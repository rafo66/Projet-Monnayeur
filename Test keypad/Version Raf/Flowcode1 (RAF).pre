
# 1 "Flowcode1 (RAF).c"

# 26 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\htc.h"
extern const char __xc8_OPTIM_SPEED;

extern double __fpnormalize(double);


# 13 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 50 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\pic16f873.h"
extern volatile unsigned char INDF @ 0x000;

asm("INDF equ 00h");




extern volatile unsigned char TMR0 @ 0x001;

asm("TMR0 equ 01h");




extern volatile unsigned char PCL @ 0x002;

asm("PCL equ 02h");




extern volatile unsigned char STATUS @ 0x003;

asm("STATUS equ 03h");


typedef union {
struct {
unsigned C :1;
unsigned DC :1;
unsigned Z :1;
unsigned nPD :1;
unsigned nTO :1;
unsigned RP :2;
unsigned IRP :1;
};
struct {
unsigned :5;
unsigned RP0 :1;
unsigned RP1 :1;
};
struct {
unsigned CARRY :1;
unsigned :1;
unsigned ZERO :1;
};
} STATUSbits_t;
extern volatile STATUSbits_t STATUSbits @ 0x003;

# 157
extern volatile unsigned char FSR @ 0x004;

asm("FSR equ 04h");




extern volatile unsigned char PORTA @ 0x005;

asm("PORTA equ 05h");


typedef union {
struct {
unsigned RA0 :1;
unsigned RA1 :1;
unsigned RA2 :1;
unsigned RA3 :1;
unsigned RA4 :1;
unsigned RA5 :1;
};
} PORTAbits_t;
extern volatile PORTAbits_t PORTAbits @ 0x005;

# 214
extern volatile unsigned char PORTB @ 0x006;

asm("PORTB equ 06h");


typedef union {
struct {
unsigned RB0 :1;
unsigned RB1 :1;
unsigned RB2 :1;
unsigned RB3 :1;
unsigned RB4 :1;
unsigned RB5 :1;
unsigned RB6 :1;
unsigned RB7 :1;
};
} PORTBbits_t;
extern volatile PORTBbits_t PORTBbits @ 0x006;

# 276
extern volatile unsigned char PORTC @ 0x007;

asm("PORTC equ 07h");


typedef union {
struct {
unsigned RC0 :1;
unsigned RC1 :1;
unsigned RC2 :1;
unsigned RC3 :1;
unsigned RC4 :1;
unsigned RC5 :1;
unsigned RC6 :1;
unsigned RC7 :1;
};
} PORTCbits_t;
extern volatile PORTCbits_t PORTCbits @ 0x007;

# 338
extern volatile unsigned char PCLATH @ 0x00A;

asm("PCLATH equ 0Ah");


typedef union {
struct {
unsigned PCLATH :5;
};
} PCLATHbits_t;
extern volatile PCLATHbits_t PCLATHbits @ 0x00A;

# 358
extern volatile unsigned char INTCON @ 0x00B;

asm("INTCON equ 0Bh");


typedef union {
struct {
unsigned RBIF :1;
unsigned INTF :1;
unsigned T0IF :1;
unsigned RBIE :1;
unsigned INTE :1;
unsigned T0IE :1;
unsigned PEIE :1;
unsigned GIE :1;
};
struct {
unsigned :2;
unsigned TMR0IF :1;
unsigned :2;
unsigned TMR0IE :1;
};
} INTCONbits_t;
extern volatile INTCONbits_t INTCONbits @ 0x00B;

# 436
extern volatile unsigned char PIR1 @ 0x00C;

asm("PIR1 equ 0Ch");


typedef union {
struct {
unsigned TMR1IF :1;
unsigned TMR2IF :1;
unsigned CCP1IF :1;
unsigned SSPIF :1;
unsigned TXIF :1;
unsigned RCIF :1;
unsigned ADIF :1;
};
} PIR1bits_t;
extern volatile PIR1bits_t PIR1bits @ 0x00C;

# 492
extern volatile unsigned char PIR2 @ 0x00D;

asm("PIR2 equ 0Dh");


typedef union {
struct {
unsigned CCP2IF :1;
unsigned :2;
unsigned BCLIF :1;
unsigned EEIF :1;
};
} PIR2bits_t;
extern volatile PIR2bits_t PIR2bits @ 0x00D;

# 525
extern volatile unsigned short TMR1 @ 0x00E;

asm("TMR1 equ 0Eh");




extern volatile unsigned char TMR1L @ 0x00E;

asm("TMR1L equ 0Eh");




extern volatile unsigned char TMR1H @ 0x00F;

asm("TMR1H equ 0Fh");




extern volatile unsigned char T1CON @ 0x010;

asm("T1CON equ 010h");


typedef union {
struct {
unsigned TMR1ON :1;
unsigned TMR1CS :1;
unsigned nT1SYNC :1;
unsigned T1OSCEN :1;
unsigned T1CKPS :2;
};
struct {
unsigned :4;
unsigned T1CKPS0 :1;
unsigned T1CKPS1 :1;
};
struct {
unsigned :2;
unsigned T1INSYNC :1;
};
struct {
unsigned :2;
unsigned T1SYNC :1;
};
} T1CONbits_t;
extern volatile T1CONbits_t T1CONbits @ 0x010;

# 623
extern volatile unsigned char TMR2 @ 0x011;

asm("TMR2 equ 011h");




extern volatile unsigned char T2CON @ 0x012;

asm("T2CON equ 012h");


typedef union {
struct {
unsigned T2CKPS :2;
unsigned TMR2ON :1;
unsigned TOUTPS :4;
};
struct {
unsigned T2CKPS0 :1;
unsigned T2CKPS1 :1;
unsigned :1;
unsigned TOUTPS0 :1;
unsigned TOUTPS1 :1;
unsigned TOUTPS2 :1;
unsigned TOUTPS3 :1;
};
} T2CONbits_t;
extern volatile T2CONbits_t T2CONbits @ 0x012;

# 701
extern volatile unsigned char SSPBUF @ 0x013;

asm("SSPBUF equ 013h");




extern volatile unsigned char SSPCON @ 0x014;

asm("SSPCON equ 014h");


typedef union {
struct {
unsigned SSPM :4;
unsigned CKP :1;
unsigned SSPEN :1;
unsigned SSPOV :1;
unsigned WCOL :1;
};
struct {
unsigned SSPM0 :1;
unsigned SSPM1 :1;
unsigned SSPM2 :1;
unsigned SSPM3 :1;
};
} SSPCONbits_t;
extern volatile SSPCONbits_t SSPCONbits @ 0x014;

# 778
extern volatile unsigned short CCPR1 @ 0x015;

asm("CCPR1 equ 015h");




extern volatile unsigned char CCPR1L @ 0x015;

asm("CCPR1L equ 015h");




extern volatile unsigned char CCPR1H @ 0x016;

asm("CCPR1H equ 016h");




extern volatile unsigned char CCP1CON @ 0x017;

asm("CCP1CON equ 017h");


typedef union {
struct {
unsigned CCP1M :4;
unsigned CCP1Y :1;
unsigned CCP1X :1;
};
struct {
unsigned CCP1M0 :1;
unsigned CCP1M1 :1;
unsigned CCP1M2 :1;
unsigned CCP1M3 :1;
};
} CCP1CONbits_t;
extern volatile CCP1CONbits_t CCP1CONbits @ 0x017;

# 857
extern volatile unsigned char RCSTA @ 0x018;

asm("RCSTA equ 018h");


typedef union {
struct {
unsigned RX9D :1;
unsigned OERR :1;
unsigned FERR :1;
unsigned ADDEN :1;
unsigned CREN :1;
unsigned SREN :1;
unsigned RX9 :1;
unsigned SPEN :1;
};
struct {
unsigned RCD8 :1;
unsigned :5;
unsigned RC9 :1;
};
struct {
unsigned :6;
unsigned nRC8 :1;
};
struct {
unsigned :6;
unsigned RC8_9 :1;
};
} RCSTAbits_t;
extern volatile RCSTAbits_t RCSTAbits @ 0x018;

# 952
extern volatile unsigned char TXREG @ 0x019;

asm("TXREG equ 019h");




extern volatile unsigned char RCREG @ 0x01A;

asm("RCREG equ 01Ah");




extern volatile unsigned short CCPR2 @ 0x01B;

asm("CCPR2 equ 01Bh");




extern volatile unsigned char CCPR2L @ 0x01B;

asm("CCPR2L equ 01Bh");




extern volatile unsigned char CCPR2H @ 0x01C;

asm("CCPR2H equ 01Ch");




extern volatile unsigned char CCP2CON @ 0x01D;

asm("CCP2CON equ 01Dh");


typedef union {
struct {
unsigned CCP2M :4;
unsigned CCP2Y :1;
unsigned CCP2X :1;
};
struct {
unsigned CCP2M0 :1;
unsigned CCP2M1 :1;
unsigned CCP2M2 :1;
unsigned CCP2M3 :1;
};
} CCP2CONbits_t;
extern volatile CCP2CONbits_t CCP2CONbits @ 0x01D;

# 1045
extern volatile unsigned char ADRESH @ 0x01E;

asm("ADRESH equ 01Eh");




extern volatile unsigned char ADCON0 @ 0x01F;

asm("ADCON0 equ 01Fh");


typedef union {
struct {
unsigned ADON :1;
unsigned :1;
unsigned GO_nDONE :1;
unsigned CHS :3;
unsigned ADCS :2;
};
struct {
unsigned :2;
unsigned GO :1;
unsigned CHS0 :1;
unsigned CHS1 :1;
unsigned CHS2 :1;
unsigned ADCS0 :1;
unsigned ADCS1 :1;
};
struct {
unsigned :2;
unsigned nDONE :1;
};
struct {
unsigned :2;
unsigned GO_DONE :1;
};
} ADCON0bits_t;
extern volatile ADCON0bits_t ADCON0bits @ 0x01F;

# 1148
extern volatile unsigned char OPTION_REG @ 0x081;

asm("OPTION_REG equ 081h");


typedef union {
struct {
unsigned PS :3;
unsigned PSA :1;
unsigned T0SE :1;
unsigned T0CS :1;
unsigned INTEDG :1;
unsigned nRBPU :1;
};
struct {
unsigned PS0 :1;
unsigned PS1 :1;
unsigned PS2 :1;
};
} OPTION_REGbits_t;
extern volatile OPTION_REGbits_t OPTION_REGbits @ 0x081;

# 1218
extern volatile unsigned char TRISA @ 0x085;

asm("TRISA equ 085h");


typedef union {
struct {
unsigned TRISA0 :1;
unsigned TRISA1 :1;
unsigned TRISA2 :1;
unsigned TRISA3 :1;
unsigned TRISA4 :1;
unsigned TRISA5 :1;
};
} TRISAbits_t;
extern volatile TRISAbits_t TRISAbits @ 0x085;

# 1268
extern volatile unsigned char TRISB @ 0x086;

asm("TRISB equ 086h");


typedef union {
struct {
unsigned TRISB0 :1;
unsigned TRISB1 :1;
unsigned TRISB2 :1;
unsigned TRISB3 :1;
unsigned TRISB4 :1;
unsigned TRISB5 :1;
unsigned TRISB6 :1;
unsigned TRISB7 :1;
};
} TRISBbits_t;
extern volatile TRISBbits_t TRISBbits @ 0x086;

# 1330
extern volatile unsigned char TRISC @ 0x087;

asm("TRISC equ 087h");


typedef union {
struct {
unsigned TRISC0 :1;
unsigned TRISC1 :1;
unsigned TRISC2 :1;
unsigned TRISC3 :1;
unsigned TRISC4 :1;
unsigned TRISC5 :1;
unsigned TRISC6 :1;
unsigned TRISC7 :1;
};
} TRISCbits_t;
extern volatile TRISCbits_t TRISCbits @ 0x087;

# 1392
extern volatile unsigned char PIE1 @ 0x08C;

asm("PIE1 equ 08Ch");


typedef union {
struct {
unsigned TMR1IE :1;
unsigned TMR2IE :1;
unsigned CCP1IE :1;
unsigned SSPIE :1;
unsigned TXIE :1;
unsigned RCIE :1;
unsigned ADIE :1;
};
} PIE1bits_t;
extern volatile PIE1bits_t PIE1bits @ 0x08C;

# 1448
extern volatile unsigned char PIE2 @ 0x08D;

asm("PIE2 equ 08Dh");


typedef union {
struct {
unsigned CCP2IE :1;
unsigned :2;
unsigned BCLIE :1;
unsigned EEIE :1;
};
} PIE2bits_t;
extern volatile PIE2bits_t PIE2bits @ 0x08D;

# 1481
extern volatile unsigned char PCON @ 0x08E;

asm("PCON equ 08Eh");


typedef union {
struct {
unsigned nBOR :1;
unsigned nPOR :1;
};
struct {
unsigned nBO :1;
};
} PCONbits_t;
extern volatile PCONbits_t PCONbits @ 0x08E;

# 1515
extern volatile unsigned char SSPCON2 @ 0x091;

asm("SSPCON2 equ 091h");


typedef union {
struct {
unsigned SEN :1;
unsigned RSEN :1;
unsigned PEN :1;
unsigned RCEN :1;
unsigned ACKEN :1;
unsigned ACKDT :1;
unsigned ACKSTAT :1;
unsigned GCEN :1;
};
} SSPCON2bits_t;
extern volatile SSPCON2bits_t SSPCON2bits @ 0x091;

# 1577
extern volatile unsigned char PR2 @ 0x092;

asm("PR2 equ 092h");




extern volatile unsigned char SSPADD @ 0x093;

asm("SSPADD equ 093h");




extern volatile unsigned char SSPSTAT @ 0x094;

asm("SSPSTAT equ 094h");


typedef union {
struct {
unsigned BF :1;
unsigned UA :1;
unsigned R_nW :1;
unsigned S :1;
unsigned P :1;
unsigned D_nA :1;
unsigned CKE :1;
unsigned SMP :1;
};
struct {
unsigned :2;
unsigned R :1;
unsigned :2;
unsigned D :1;
};
struct {
unsigned :2;
unsigned I2C_READ :1;
unsigned I2C_START :1;
unsigned I2C_STOP :1;
unsigned I2C_DATA :1;
};
struct {
unsigned :2;
unsigned nW :1;
unsigned :2;
unsigned nA :1;
};
struct {
unsigned :2;
unsigned nWRITE :1;
unsigned :2;
unsigned nADDRESS :1;
};
struct {
unsigned :2;
unsigned R_W :1;
unsigned :2;
unsigned D_A :1;
};
struct {
unsigned :2;
unsigned READ_WRITE :1;
unsigned :2;
unsigned DATA_ADDRESS :1;
};
} SSPSTATbits_t;
extern volatile SSPSTATbits_t SSPSTATbits @ 0x094;

# 1760
extern volatile unsigned char TXSTA @ 0x098;

asm("TXSTA equ 098h");


typedef union {
struct {
unsigned TX9D :1;
unsigned TRMT :1;
unsigned BRGH :1;
unsigned :1;
unsigned SYNC :1;
unsigned TXEN :1;
unsigned TX9 :1;
unsigned CSRC :1;
};
struct {
unsigned TXD8 :1;
unsigned :5;
unsigned nTX8 :1;
};
struct {
unsigned :6;
unsigned TX8_9 :1;
};
} TXSTAbits_t;
extern volatile TXSTAbits_t TXSTAbits @ 0x098;

# 1841
extern volatile unsigned char SPBRG @ 0x099;

asm("SPBRG equ 099h");




extern volatile unsigned char ADRESL @ 0x09E;

asm("ADRESL equ 09Eh");




extern volatile unsigned char ADCON1 @ 0x09F;

asm("ADCON1 equ 09Fh");


typedef union {
struct {
unsigned PCFG :4;
unsigned :3;
unsigned ADFM :1;
};
struct {
unsigned PCFG0 :1;
unsigned PCFG1 :1;
unsigned PCFG2 :1;
unsigned PCFG3 :1;
};
} ADCON1bits_t;
extern volatile ADCON1bits_t ADCON1bits @ 0x09F;

# 1908
extern volatile unsigned char EEDATA @ 0x10C;

asm("EEDATA equ 010Ch");




extern volatile unsigned char EEADR @ 0x10D;

asm("EEADR equ 010Dh");




extern volatile unsigned char EEDATH @ 0x10E;

asm("EEDATH equ 010Eh");




extern volatile unsigned char EEADRH @ 0x10F;

asm("EEADRH equ 010Fh");




extern volatile unsigned char EECON1 @ 0x18C;

asm("EECON1 equ 018Ch");


typedef union {
struct {
unsigned RD :1;
unsigned WR :1;
unsigned WREN :1;
unsigned WRERR :1;
unsigned :3;
unsigned EEPGD :1;
};
} EECON1bits_t;
extern volatile EECON1bits_t EECON1bits @ 0x18C;

# 1981
extern volatile unsigned char EECON2 @ 0x18D;

asm("EECON2 equ 018Dh");

# 1993
extern volatile __bit ACKDT @ (((unsigned) &SSPCON2)*8) + 5;

extern volatile __bit ACKEN @ (((unsigned) &SSPCON2)*8) + 4;

extern volatile __bit ACKSTAT @ (((unsigned) &SSPCON2)*8) + 6;

extern volatile __bit ADCS0 @ (((unsigned) &ADCON0)*8) + 6;

extern volatile __bit ADCS1 @ (((unsigned) &ADCON0)*8) + 7;

extern volatile __bit ADDEN @ (((unsigned) &RCSTA)*8) + 3;

extern volatile __bit ADFM @ (((unsigned) &ADCON1)*8) + 7;

extern volatile __bit ADIE @ (((unsigned) &PIE1)*8) + 6;

extern volatile __bit ADIF @ (((unsigned) &PIR1)*8) + 6;

extern volatile __bit ADON @ (((unsigned) &ADCON0)*8) + 0;

extern volatile __bit BCLIE @ (((unsigned) &PIE2)*8) + 3;

extern volatile __bit BCLIF @ (((unsigned) &PIR2)*8) + 3;

extern volatile __bit BF @ (((unsigned) &SSPSTAT)*8) + 0;

extern volatile __bit BRGH @ (((unsigned) &TXSTA)*8) + 2;

extern volatile __bit CARRY @ (((unsigned) &STATUS)*8) + 0;

extern volatile __bit CCP1IE @ (((unsigned) &PIE1)*8) + 2;

extern volatile __bit CCP1IF @ (((unsigned) &PIR1)*8) + 2;

extern volatile __bit CCP1M0 @ (((unsigned) &CCP1CON)*8) + 0;

extern volatile __bit CCP1M1 @ (((unsigned) &CCP1CON)*8) + 1;

extern volatile __bit CCP1M2 @ (((unsigned) &CCP1CON)*8) + 2;

extern volatile __bit CCP1M3 @ (((unsigned) &CCP1CON)*8) + 3;

extern volatile __bit CCP1X @ (((unsigned) &CCP1CON)*8) + 5;

extern volatile __bit CCP1Y @ (((unsigned) &CCP1CON)*8) + 4;

extern volatile __bit CCP2IE @ (((unsigned) &PIE2)*8) + 0;

extern volatile __bit CCP2IF @ (((unsigned) &PIR2)*8) + 0;

extern volatile __bit CCP2M0 @ (((unsigned) &CCP2CON)*8) + 0;

extern volatile __bit CCP2M1 @ (((unsigned) &CCP2CON)*8) + 1;

extern volatile __bit CCP2M2 @ (((unsigned) &CCP2CON)*8) + 2;

extern volatile __bit CCP2M3 @ (((unsigned) &CCP2CON)*8) + 3;

extern volatile __bit CCP2X @ (((unsigned) &CCP2CON)*8) + 5;

extern volatile __bit CCP2Y @ (((unsigned) &CCP2CON)*8) + 4;

extern volatile __bit CHS0 @ (((unsigned) &ADCON0)*8) + 3;

extern volatile __bit CHS1 @ (((unsigned) &ADCON0)*8) + 4;

extern volatile __bit CHS2 @ (((unsigned) &ADCON0)*8) + 5;

extern volatile __bit CKE @ (((unsigned) &SSPSTAT)*8) + 6;

extern volatile __bit CKP @ (((unsigned) &SSPCON)*8) + 4;

extern volatile __bit CREN @ (((unsigned) &RCSTA)*8) + 4;

extern volatile __bit CSRC @ (((unsigned) &TXSTA)*8) + 7;

extern volatile __bit DATA_ADDRESS @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit DC @ (((unsigned) &STATUS)*8) + 1;

extern volatile __bit D_A @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit D_nA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit EEIE @ (((unsigned) &PIE2)*8) + 4;

extern volatile __bit EEIF @ (((unsigned) &PIR2)*8) + 4;

extern volatile __bit EEPGD @ (((unsigned) &EECON1)*8) + 7;

extern volatile __bit FERR @ (((unsigned) &RCSTA)*8) + 2;

extern volatile __bit GCEN @ (((unsigned) &SSPCON2)*8) + 7;

extern volatile __bit GIE @ (((unsigned) &INTCON)*8) + 7;

extern volatile __bit GO @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit GO_DONE @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit GO_nDONE @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit I2C_DATA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit I2C_READ @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit I2C_START @ (((unsigned) &SSPSTAT)*8) + 3;

extern volatile __bit I2C_STOP @ (((unsigned) &SSPSTAT)*8) + 4;

extern volatile __bit INTE @ (((unsigned) &INTCON)*8) + 4;

extern volatile __bit INTEDG @ (((unsigned) &OPTION_REG)*8) + 6;

extern volatile __bit INTF @ (((unsigned) &INTCON)*8) + 1;

extern volatile __bit IRP @ (((unsigned) &STATUS)*8) + 7;

extern volatile __bit OERR @ (((unsigned) &RCSTA)*8) + 1;

extern volatile __bit PCFG0 @ (((unsigned) &ADCON1)*8) + 0;

extern volatile __bit PCFG1 @ (((unsigned) &ADCON1)*8) + 1;

extern volatile __bit PCFG2 @ (((unsigned) &ADCON1)*8) + 2;

extern volatile __bit PCFG3 @ (((unsigned) &ADCON1)*8) + 3;

extern volatile __bit PEIE @ (((unsigned) &INTCON)*8) + 6;

extern volatile __bit PEN @ (((unsigned) &SSPCON2)*8) + 2;

extern volatile __bit PS0 @ (((unsigned) &OPTION_REG)*8) + 0;

extern volatile __bit PS1 @ (((unsigned) &OPTION_REG)*8) + 1;

extern volatile __bit PS2 @ (((unsigned) &OPTION_REG)*8) + 2;

extern volatile __bit PSA @ (((unsigned) &OPTION_REG)*8) + 3;

extern volatile __bit RA0 @ (((unsigned) &PORTA)*8) + 0;

extern volatile __bit RA1 @ (((unsigned) &PORTA)*8) + 1;

extern volatile __bit RA2 @ (((unsigned) &PORTA)*8) + 2;

extern volatile __bit RA3 @ (((unsigned) &PORTA)*8) + 3;

extern volatile __bit RA4 @ (((unsigned) &PORTA)*8) + 4;

extern volatile __bit RA5 @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit RB0 @ (((unsigned) &PORTB)*8) + 0;

extern volatile __bit RB1 @ (((unsigned) &PORTB)*8) + 1;

extern volatile __bit RB2 @ (((unsigned) &PORTB)*8) + 2;

extern volatile __bit RB3 @ (((unsigned) &PORTB)*8) + 3;

extern volatile __bit RB4 @ (((unsigned) &PORTB)*8) + 4;

extern volatile __bit RB5 @ (((unsigned) &PORTB)*8) + 5;

extern volatile __bit RB6 @ (((unsigned) &PORTB)*8) + 6;

extern volatile __bit RB7 @ (((unsigned) &PORTB)*8) + 7;

extern volatile __bit RBIE @ (((unsigned) &INTCON)*8) + 3;

extern volatile __bit RBIF @ (((unsigned) &INTCON)*8) + 0;

extern volatile __bit RC0 @ (((unsigned) &PORTC)*8) + 0;

extern volatile __bit RC1 @ (((unsigned) &PORTC)*8) + 1;

extern volatile __bit RC2 @ (((unsigned) &PORTC)*8) + 2;

extern volatile __bit RC3 @ (((unsigned) &PORTC)*8) + 3;

extern volatile __bit RC4 @ (((unsigned) &PORTC)*8) + 4;

extern volatile __bit RC5 @ (((unsigned) &PORTC)*8) + 5;

extern volatile __bit RC6 @ (((unsigned) &PORTC)*8) + 6;

extern volatile __bit RC7 @ (((unsigned) &PORTC)*8) + 7;

extern volatile __bit RC8_9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RC9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RCD8 @ (((unsigned) &RCSTA)*8) + 0;

extern volatile __bit RCEN @ (((unsigned) &SSPCON2)*8) + 3;

extern volatile __bit RCIE @ (((unsigned) &PIE1)*8) + 5;

extern volatile __bit RCIF @ (((unsigned) &PIR1)*8) + 5;

extern volatile __bit RD @ (((unsigned) &EECON1)*8) + 0;

extern volatile __bit READ_WRITE @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit RP0 @ (((unsigned) &STATUS)*8) + 5;

extern volatile __bit RP1 @ (((unsigned) &STATUS)*8) + 6;

extern volatile __bit RSEN @ (((unsigned) &SSPCON2)*8) + 1;

extern volatile __bit RX9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RX9D @ (((unsigned) &RCSTA)*8) + 0;

extern volatile __bit R_W @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit R_nW @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit SEN @ (((unsigned) &SSPCON2)*8) + 0;

extern volatile __bit SMP @ (((unsigned) &SSPSTAT)*8) + 7;

extern volatile __bit SPEN @ (((unsigned) &RCSTA)*8) + 7;

extern volatile __bit SREN @ (((unsigned) &RCSTA)*8) + 5;

extern volatile __bit SSPEN @ (((unsigned) &SSPCON)*8) + 5;

extern volatile __bit SSPIE @ (((unsigned) &PIE1)*8) + 3;

extern volatile __bit SSPIF @ (((unsigned) &PIR1)*8) + 3;

extern volatile __bit SSPM0 @ (((unsigned) &SSPCON)*8) + 0;

extern volatile __bit SSPM1 @ (((unsigned) &SSPCON)*8) + 1;

extern volatile __bit SSPM2 @ (((unsigned) &SSPCON)*8) + 2;

extern volatile __bit SSPM3 @ (((unsigned) &SSPCON)*8) + 3;

extern volatile __bit SSPOV @ (((unsigned) &SSPCON)*8) + 6;

extern volatile __bit SYNC @ (((unsigned) &TXSTA)*8) + 4;

extern volatile __bit T0CS @ (((unsigned) &OPTION_REG)*8) + 5;

extern volatile __bit T0IE @ (((unsigned) &INTCON)*8) + 5;

extern volatile __bit T0IF @ (((unsigned) &INTCON)*8) + 2;

extern volatile __bit T0SE @ (((unsigned) &OPTION_REG)*8) + 4;

extern volatile __bit T1CKPS0 @ (((unsigned) &T1CON)*8) + 4;

extern volatile __bit T1CKPS1 @ (((unsigned) &T1CON)*8) + 5;

extern volatile __bit T1INSYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit T1OSCEN @ (((unsigned) &T1CON)*8) + 3;

extern volatile __bit T1SYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit T2CKPS0 @ (((unsigned) &T2CON)*8) + 0;

extern volatile __bit T2CKPS1 @ (((unsigned) &T2CON)*8) + 1;

extern volatile __bit TMR0IE @ (((unsigned) &INTCON)*8) + 5;

extern volatile __bit TMR0IF @ (((unsigned) &INTCON)*8) + 2;

extern volatile __bit TMR1CS @ (((unsigned) &T1CON)*8) + 1;

extern volatile __bit TMR1IE @ (((unsigned) &PIE1)*8) + 0;

extern volatile __bit TMR1IF @ (((unsigned) &PIR1)*8) + 0;

extern volatile __bit TMR1ON @ (((unsigned) &T1CON)*8) + 0;

extern volatile __bit TMR2IE @ (((unsigned) &PIE1)*8) + 1;

extern volatile __bit TMR2IF @ (((unsigned) &PIR1)*8) + 1;

extern volatile __bit TMR2ON @ (((unsigned) &T2CON)*8) + 2;

extern volatile __bit TOUTPS0 @ (((unsigned) &T2CON)*8) + 3;

extern volatile __bit TOUTPS1 @ (((unsigned) &T2CON)*8) + 4;

extern volatile __bit TOUTPS2 @ (((unsigned) &T2CON)*8) + 5;

extern volatile __bit TOUTPS3 @ (((unsigned) &T2CON)*8) + 6;

extern volatile __bit TRISA0 @ (((unsigned) &TRISA)*8) + 0;

extern volatile __bit TRISA1 @ (((unsigned) &TRISA)*8) + 1;

extern volatile __bit TRISA2 @ (((unsigned) &TRISA)*8) + 2;

extern volatile __bit TRISA3 @ (((unsigned) &TRISA)*8) + 3;

extern volatile __bit TRISA4 @ (((unsigned) &TRISA)*8) + 4;

extern volatile __bit TRISA5 @ (((unsigned) &TRISA)*8) + 5;

extern volatile __bit TRISB0 @ (((unsigned) &TRISB)*8) + 0;

extern volatile __bit TRISB1 @ (((unsigned) &TRISB)*8) + 1;

extern volatile __bit TRISB2 @ (((unsigned) &TRISB)*8) + 2;

extern volatile __bit TRISB3 @ (((unsigned) &TRISB)*8) + 3;

extern volatile __bit TRISB4 @ (((unsigned) &TRISB)*8) + 4;

extern volatile __bit TRISB5 @ (((unsigned) &TRISB)*8) + 5;

extern volatile __bit TRISB6 @ (((unsigned) &TRISB)*8) + 6;

extern volatile __bit TRISB7 @ (((unsigned) &TRISB)*8) + 7;

extern volatile __bit TRISC0 @ (((unsigned) &TRISC)*8) + 0;

extern volatile __bit TRISC1 @ (((unsigned) &TRISC)*8) + 1;

extern volatile __bit TRISC2 @ (((unsigned) &TRISC)*8) + 2;

extern volatile __bit TRISC3 @ (((unsigned) &TRISC)*8) + 3;

extern volatile __bit TRISC4 @ (((unsigned) &TRISC)*8) + 4;

extern volatile __bit TRISC5 @ (((unsigned) &TRISC)*8) + 5;

extern volatile __bit TRISC6 @ (((unsigned) &TRISC)*8) + 6;

extern volatile __bit TRISC7 @ (((unsigned) &TRISC)*8) + 7;

extern volatile __bit TRMT @ (((unsigned) &TXSTA)*8) + 1;

extern volatile __bit TX8_9 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit TX9 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit TX9D @ (((unsigned) &TXSTA)*8) + 0;

extern volatile __bit TXD8 @ (((unsigned) &TXSTA)*8) + 0;

extern volatile __bit TXEN @ (((unsigned) &TXSTA)*8) + 5;

extern volatile __bit TXIE @ (((unsigned) &PIE1)*8) + 4;

extern volatile __bit TXIF @ (((unsigned) &PIR1)*8) + 4;

extern volatile __bit UA @ (((unsigned) &SSPSTAT)*8) + 1;

extern volatile __bit WCOL @ (((unsigned) &SSPCON)*8) + 7;

extern volatile __bit WR @ (((unsigned) &EECON1)*8) + 1;

extern volatile __bit WREN @ (((unsigned) &EECON1)*8) + 2;

extern volatile __bit WRERR @ (((unsigned) &EECON1)*8) + 3;

extern volatile __bit ZERO @ (((unsigned) &STATUS)*8) + 2;

extern volatile __bit nA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit nADDRESS @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit nBO @ (((unsigned) &PCON)*8) + 0;

extern volatile __bit nBOR @ (((unsigned) &PCON)*8) + 0;

extern volatile __bit nDONE @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit nPD @ (((unsigned) &STATUS)*8) + 3;

extern volatile __bit nPOR @ (((unsigned) &PCON)*8) + 1;

extern volatile __bit nRBPU @ (((unsigned) &OPTION_REG)*8) + 7;

extern volatile __bit nRC8 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit nT1SYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit nTO @ (((unsigned) &STATUS)*8) + 4;

extern volatile __bit nTX8 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit nW @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit nWRITE @ (((unsigned) &SSPSTAT)*8) + 2;


# 28 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\pic.h"
#pragma intrinsic(__nop)
extern void __nop(void);

# 78
extern unsigned int flash_read(unsigned short addr);

# 114 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\eeprom_routines.h"
extern void eeprom_write(unsigned char addr, unsigned char value);
extern unsigned char eeprom_read(unsigned char addr);
extern void eecpymem(volatile unsigned char *to, __eeprom unsigned char *from, unsigned char size);
extern void memcpyee(__eeprom unsigned char *to, const unsigned char *from, unsigned char size);


# 152 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\pic.h"
#pragma intrinsic(_delay)
extern __nonreentrant void _delay(unsigned long);
#pragma intrinsic(_delaywdt)
extern __nonreentrant void _delaywdt(unsigned long);

# 193
extern __bank0 unsigned char __resetbits;
extern __bank0 __bit __powerdown;
extern __bank0 __bit __timeout;

# 30 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\math.h"
extern double fabs(double);
extern double floor(double);
extern double ceil(double);
extern double modf(double, double *);
extern double sqrt(double);
extern double atof(const char *);
extern double sin(double) ;
extern double cos(double) ;
extern double tan(double) ;
extern double asin(double) ;
extern double acos(double) ;
extern double atan(double);
extern double atan2(double, double) ;
extern double log(double);
extern double log10(double);
extern double pow(double, double) ;
extern double exp(double) ;
extern double sinh(double) ;
extern double cosh(double) ;
extern double tanh(double);
extern double eval_poly(double, const double *, int);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double fmod(double, double);
extern double trunc(double);
extern double round(double);

# 34 "Flowcode1 (RAF).c"
__config("__PROG_CONFIG", "pic", 0x1, 0x3FF9);

# 76 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\internals.c"
unsigned char FCI_TMP_STR[20];
int FCI_TMP_INT;

# 46 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_TypeDefs.c"
typedef signed char MX_SINT8;
typedef signed short MX_SINT16;
typedef signed long MX_SINT32;
typedef unsigned char MX_UINT8;
typedef unsigned short MX_UINT16;
typedef unsigned long MX_UINT32;
typedef char MX_CHAR;
typedef MX_UINT16 MX_UINT;
typedef MX_SINT16 MX_SINT;




typedef MX_UINT8 MX_BOOL;

typedef double MX_FLOAT;




typedef union
{
MX_UINT32 AsLong;
MX_UINT16 AsInt[2];
MX_UINT8 AsByte[4];
} MX_Union32;

typedef union
{
MX_UINT16 AsInt;
MX_UINT8 AsByte[2];
} MX_Union16;

# 197 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_IO.c"
void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
{
*Port = (*Port & ~OutMask) | (OutValue & OutMask);
}


void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
{
*Tris = *Tris & (~OutMask);
*Port = (*Port & ~OutMask) | (OutValue & OutMask);
}


MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
{
return (*Port & InMask) >> Shift;
}


inline MX_UINT8 FC_CAL_Port_In_DDR__x (volatile MX_UINT8* Port,volatile MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
{
*Tris = *Tris | InMask;
return (*Port & InMask) >> Shift;
}

# 44 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_Delay.c"
void Wdt_Delay_S(MX_UINT8 delay);
void Wdt_Delay_Ms(MX_UINT8 delay);

# 57
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);




void delay_10us(MX_UINT8 del);
void delay_us(MX_UINT8 del);
void delay_ms(MX_UINT8 del);
void delay_s(MX_UINT8 del);



void delay_10us(MX_UINT8 del)
{
while (del--)
{
_delay((unsigned long)((10)*(1000000/4000000.0)));
}
}



void delay_us(MX_UINT8 del)
{
while (del > 99)
{
_delay((unsigned long)((100)*(1000000/4000000.0)));
del -= 100;
}
while (del > 9)
{
_delay((unsigned long)((10)*(1000000/4000000.0)));
del -= 10;
}
while (del--)
{
_delay((unsigned long)((1)*(1000000/4000000.0)));
}
}



void delay_ms(MX_UINT8 del)
{
while (del--)
{
_delay((unsigned long)((1)*(1000000/4000.0)));
}
}


void delay_s(MX_UINT8 del)
{
MX_UINT8 i;
for(i=0; i<del; i++)
{
delay_ms(250);
delay_ms(250);
delay_ms(250);
delay_ms(250);
}
}



void Wdt_Delay_S(MX_UINT8 delay)
{
MX_UINT8 i;
MX_UINT16 j;
for (i=0; i<delay; i++)
{
for (j=0; j<999; j++)
{
Wdt_Delay_Ms(1);
}
}
}

void Wdt_Delay_Ms(MX_UINT8 delay)
{
MX_UINT8 i;
for (i=0; i<delay; i++)
{
asm("clrwdt");
delay_ms(1);
}
}


void FCI_DELAYINT_US(MX_UINT16 Delay)
{
while (Delay > 255)
{
delay_us(255);
Delay = Delay - 255;
}
if (Delay > 0)
delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
while (Delay > 255)
{
delay_ms(255);
Delay = Delay - 255;
}
if (Delay > 0)
delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
while (Delay > 255)
{
Wdt_Delay_Ms(255);
Delay = Delay - 255;
}
if (Delay > 0)
Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
while (Delay > 255)
{
delay_s(255);
Delay = Delay - 255;
}
if (Delay > 0)
delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
while (Delay > 255)
{
Wdt_Delay_S(255);
Delay = Delay - 255;
}
if (Delay > 0)
Wdt_Delay_S(Delay & 0xFF);
}

# 93 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_String.c"
MX_UINT8 FCI_GETCHAR(unsigned char* sStr1, MX_UINT16 iStr1_len, MX_UINT16 iPos);
MX_UINT16 FCI_GETLENGTH(unsigned char* sStr1, MX_UINT16 iStr1_len);
unsigned char* FCI_MIDSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iStart, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len);
unsigned char* FCI_LEFTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len);
unsigned char* FCI_RIGHTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len);
unsigned char* FCI_TOSTRING(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);

void FCI_TOLOWER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
void FCI_TOUPPER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_COMPARE(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, MX_UINT8 iNoCase);
unsigned char* FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, unsigned char* String, MX_UINT16 MSZ_String);
unsigned char* FCI_NUMBER_TO_HEX(MX_UINT32 Number, unsigned char* String, MX_UINT16 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(unsigned char* String, MX_UINT16 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(unsigned char* String, MX_UINT16 MSZ_String);


MX_UINT8 FCI_STRREV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_STRMOV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
void FCI_SHEAD(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, unsigned char* sDst, MX_UINT16 iDst_len);
void FCI_SCOPY(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);

# 4 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\__size_t.h"
typedef unsigned size_t;

# 7 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\stdlib.h"
typedef unsigned short wchar_t;

# 15
typedef struct {
int rem;
int quot;
} div_t;
typedef struct {
unsigned rem;
unsigned quot;
} udiv_t;
typedef struct {
long quot;
long rem;
} ldiv_t;
typedef struct {
unsigned long quot;
unsigned long rem;
} uldiv_t;

# 53
extern double atof(const char *);
extern double strtod(const char *, const char **);
extern int atoi(const char *);
extern unsigned xtoi(const char *);
extern long atol(const char *);
extern long strtol(const char *, char **, int);

extern int rand(void);
extern void srand(unsigned int);
extern void * calloc(size_t, size_t);
extern div_t div(int numer, int denom);
extern udiv_t udiv(unsigned numer, unsigned denom);
extern ldiv_t ldiv(long numer, long denom);
extern uldiv_t uldiv(unsigned long numer,unsigned long denom);
extern unsigned long _lrotl(unsigned long value, unsigned int shift);
extern unsigned long _lrotr(unsigned long value, unsigned int shift);
extern unsigned int _rotl(unsigned int value, unsigned int shift);
extern unsigned int _rotr(unsigned int value, unsigned int shift);




extern void * malloc(size_t);
extern void free(void *);
extern void * realloc(void *, size_t);

# 86
extern int atexit(void (*)(void));
extern char * getenv(const char *);
extern char ** environ;
extern int system(char *);
extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
extern void * bsearch(const void *, void *, size_t, size_t, int(*)(const void *, const void *));
extern int abs(int);
extern long labs(long);

extern char * itoa(char * buf, int val, int base);
extern char * utoa(char * buf, unsigned val, int base);




extern char * ltoa(char * buf, long val, int base);
extern char * ultoa(char * buf, unsigned long val, int base);

extern char * ftoa(float f, int * status);

# 124 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_String.c"
MX_UINT8 FCI_GETCHAR(unsigned char* sStr1, MX_UINT16 iStr1_len, MX_UINT16 iPos)
{
if(iPos < iStr1_len)
return sStr1[iPos];
return '\0';
}


MX_UINT16 FCI_GETLENGTH(unsigned char* sStr1, MX_UINT16 iStr1_len)
{
MX_UINT16 tmp;
for (tmp = 0; tmp < iStr1_len; tmp++) if (sStr1[tmp] == 0) break;
return (tmp);
}


unsigned char* FCI_MIDSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iStart, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return sDst;
MX_UINT16 idx;
for (idx = 0; idx < iSrc_len; idx++) if (sSrc[idx] == 0) break;

if (iStart >= idx)
{
sDst[0] = '\0';
}
else
{
if ((iStart + iCount) >= idx)
iCount = idx - iStart;
if (iCount > (iDst_len))
iCount = (iDst_len);

for (idx = 0; idx < iCount; idx++)
{
sDst[idx] = sSrc[idx + iStart];
}
if (idx < iDst_len)
{
sDst[idx] = '\0';
}
}
return (sDst);
}


unsigned char* FCI_LEFTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return sDst;
MX_UINT16 idx;
for (idx = 0; idx < iSrc_len; idx++) if (sSrc[idx] == 0) break;

if (iCount > idx)
iCount = idx;
if (iCount > (iDst_len))
iCount = (iDst_len);

for (idx = 0; idx < iCount; idx++)
{
sDst[idx] = sSrc[idx];
}

if (idx < iDst_len)
sDst[idx] = '\0';

return (sDst);
}


unsigned char* FCI_RIGHTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return sDst;
MX_UINT16 idx;
MX_UINT16 delta;

for (idx = 0; idx < iSrc_len; idx++) if (sSrc[idx] == 0) break;

if (iCount > idx)
iCount = idx;

delta = idx - iCount;

if (iCount > (iDst_len))
iCount = (iDst_len);

for(idx = 0; idx < iCount; idx++)
{
sDst[idx] = sSrc[idx + delta];
}

if (idx < iDst_len)
sDst[idx] = '\0';

return (sDst);
}



MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_SINT16 iSrc = iSrc1;
MX_UINT16 top = 10000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;



if (iSrc < 0)
{
sDst[0] = '-';
idx++;
iSrc = -iSrc;
}

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_SINT32 iSrc = iSrc1;
MX_UINT32 top = 1000000000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;



if (iSrc < 0)
{
sDst[0] = '-';
idx++;
iSrc = -iSrc;
}

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned long)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned long)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_UINT16 iSrc = iSrc1;
MX_UINT16 top = 10000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_UINT32 iSrc = iSrc1;
MX_UINT32 top = 1000000000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned long)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned long)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}



unsigned char* FCI_TOSTRING(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;

MX_SINT32 iSrc = iSrc1;


unsigned long top = 1000000000;

# 389
MX_UINT8 idx = 0;

if (iDst_len == 0) return sDst;



if (iSrc < 0)
{
sDst[0] = '-';
idx++;
iSrc = -iSrc;
}

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{

if (((unsigned long)iSrc >= top) || (tmp1))

# 415
{

tmp1 = (unsigned long)iSrc / top;

# 421
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (sDst);
}


void FCI_TOLOWER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return;
MX_UINT16 idx;
MX_UINT16 ch;

if (iSrc_len < iDst_len) iSrc_len = iDst_len;

for (idx=0; idx<iSrc_len; idx++)
{
ch = sSrc[idx];
if ((ch >= 'A') && (ch <= 'Z'))
{
ch ^= 0x20;
}
sDst[idx] = ch;
if (ch == 0)
{
break;
}
}
if (idx < iDst_len)
sDst[idx] = '\0';
}


void FCI_TOUPPER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return;
MX_UINT16 idx;
MX_UINT16 ch;

if (iSrc_len < iDst_len) iSrc_len = iDst_len;

for (idx=0; idx<iSrc_len; idx++)
{
ch = sSrc[idx];
if ((ch >= 'a') && (ch <= 'z'))
{
ch ^= 0x20;
}
sDst[idx] = ch;
if (ch == 0)
{
break;
}
}
if (idx < iDst_len)
sDst[idx] = '\0';
}


MX_UINT8 FCI_COMPARE(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, MX_UINT8 iNoCase)
{
MX_UINT16 idx = 0;
MX_UINT8 ch1, ch2;

while ((idx < iSrc1_len)&&(idx < iSrc2_len))
{
ch1 = sSrc1[idx];
ch2 = sSrc2[idx];

if (iNoCase)
{
if ((ch1 >= 'a') && (ch1 <= 'z'))
ch1 = (ch1 & 0xDF);

if ((ch2 >= 'a') && (ch2 <= 'z'))
ch2 = (ch2 & 0xDF);
}

if (ch2 == 0)
{
if (ch1 == 0)
return (0);
else
return (1);
}
else if (ch1 == 0)
return (255);
else if (ch1 < ch2)
return(255);
else if (ch1 > ch2)
return(1);

++idx;
}


if (iSrc1_len > iSrc2_len)
{
if (sSrc1[idx] == 0)
return (0);
else
return (1);
}
else if (iSrc1_len < iSrc2_len)
{
if (sSrc2[idx] == 0)
return (0);
else
return (255);
}
return (0);
}


unsigned char* FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, unsigned char* String, MX_UINT16 MSZ_String)
{
MX_SINT32 whole;
MX_UINT8 idx;
MX_UINT8 stringidx = 0;
MX_FLOAT temp = 0.5;
MX_FLOAT real;
MX_UINT8 temp_string[12];


for (idx = 0; idx < Precision; idx++) temp *= 0.1;

if (Number < 0)
{
Number = -Number;
String[stringidx++] = '-';
}
Number += temp;

temp = floor(Number);
whole = (MX_SINT32)temp;

real = Number - temp;

FCI_TOSTRING(whole, temp_string, sizeof(temp_string));

for (idx=0; temp_string[idx]; idx++)
{
if(stringidx < MSZ_String)
{
String[stringidx] = temp_string[idx];
stringidx = stringidx + 1;
}
}

if (Precision > 0)
{
if(stringidx < MSZ_String)
{
String[stringidx] = '.';
stringidx = stringidx + 1;
}

for (idx = 0; idx < Precision; idx++)
{
if (stringidx >= MSZ_String)
break;

real = real * 10;
whole = (MX_SINT32)real;
temp = (MX_FLOAT)whole;
real = real - temp;

String[stringidx] = '0' + whole;
stringidx = stringidx + 1;
}
}

if(stringidx < MSZ_String)
{
String[stringidx] = 0;
}

return String;
}




unsigned char* FCI_NUMBER_TO_HEX(MX_UINT32 Number, unsigned char* String, MX_UINT16 MSZ_String)
{
MX_UINT8 stringidx;
MX_UINT8 idx = 0;
MX_UINT8 temp;
MX_UINT8 digit[8];



MX_UINT32 num = Number;

# 625
String[0] = 0;


if(((Number >> 8) > 0xFF) && (MSZ_String < 10))
return String;

if((Number > 0xFF) && (MSZ_String < 6))
return String;

if((Number <= 0xFF) && (MSZ_String < 4))
return String;


String[0] = '0';
String[1] = 'x';


do
{
temp = num % 16;
num = num >> 4;

if(temp > 9)
{
temp = temp - 10;
digit[idx] = temp + 'A';
}
else
digit[idx] = temp + '0';

idx = idx + 1;
} while (num > 0);


if(idx == 1)
{
digit[1] = '0';
idx = 2;
}


for (stringidx = 2; stringidx < (idx + 2); stringidx++)
String[stringidx] = digit[idx - (stringidx - 1)];


if(stringidx < MSZ_String)
{
String[stringidx] = 0;
}

return String;
}




MX_SINT32 FCI_STRING_TO_INT(unsigned char* String, MX_UINT16 MSZ_String)
{
MX_UINT8 bNegative = 0;
MX_UINT8 idx = 0;
MX_SINT32 RetVal = 0;


while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
{

if(String[idx] == '-')
{
bNegative = 1;
idx = idx + 1;
break;
}
idx = idx + 1;
}


while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
{

RetVal = (long) RetVal * 10;
RetVal = (long) RetVal + (String[idx] - '0');
idx = idx + 1;
}

if (bNegative)
RetVal = (long) 0 - RetVal;

return RetVal;
}




MX_FLOAT FCI_STRING_TO_FLOAT(unsigned char* String, MX_UINT16 MSZ_String)
{
MX_FLOAT RetVal = 0;
MX_FLOAT real_divider = 1;
MX_UINT32 whole, real;
MX_UINT8 idx = 0;
MX_UINT8 idx2 = 0;
MX_UINT8 offset = 0;
MX_UINT8 bNegative = 0;
MX_UINT8 Comp_String[8];


if(String[0] == '-')
{
bNegative = 1;
offset = 1;
}


for(idx=offset; idx<MSZ_String; idx++)
{
if(String[idx] == '.')
break;
}


whole = FCI_STRING_TO_INT (String, idx);


if(idx == MSZ_String)
{
RetVal = (MX_FLOAT)whole;
return RetVal;
}


offset = idx + 1;
for(idx=offset; idx<MSZ_String; idx++)
{
if(String[idx] >= '0' && String[idx] <= '9')
{
Comp_String[idx - offset] = String[idx];
real_divider = real_divider * 0.1;
}
else
break;
}


real = FCI_STRING_TO_INT (Comp_String, (idx - offset));


RetVal = (MX_FLOAT)real;
RetVal = RetVal * real_divider;
real_divider = (MX_FLOAT)whole;
RetVal = RetVal + real_divider;

if (bNegative)
RetVal = -RetVal;

return RetVal;
}

# 788
MX_UINT8 FCI_STRREV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT16 ix, len;
for (len = 0; len < iSrc_len; len++) if (sSrc[len] == 0) break;
if (len > iDst_len)
{
len = iDst_len;
}
ix = len;
while (ix > 0)
{
ix--;
sDst[ix] = sSrc[ix];
}


return len;
}

# 812
MX_UINT8 FCI_STRMOV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT16 ix;
ix = 0;
while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
{
sDst[ix] = sSrc[ix];
ix++;
}


return ix;
}

# 835
void FCI_SHEAD(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, unsigned char* sDst, MX_UINT16 iDst_len)
{

MX_UINT16 len, strt;

if ((MX_UINT16) sSrc2 == (MX_UINT16) sDst)
{
for (strt = 0; strt < iSrc1_len; strt++) if (sSrc1[strt] == 0) break;
if (strt < iDst_len)
{


for (len = 0; len < iSrc2_len; len++) if (sSrc2[len] == 0) break;
if (len > (iDst_len - strt))
{
len = (iDst_len - strt);
}
iSrc2_len = strt + len;
strt = len;
while (strt > 0)
{
strt--;
iSrc2_len--;
sDst[iSrc2_len] = sSrc2[strt];
}

for (strt = 0; strt < (iSrc1_len) && strt < (iDst_len) && sSrc1[strt] != '\0'; strt++) sDst[strt] = sSrc1[strt];
len += strt;
}
else
{

for (len = 0; len < (iSrc1_len) && len < (iDst_len) && sSrc1[len] != '\0'; len++) sDst[len] = sSrc1[len];
}
}
else
{

for (len = 0; len < (iSrc1_len) && len < (iDst_len) && sSrc1[len] != '\0'; len++) sDst[len] = sSrc1[len];

if (len < iDst_len)
{
unsigned char* temp_sSrc1 = sDst + len;
iSrc1_len = iDst_len - len;
for (strt = 0; strt < (iSrc2_len) && strt < (iSrc1_len) && sSrc2[strt] != '\0'; strt++) temp_sSrc1[strt] = sSrc2[strt];
len += strt;
}
}

if (len < iDst_len)
{
sDst[len] = '\0';
}
}

# 896
void FCI_SCOPY(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT16 len;


for (len = 0; len < (iSrc_len) && len < (iDst_len) && sSrc[len] != '\0'; len++) sDst[len] = sSrc[len];

if (len < iDst_len)
{
sDst[len] = '\0';
}
}

# 44 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_Float.c"
char isinf(float f);

# 76
MX_SINT32 MX_Map(MX_SINT32 x, MX_SINT32 in_min, MX_SINT32 in_max, MX_SINT32 out_min, MX_SINT32 out_max);
MX_FLOAT MX_Map_Float(MX_FLOAT x, MX_FLOAT in_min, MX_FLOAT in_max, MX_FLOAT out_min, MX_FLOAT out_max);

MX_SINT32 MX_Map(MX_SINT32 x, MX_SINT32 in_min, MX_SINT32 in_max, MX_SINT32 out_min, MX_SINT32 out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

MX_FLOAT MX_Map_Float(MX_FLOAT x, MX_FLOAT in_min, MX_FLOAT in_max, MX_FLOAT out_min, MX_FLOAT out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}



char isinf(float f)
{
char* b;
b = (char*)&f;
if ((b[0] == 0) &&
(b[1] == 0) &&
(b[2] == 128) &&
((b[3] & 127) == 127))
{
return (255);
}
return (0);
}

# 120
inline signed long flt_cos_i(unsigned long Rads12)
{
unsigned long x, x2, x4, x6, x8, err;
signed int sgn;

x = Rads12;
if (x > 6433 && x <= 19301)
{
sgn = -1;
}
else
{
sgn = 1;
}
if (x > 12867)
{
x -= 12867;
}
if (x > 6433)
{
x = 12867 - x;
}

x2 = (x * x + 2047) >> 12;
x4 = (x2 * x2) >> 12;
x6 = (x4 * x2) >> 12;
x8 = (x4 * x4) >> 12;

x2 *= 360;
x4 *= 30;
x8 /= 90;
err = 250;
return ((signed long)((2949120L - x2 + x4 - x6 + x8 - err) * sgn) * 7) >> 1;
}

# 168
inline signed long flt_sin_i(unsigned long Rads12)
{
unsigned long x, x2, x3, x5, x7, x9, err;
signed int sgn;

x = Rads12;
if (x > 12867)
{
sgn = -1;
x -= 12867;
}
else
{
sgn = 1;
}
if (x > 6433)
{
x = 12867 - x;
}
x2 = (x * x + 2047) >> 12;
x3 = (x2 * x) >> 12;
x5 = (x3 * x2) >> 12;
x7 = (x5 * x2) >> 12;
x9 = (x7 * x2) >> 12;

x *= 2520;
x3 *= 420;
x5 *= 21;
x9 /= 36;
err = 2048;
return (signed long)(x - x3 + x5 - x7 + x9 + err) * sgn;
}

# 54 "Flowcode1 (RAF).c"
volatile MX_CHAR FCV_MDP[4] = "0000";
volatile MX_CHAR FCV_CODE[4];
volatile MX_UINT8 FCV_KEY;
volatile MX_BOOL FCV_VALIDATION = (0);
volatile MX_UINT8 FCV_NBCHIFFRE = (0x0);
volatile MX_BOOL FCV_HAS_SET_PASSWORD;

void FCM_modification_mdp();
MX_UINT8 FCM_custom_keypad_get_number();
void FCM_identification();

# 81
MX_UINT16 FC_CAL_EE_Read(MX_UINT16 FCL_ADDRESS);
void FC_CAL_EE_Write(MX_UINT16 FCL_ADDRESS, MX_UINT16 FCL_DATA);

# 98
asm("\tpsect eeprom_data,class=EEDATA,delta=2,space=3,noexec"); asm("\tdb\t" "0" "," "1" "," "0x2" "," "0x03" "," "'A'" "," "'b'" "," "'H'" "," "'e'");
asm("\tpsect eeprom_data,class=EEDATA,delta=2,space=3,noexec"); asm("\tdb\t" "'l'" "," "'l'" "," "'o'" "," "0xFF" "," "0xFF" "," "0xFF" "," "0xFF" "," "0xFF");

# 111
MX_UINT16 FCD_06651_eeprom1__Read(MX_UINT16 FCL_ADDRESS);
void FCD_06651_eeprom1__Write(MX_UINT16 FCL_ADDRESS, MX_UINT16 FCL_VALUE);

# 125
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER);
void FCD_04071_LCD__Start();

# 174
const MX_UINT8 FCD_00fb1_lut__INTLIST_LUT [] =
{

1, 2, 3, 10, 4, 5, 6, 11, 7, 8, 9, 12, 14, 0, 15, 13


};

MX_UINT16 FCD_00fb1_lut__GetLUTCount();

# 189
MX_UINT8 FCD_08c31_keypad_base__WaitPressed();
MX_UINT8 FCD_08c31_keypad_base__GetAscii();
void FCD_08c31_keypad_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08c31_keypad_base__Prv_GetRow();
MX_UINT8 FCD_08c31_keypad_base__GetNumber();
MX_UINT8 FCD_08c31_keypad_base__GetIndex();
void FCD_08c31_keypad_base__Prv_FloatColumns();
void FCD_08c31_keypad_base__WaitReleased();

# 203
MX_UINT8 FCD_0a211_keypad_4x4__WaitPressed();
MX_UINT8 FCD_0a211_keypad_4x4__GetAscii();
void FCD_0a211_keypad_4x4__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_0a211_keypad_4x4__GetNumber();
MX_UINT8 FCD_0a211_keypad_4x4__GetIndex();
void FCD_0a211_keypad_4x4__WaitReleased();

# 164 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_EEPROM.c"
MX_UINT16 FC_CAL_EE_Read (MX_UINT16 Address)
{
MX_UINT16 data = 0;



EEADR = Address & 0xff;

# 175
EECON1bits.EEPGD = 0;

# 181
EECON1bits.RD = 1;
data = EEDATA;

# 187
return (data);
}

void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT16 Data)
{


char bInterruptsEnabled;

while ((EECON1bits.WR));
EEADR = Address & 0xff;

# 201
EEDATA = Data;

EECON1bits.EEPGD = 0;

# 209
EECON1bits.WREN = 1;
bInterruptsEnabled = (INTCONbits.GIE);
INTCONbits.GIE = 0;


EECON2 = 0x55;
EECON2 = 0xAA;


EECON1bits.WR = 1;
while ((EECON1bits.WR));
if (bInterruptsEnabled)
INTCONbits.GIE = 1;
EECON1bits.WREN = 0;

# 227
}

# 234 "Flowcode1 (RAF).c"
MX_UINT16 FCD_06651_eeprom1__Read(MX_UINT16 FCL_ADDRESS)
{

MX_UINT16 FCR_RETVAL;


FCR_RETVAL = FC_CAL_EE_Read(FCL_ADDRESS);

return (FCR_RETVAL);

}

# 254
void FCD_06651_eeprom1__Write(MX_UINT16 FCL_ADDRESS, MX_UINT16 FCL_VALUE)
{

FC_CAL_EE_Write(FCL_ADDRESS, FCL_VALUE);

}

# 274
void FCD_04071_LCD__Clear()
{




FCD_04071_LCD__RawSend(0x01, 0);

delay_ms((2));

FCD_04071_LCD__RawSend(0x02, 0);

delay_ms((2));

}

# 296
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{

MX_UINT8 FCL_IDX = (0x0);
MX_UINT8 FCL_COUNT;



FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

while (FCL_IDX < FCL_COUNT)
{

# 315
FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);




FCL_IDX = FCL_IDX + 1;


}


}

# 334
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

# 349
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{


MX_CHAR FCL_S[10];



FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

FCD_04071_LCD__PrintString(FCL_S, 10);



}

# 379
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

delay_ms((2));

FCD_04071_LCD__RawSend(FCL_D0, 0x10);

FCD_04071_LCD__RawSend(FCL_D1, 0x10);

FCD_04071_LCD__RawSend(FCL_D2, 0x10);

FCD_04071_LCD__RawSend(FCL_D3, 0x10);

FCD_04071_LCD__RawSend(FCL_D4, 0x10);

FCD_04071_LCD__RawSend(FCL_D5, 0x10);

FCD_04071_LCD__RawSend(FCL_D6, 0x10);

FCD_04071_LCD__RawSend(FCL_D7, 0x10);

FCD_04071_LCD__Clear();

}

# 412
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{

MX_UINT8 FCL_X;


if (FCL_LINE < 2)
{

FCD_04071_LCD__Cursor(0, FCL_LINE);


FCL_X = 0;

while (FCL_X < 16)
{


FCD_04071_LCD__RawSend(' ', 0x10);


FCL_X = FCL_X + 1;


}

FCD_04071_LCD__Cursor(0, FCL_LINE);



}

}

# 453
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

# 467
if (FCL_Y == 0)
{


FCL_Y = 0x80;

} else {


FCL_Y = 0xC0;

}

# 492
FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

delay_ms((2));




FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

delay_ms((2));

}

# 511
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

delay_ms((2));

}

# 529
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{


MX_CHAR FCL_S[15];


if (FCL_FORMAT == 1)
{


FCI_TOSTRU32(FCL_NUMBER, FCL_S, 15);

} else {


FCI_TOSTRS32((MX_SINT32)(FCL_NUMBER), FCL_S, 15);

}

FCD_04071_LCD__PrintString(FCL_S, 15);



}

# 562
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{

MX_UINT8 FCL_CMD = (0x0);



FCL_CMD = 0;

if (FCL_DIRECTION == 0)
{


FCL_CMD = 0x18;


} else {


FCL_CMD = 0x1C;


}

if (FCL_CMD != 0 && FCL_POSITION != 0)
{

while (FCL_POSITION != 0)
{

FCD_04071_LCD__RawSend(FCL_CMD, 0);


FCL_POSITION = FCL_POSITION - 1;


}



}

}

# 613
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{

MX_UINT8 FCL_NIBBLE;

# 630
{TRISB &= ~(1<<0); (0) ? (PORTB = PORTB | (1<<0)) : (PORTB = PORTB & ~(1<<0));};
{TRISB &= ~(1<<1); (0) ? (PORTB = PORTB | (1<<1)) : (PORTB = PORTB & ~(1<<1));};
{TRISB &= ~(1<<2); (0) ? (PORTB = PORTB | (1<<2)) : (PORTB = PORTB & ~(1<<2));};
{TRISB &= ~(1<<3); (0) ? (PORTB = PORTB | (1<<3)) : (PORTB = PORTB & ~(1<<3));};
{TRISB &= ~(1<<4); (0) ? (PORTB = PORTB | (1<<4)) : (PORTB = PORTB & ~(1<<4));};
{TRISB &= ~(1<<5); (0) ? (PORTB = PORTB | (1<<5)) : (PORTB = PORTB & ~(1<<5));};

# 652
FCL_NIBBLE = (FCL_DATA >> 4);
{TRISB &= ~(1<<0); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<0)) : (PORTB = PORTB & ~(1<<0));};
FCL_NIBBLE = FCL_NIBBLE >> 1;
{TRISB &= ~(1<<1); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<1)) : (PORTB = PORTB & ~(1<<1));};
FCL_NIBBLE = FCL_NIBBLE >> 1;
{TRISB &= ~(1<<2); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<2)) : (PORTB = PORTB & ~(1<<2));};
FCL_NIBBLE = FCL_NIBBLE >> 1;
{TRISB &= ~(1<<3); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<3)) : (PORTB = PORTB & ~(1<<3));};

# 686
if (FCL_TYPE)
{


{TRISB &= ~(1<<4); (1) ? (PORTB = PORTB | (1<<4)) : (PORTB = PORTB & ~(1<<4));};



}

# 703
delay_us((100));

# 711
{TRISB &= ~(1<<5); (1) ? (PORTB = PORTB | (1<<5)) : (PORTB = PORTB & ~(1<<5));};

delay_us((100));


{TRISB &= ~(1<<5); (0) ? (PORTB = PORTB | (1<<5)) : (PORTB = PORTB & ~(1<<5));};

delay_us((100));

# 727
{TRISB &= ~(1<<0); (0) ? (PORTB = PORTB | (1<<0)) : (PORTB = PORTB & ~(1<<0));};
{TRISB &= ~(1<<1); (0) ? (PORTB = PORTB | (1<<1)) : (PORTB = PORTB & ~(1<<1));};
{TRISB &= ~(1<<2); (0) ? (PORTB = PORTB | (1<<2)) : (PORTB = PORTB & ~(1<<2));};
{TRISB &= ~(1<<3); (0) ? (PORTB = PORTB | (1<<3)) : (PORTB = PORTB & ~(1<<3));};
{TRISB &= ~(1<<4); (0) ? (PORTB = PORTB | (1<<4)) : (PORTB = PORTB & ~(1<<4));};

# 741
FCL_NIBBLE = (FCL_DATA & 0xf);
{TRISB &= ~(1<<0); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<0)) : (PORTB = PORTB & ~(1<<0));};
FCL_NIBBLE = FCL_NIBBLE >> 1;
{TRISB &= ~(1<<1); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<1)) : (PORTB = PORTB & ~(1<<1));};
FCL_NIBBLE = FCL_NIBBLE >> 1;
{TRISB &= ~(1<<2); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<2)) : (PORTB = PORTB & ~(1<<2));};
FCL_NIBBLE = FCL_NIBBLE >> 1;
{TRISB &= ~(1<<3); ((FCL_NIBBLE & 0x01)) ? (PORTB = PORTB | (1<<3)) : (PORTB = PORTB & ~(1<<3));};

if (FCL_TYPE)
{


{TRISB &= ~(1<<4); (1) ? (PORTB = PORTB | (1<<4)) : (PORTB = PORTB & ~(1<<4));};



}

delay_us((100));


{TRISB &= ~(1<<5); (1) ? (PORTB = PORTB | (1<<5)) : (PORTB = PORTB & ~(1<<5));};

delay_us((100));


{TRISB &= ~(1<<5); (0) ? (PORTB = PORTB | (1<<5)) : (PORTB = PORTB & ~(1<<5));};

delay_us((100));

# 777
}

# 788
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

# 798
}

# 804
void FCD_04071_LCD__Start()
{

# 818
{TRISB &= ~(1<<0); (0) ? (PORTB = PORTB | (1<<0)) : (PORTB = PORTB & ~(1<<0));};
{TRISB &= ~(1<<1); (0) ? (PORTB = PORTB | (1<<1)) : (PORTB = PORTB & ~(1<<1));};
{TRISB &= ~(1<<2); (0) ? (PORTB = PORTB | (1<<2)) : (PORTB = PORTB & ~(1<<2));};
{TRISB &= ~(1<<3); (0) ? (PORTB = PORTB | (1<<3)) : (PORTB = PORTB & ~(1<<3));};
{TRISB &= ~(1<<4); (0) ? (PORTB = PORTB | (1<<4)) : (PORTB = PORTB & ~(1<<4));};
{TRISB &= ~(1<<5); (0) ? (PORTB = PORTB | (1<<5)) : (PORTB = PORTB & ~(1<<5));};

# 851
delay_ms((12));

FCD_04071_LCD__RawSend(0x33, 0);

delay_ms((2));

FCD_04071_LCD__RawSend(0x33, 0);

delay_ms((2));

# 866
FCD_04071_LCD__RawSend(0x32, 0);

delay_ms((2));

FCD_04071_LCD__RawSend(0x2c, 0);



delay_ms((2));

FCD_04071_LCD__RawSend(0x06, 0);

delay_ms((2));

FCD_04071_LCD__RawSend(0x0c, 0);

delay_ms((2));

FCD_04071_LCD__RawSend(0x01, 0);

delay_ms((2));

FCD_04071_LCD__RawSend(0x02, 0);

delay_ms((2));

FCD_04071_LCD__Clear();

# 901
}

# 923
MX_UINT16 FCD_00fb1_lut__GetLUTCount()
{

MX_UINT16 FCR_RETVAL;



FCR_RETVAL = 16;

return (FCR_RETVAL);

}

# 946
MX_UINT8 FCD_08c31_keypad_base__WaitPressed()
{

MX_UINT8 FCL_INDEX;
MX_UINT8 FCR_RETVAL;


while (1)
{

FCL_INDEX = FCD_08c31_keypad_base__GetIndex();


if ((FCL_INDEX == 255) == 0) break;
}


FCR_RETVAL = FCL_INDEX;

return (FCR_RETVAL);

}

# 974
MX_UINT8 FCD_08c31_keypad_base__GetAscii()
{

MX_UINT8 FCL_INDEX;
MX_UINT8 FCR_RETVAL;


FCL_INDEX = FCD_08c31_keypad_base__GetIndex();

if (FCL_INDEX < 255)
{


FCR_RETVAL = FCI_GETCHAR("123A456B789C*0#D", 17, FCL_INDEX);

} else {


FCR_RETVAL = FCL_INDEX;

}

return (FCR_RETVAL);

}

# 1005
void FCD_08c31_keypad_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{

MX_UINT8 FCL_INDEX;


FCL_INDEX = FCD_08c31_keypad_base__GetIndex();

if (FCL_INDEX < 255)
{


FCI_MIDSTRING("123A456B789C*0#D", 17, FCL_INDEX, 1, FCR_RETVAL,20);

} else {


FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

}

}

# 1031
MX_UINT8 FCD_08c31_keypad_base__Prv_GetRow()
{

MX_UINT8 FCL_INDEX = (0x0);
MX_BOOL FCL_PIN_STATE = (0);
MX_UINT8 FCR_RETVAL;




FCL_INDEX = 0;
FCR_RETVAL = 255;

while (FCL_INDEX < 4)
{

switch (FCL_INDEX)
{
case 0:
{

FCL_PIN_STATE = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<4)), (4)));

break;
}
case 1:
{

FCL_PIN_STATE = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<5)), (5)));

break;
}
case 2:
{

FCL_PIN_STATE = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<6)), (6)));

break;
}
case 3:
{

FCL_PIN_STATE = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<7)), (7)));

break;
}
default:
{
}
}

if (FCL_PIN_STATE > 0)
{


FCR_RETVAL = FCL_INDEX;

goto FCC_Prv_GetRow_A;



}


FCL_INDEX = FCL_INDEX + 1;


}

FCC_Prv_GetRow_A:
;

return (FCR_RETVAL);

}

# 1112
MX_UINT8 FCD_08c31_keypad_base__GetNumber()
{

MX_UINT8 FCR_RETVAL;


FCR_RETVAL = FCD_08c31_keypad_base__GetIndex();

if (FCR_RETVAL < 255)
{

FCR_RETVAL = FCD_00fb1_lut__INTLIST_LUT[FCR_RETVAL];



}

return (FCR_RETVAL);

}

# 1138
MX_UINT8 FCD_08c31_keypad_base__GetIndex()
{

MX_UINT8 FCL_INDEX = (0x0);
MX_UINT8 FCL_ROW_STATE;
MX_UINT8 FCR_RETVAL;


FCD_08c31_keypad_base__Prv_FloatColumns();



FCL_INDEX = 0;
FCR_RETVAL = 255;

while (FCL_INDEX < 4)
{

switch (FCL_INDEX)
{
case 0:
{



{TRISC &= ~(1<<0); (1) ? (PORTC = PORTC | (1<<0)) : (PORTC = PORTC & ~(1<<0));};

# 1170
break;
}
case 1:
{



{TRISC &= ~(1<<1); (1) ? (PORTC = PORTC | (1<<1)) : (PORTC = PORTC & ~(1<<1));};

# 1184
break;
}
case 2:
{



{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1198
break;
}
case 3:
{



{TRISC &= ~(1<<3); (1) ? (PORTC = PORTC | (1<<3)) : (PORTC = PORTC & ~(1<<3));};

# 1212
break;
}
default:
{
}
}

delay_us((20));

FCL_ROW_STATE = FCD_08c31_keypad_base__Prv_GetRow();

switch (FCL_INDEX)
{
case 0:
{



{TRISC &= ~(1<<0); (0) ? (PORTC = PORTC | (1<<0)) : (PORTC = PORTC & ~(1<<0));};

# 1237
break;
}
case 1:
{



{TRISC &= ~(1<<1); (0) ? (PORTC = PORTC | (1<<1)) : (PORTC = PORTC & ~(1<<1));};

# 1251
break;
}
case 2:
{



{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1265
break;
}
case 3:
{



{TRISC &= ~(1<<3); (0) ? (PORTC = PORTC | (1<<3)) : (PORTC = PORTC & ~(1<<3));};

# 1279
break;
}
default:
{
}
}

if (FCL_ROW_STATE < 255)
{


FCR_RETVAL = (FCL_ROW_STATE * 4) + FCL_INDEX;

goto FCC_GetIndex_A;



}

delay_us((50));


FCL_INDEX = FCL_INDEX + 1;


}

FCC_GetIndex_A:
;

return (FCR_RETVAL);

}

# 1316
void FCD_08c31_keypad_base__Prv_FloatColumns()
{

MX_UINT8 FCL_INDEX;
MX_UINT8 FCL_DUMMY;



FCL_INDEX = 0;

while (FCL_INDEX < 4)
{

switch (FCL_INDEX)
{
case 0:
{



FCL_DUMMY = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<4)), (4)));

# 1343
break;
}
case 1:
{



FCL_DUMMY = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<5)), (5)));

# 1357
break;
}
case 2:
{



FCL_DUMMY = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<6)), (6)));

# 1371
break;
}
case 3:
{



FCL_DUMMY = (FC_CAL_Port_In_DDR__x((&PORTC), (&TRISC), ((1<<7)), (7)));

# 1385
break;
}
default:
{
}
}


FCL_INDEX = FCL_INDEX + 1;


}


FCL_INDEX = 0;

while (FCL_INDEX < 4)
{

switch (FCL_INDEX)
{
case 0:
{



{TRISC &= ~(1<<0); (0) ? (PORTC = PORTC | (1<<0)) : (PORTC = PORTC & ~(1<<0));};

# 1418
break;
}
case 1:
{



{TRISC &= ~(1<<1); (0) ? (PORTC = PORTC | (1<<1)) : (PORTC = PORTC & ~(1<<1));};

# 1432
break;
}
case 2:
{



{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1446
break;
}
case 3:
{



{TRISC &= ~(1<<3); (0) ? (PORTC = PORTC | (1<<3)) : (PORTC = PORTC & ~(1<<3));};

# 1460
break;
}
default:
{
}
}


FCL_INDEX = FCL_INDEX + 1;


}

}

# 1478
void FCD_08c31_keypad_base__WaitReleased()
{

MX_UINT8 FCL_INDEX;


while (1)
{

FCL_INDEX = FCD_08c31_keypad_base__GetIndex();


if ((FCL_INDEX < 255) == 0) break;
}

}

# 1505
MX_UINT8 FCD_0a211_keypad_4x4__WaitPressed()
{

MX_UINT8 FCR_RETVAL;



FCR_RETVAL = FCD_08c31_keypad_base__WaitPressed();

return (FCR_RETVAL);

}

# 1523
MX_UINT8 FCD_0a211_keypad_4x4__GetAscii()
{

MX_UINT8 FCR_RETVAL;



FCR_RETVAL = FCD_08c31_keypad_base__GetAscii();

return (FCR_RETVAL);

}

# 1541
void FCD_0a211_keypad_4x4__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{



FCD_08c31_keypad_base__GetString(FCR_RETVAL,20 );

}

# 1555
MX_UINT8 FCD_0a211_keypad_4x4__GetNumber()
{

MX_UINT8 FCR_RETVAL;



FCR_RETVAL = FCD_08c31_keypad_base__GetNumber();

return (FCR_RETVAL);

}

# 1573
MX_UINT8 FCD_0a211_keypad_4x4__GetIndex()
{

MX_UINT8 FCR_RETVAL;



FCR_RETVAL = FCD_08c31_keypad_base__GetIndex();

return (FCR_RETVAL);

}

# 1589
void FCD_0a211_keypad_4x4__WaitReleased()
{


FCD_08c31_keypad_base__WaitReleased();

}

# 1605
void FCM_modification_mdp()
{



FCV_NBCHIFFRE = 0;


FCD_04071_LCD__Clear();


FCD_04071_LCD__PrintString("Entrer nouveau", 15);


FCD_04071_LCD__Cursor(0, 1);


FCD_04071_LCD__PrintString("mot de passe", 13);


FCD_0a211_keypad_4x4__WaitPressed();


FCD_04071_LCD__Clear();


while (FCV_VALIDATION == (0))
{


while (!(FCV_NBCHIFFRE >= 4))
{


FCD_0a211_keypad_4x4__WaitPressed();


FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();


if (FCV_KEY < 10)
{



FCV_MDP[FCV_NBCHIFFRE] = FCV_KEY;


FCD_04071_LCD__Cursor(FCV_NBCHIFFRE, 1);


FCD_04071_LCD__PrintNumber(FCV_KEY);



FCV_NBCHIFFRE = FCV_NBCHIFFRE + 1;

} else {


if (FCV_KEY == 14 && FCV_NBCHIFFRE > 0)
{



FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;



FCV_MDP[FCV_NBCHIFFRE] = 0;


FCD_04071_LCD__Cursor(FCV_NBCHIFFRE, 1);


FCD_04071_LCD__PrintString(" ", 2);



}

}


FCD_0a211_keypad_4x4__WaitReleased();


}


FCD_0a211_keypad_4x4__WaitPressed();


FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();


if (FCV_KEY == 15)
{



FCV_VALIDATION = (1);

} else {


if (FCV_KEY == 14)
{



FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;



FCV_CODE[FCV_NBCHIFFRE] = 0;


FCD_04071_LCD__Cursor(FCV_NBCHIFFRE, 1);


FCD_04071_LCD__PrintString(" ", 2);


FCD_0a211_keypad_4x4__WaitReleased();



}

}


}


FCD_06651_eeprom1__Write(1, FCV_MDP[0]);


FCD_06651_eeprom1__Write(2, FCV_MDP[1]);


FCD_06651_eeprom1__Write(3, FCV_MDP[2]);


FCD_06651_eeprom1__Write(4, FCV_MDP[3]);



FCV_VALIDATION = (0);

}

# 1761
MX_UINT8 FCM_custom_keypad_get_number()
{

MX_UINT8 FCR_RETVAL;



while (1)
{


}

return (FCR_RETVAL);

}

# 1781
void FCM_identification()
{

# 1789
FCV_CODE[0] = 20;
FCV_CODE[1] = 20;
FCV_CODE[2] = 20;
FCV_CODE[3] = 20;


FCV_MDP[0] = FCD_06651_eeprom1__Read(1);


FCV_MDP[1] = FCD_06651_eeprom1__Read(2);


FCV_MDP[2] = FCD_06651_eeprom1__Read(3);


FCV_MDP[3] = FCD_06651_eeprom1__Read(4);


while (FCV_CODE[0] != FCV_MDP[0] || FCV_CODE[1] != FCV_MDP[1] || FCV_CODE[2] != FCV_MDP[2] || FCV_CODE[3] != FCV_MDP[3])
{


FCD_04071_LCD__Clear();


FCD_04071_LCD__Cursor(0, 0);


FCD_04071_LCD__PrintString("Identifiez vous", 16);



FCV_NBCHIFFRE = 0;


while (FCV_VALIDATION == (0))
{


while (!(FCV_NBCHIFFRE >= 4))
{


FCD_0a211_keypad_4x4__WaitPressed();


FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();


if (FCV_KEY < 10)
{

# 1846
FCV_CODE[FCV_NBCHIFFRE] = FCV_KEY;


FCD_04071_LCD__Cursor(FCV_NBCHIFFRE, 1);


FCD_04071_LCD__PrintString("*", 2);



FCV_NBCHIFFRE = FCV_NBCHIFFRE + 1;

} else {

# 1864
if (FCV_KEY == 14 && FCV_NBCHIFFRE > 0)
{



FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;



FCV_CODE[FCV_NBCHIFFRE] = 0;


FCD_04071_LCD__Cursor(FCV_NBCHIFFRE, 1);


FCD_04071_LCD__PrintString(" ", 2);



}

}


FCD_0a211_keypad_4x4__WaitReleased();


}


FCD_0a211_keypad_4x4__WaitPressed();


FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();

# 1903
if (FCV_KEY == 14)
{



FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;



FCV_CODE[FCV_NBCHIFFRE] = 0;


FCD_04071_LCD__Cursor(FCV_NBCHIFFRE, 1);


FCD_04071_LCD__PrintString(" ", 2);


FCD_0a211_keypad_4x4__WaitReleased();



}


if (FCV_KEY == 15)
{



FCV_VALIDATION = (1);



}


}


if (FCV_CODE[0] != FCV_MDP[0] || FCV_CODE[1] != FCV_MDP[1] || FCV_CODE[2] != FCV_MDP[2] || FCV_CODE[3] != FCV_MDP[3])
{


FCD_04071_LCD__Clear();


FCD_04071_LCD__PrintString("code faux", 10);


delay_s((2));



}



FCV_VALIDATION = (0);


}


FCD_04071_LCD__Clear();


FCD_04071_LCD__PrintString("Bienvenue", 10);


delay_s((1));

}

# 1982
void main()
{
ADCON1 = 0x07;

OPTION_REG = 0xC0;



FCD_04071_LCD__Start();

# 1996
FCV_HAS_SET_PASSWORD = FCD_06651_eeprom1__Read(0);


if (FCV_HAS_SET_PASSWORD == (0))
{


FCM_modification_mdp();



FCV_HAS_SET_PASSWORD = (1);


FCD_06651_eeprom1__Write(0, FCV_HAS_SET_PASSWORD);



}

# 2020
FCM_identification();

mainendloop: goto mainendloop;
}

# 2030
void interrupt myisr(void)
{

}

