//************************************************************************************
//**  
//**  Source name:   C:\Users\USERX\OneDrive - Conseil régional Grand Est - Numérique Educatif\Lycée\Terminale\2I2D\Projet\Test keypad\Version Raf\Flowcode1 (RAF).fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.16F.16F873
//**  
//**  Generated by:  Flowcode v8.2.2.15
//**  Date:          Wednesday, April 12, 2023 10:56:09
//**  Users:         1
//**  Registered to:  LYC-LORITZ54-V8
//**  License key: UJJ0K6
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  https://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_CAL_PIC

#define MX_CLK_SPEED 1000000

#define FCP_NULL Unconnected_Port


#include <xc.h>
#include <math.h>
//Chip Configuration Settings
__PROG_CONFIG(0x1, 0x3FF9);

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\internals.c"





/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_MDP 4
#define FCVsz_CODE 4
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_CHAR FCV_MDP[FCVsz_MDP] = "0000";
MX_GLOBAL MX_CHAR FCV_CODE[FCVsz_CODE];
MX_GLOBAL MX_UINT8 FCV_KEY;
MX_GLOBAL MX_BOOL FCV_VALIDATION = (0);
MX_GLOBAL MX_UINT8 FCV_NBCHIFFRE = (0x0);
MX_GLOBAL MX_BOOL FCV_HAS_SET_PASSWORD;

void FCM_modification_mdp();
MX_UINT8 FCM_custom_keypad_get_number();
void FCM_identification();

/*========================================================================*\
   Use :cal_eeprom
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_EEPROM_REF 
#define MX_EE_SIZE 128
#define MX_EE_Flash_Address 0
#define MX_EE_TYPE2 


/*=----------------------------------------------------------------------=*\
   Use :cal_eeprom
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_EE
MX_UINT16 FC_CAL_EE_Read(MX_UINT16 FCL_ADDRESS);
void FC_CAL_EE_Write(MX_UINT16 FCL_ADDRESS, MX_UINT16 FCL_DATA);

/*========================================================================*\
   Use :eeprom1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*=----------------------------------------------------------------------=*\
   Use :eeprom1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/

//Initialise EEPROM MEMORY

#ifdef MX_CAL_PIC
__EEPROM_DATA(0,1,0x2,0x03,'A','b','H','e');
__EEPROM_DATA('l','l','o',0xFF,0xFF,0xFF,0xFF,0xFF);
#endif

#ifdef MX_CAL_AVR
char EEMEM NonVolatileData[] = {0,1,0x2,0x03,'A','b','H','e','l','l','o'};
#endif

#ifdef MX_CAL_PIC16
int _EEDATA(2) NonVolatileData[] = {0,1,0x2,0x03,'A','b','H','e','l','l','o'};
#endif


MX_UINT16 FCD_06651_eeprom1__Read(MX_UINT16 FCL_ADDRESS);
void FCD_06651_eeprom1__Write(MX_UINT16 FCL_ADDRESS, MX_UINT16 FCL_VALUE);

/*========================================================================*\
   Use :ctrl_lcd
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_16x2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f9e1_lcd_16x2__Clear FCD_04071_LCD__Clear
#define FCD_0f9e1_lcd_16x2__PrintString FCD_04071_LCD__PrintString
#define FCD_0f9e1_lcd_16x2__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0f9e1_lcd_16x2__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0f9e1_lcd_16x2__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0f9e1_lcd_16x2__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0f9e1_lcd_16x2__Cursor FCD_04071_LCD__Cursor
#define FCD_0f9e1_lcd_16x2__Command FCD_04071_LCD__Command
#define FCD_0f9e1_lcd_16x2__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0f9e1_lcd_16x2__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0f9e1_lcd_16x2__RawSend FCD_04071_LCD__RawSend
#define FCD_0f9e1_lcd_16x2__RemapCharacter FCD_04071_LCD__RemapCharacter
#define FCD_0f9e1_lcd_16x2__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :lut
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_lut__FLOATFIXEDLIST 1
#define FCVsz_00fb1_lut__INTLIST 16
#define FCVsz_00fb1_lut__FLOATLIST 1
#define FCVsz_00fb1_lut__INTFIXEDLIST 1
#define FCD_00fb1_lut__INTLIST(ix) FCD_00fb1_lut__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_lut__INTLIST_LUT ROMARRAY_E =
{
// Property added elements
  1, 2, 3, 10, 4, 5, 6, 11, 7, 8, 9, 12, 14, 0, 15, 13
// Dynamically added elements
 
};

MX_UINT16 FCD_00fb1_lut__GetLUTCount();

/*========================================================================*\
   Use :keypad_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_08c31_keypad_base__WaitPressed();
MX_UINT8 FCD_08c31_keypad_base__GetAscii();
void FCD_08c31_keypad_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08c31_keypad_base__Prv_GetRow();
MX_UINT8 FCD_08c31_keypad_base__GetNumber();
MX_UINT8 FCD_08c31_keypad_base__GetIndex();
void FCD_08c31_keypad_base__Prv_FloatColumns();
void FCD_08c31_keypad_base__WaitReleased();

/*========================================================================*\
   Use :keypad_4x4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_0a211_keypad_4x4__WaitPressed();
MX_UINT8 FCD_0a211_keypad_4x4__GetAscii();
void FCD_0a211_keypad_4x4__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_0a211_keypad_4x4__GetNumber();
MX_UINT8 FCD_0a211_keypad_4x4__GetIndex();
void FCD_0a211_keypad_4x4__WaitReleased();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\includes.c"


/*========================================================================*\
   Use :cal_eeprom
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :eeprom1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads a packet of bits from the EEPROM
       :The number of bits read is 8 or 16, depending on the platform
       :
       :Parameters for macro Read:
       :  Address : The address, in elements, to read the data from
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_06651_eeprom1__Read(MX_UINT16 FCL_ADDRESS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_EE_Read(FCL_ADDRESS);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Writes a packet of bits from the EEPROM
       :The number of bits written is 8 or 16, depending on the platform
       :
       :Parameters for macro Write:
       :  Address : The address, in elements, to write the data to
       :  Value : The 8 or 16 bit value to store in EEPROM
\*=----------------------------------------------------------------------=*/
void FCD_06651_eeprom1__Write(MX_UINT16 FCL_ADDRESS, MX_UINT16 FCL_VALUE)
{

	FC_CAL_EE_Write(FCL_ADDRESS, FCL_VALUE);

}


/*========================================================================*\
   Use :ctrl_lcd
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Local variable definitions
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;


	// .count = Length$ (.Text)
	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		#else


			FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		#endif

		// .Idx = .Idx + 1
		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Local variable definitions
#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	// .s = ToString$ (.Number)
	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Local variable definitions
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		// .x = 0
		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			// .x = .x + 1
			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			// .y = 0x80
			FCL_Y = 0x80;

		} else {

			// .y = 0xC0
			FCL_Y = 0xC0;

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 2 == 4

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

	//Comment:
	//EB2 LCDs have occasional problems here if cursor command isn't called twice

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Local variable definitions
#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		// .s = STRING UNSIGNED .Number
		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		// .s = STRING SIGNED .Number
		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  Position : Holds the number of positions to shift the display
       :  Direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Local variable definitions
	MX_UINT8 FCL_CMD = (0x0);


	// .cmd = 0
	FCL_CMD = 0;

	if (FCL_DIRECTION == 0)
	{

		// .cmd = 0x18
		FCL_CMD = 0x18;


	} else {

		// .cmd = 0x1C
		FCL_CMD = 0x1C;


	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			// .Position = .Position - 1
			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Local variable definitions
	MX_UINT8 FCL_NIBBLE;


	//Comment:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		// Pin_Data_0 = 0
		// Pin_Data_1 = 0
		// Pin_Data_2 = 0
		// Pin_Data_3 = 0
		// Pin_RS = 0
		// Pin_E = 0
		SET_PORT_PIN(B, 0, 0);
		SET_PORT_PIN(B, 1, 0);
		SET_PORT_PIN(B, 2, 0);
		SET_PORT_PIN(B, 3, 0);
		SET_PORT_PIN(B, 4, 0);
		SET_PORT_PIN(B, 5, 0);

		#if (0)

		//Code has been optimised out by the pre-processor
		// #else

		#endif

		// .nibble = (.data >> 4)
		// Pin_Data_0 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_1 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_2 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_3 = (.nibble & 0x01)
		FCL_NIBBLE = (FCL_DATA >> 4);
		SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	//Comment:
	//Output byte to pins

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	//Comment:
	//Output byte to port

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	if (FCL_TYPE)
	{

		// Pin_RS = 1
		SET_PORT_PIN(B, 4, 1);

	// } else {

	}

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCI_DELAYBYTE_US(100);

	//Comment:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	// Pin_E = 1
	SET_PORT_PIN(B, 5, 1);

	FCI_DELAYBYTE_US(100);

	// Pin_E = 0
	SET_PORT_PIN(B, 5, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		// Pin_Data_0 = 0
		// Pin_Data_1 = 0
		// Pin_Data_2 = 0
		// Pin_Data_3 = 0
		// Pin_RS = 0
		SET_PORT_PIN(B, 0, 0);
		SET_PORT_PIN(B, 1, 0);
		SET_PORT_PIN(B, 2, 0);
		SET_PORT_PIN(B, 3, 0);
		SET_PORT_PIN(B, 4, 0);

		// .nibble = (.data & 0xf)
		// Pin_Data_0 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_1 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_2 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_3 = (.nibble & 0x01)
		FCL_NIBBLE = (FCL_DATA & 0xf);
		SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			// Pin_RS = 1
			SET_PORT_PIN(B, 4, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		// Pin_E = 1
		SET_PORT_PIN(B, 5, 1);

		FCI_DELAYBYTE_US(100);

		// Pin_E = 0
		SET_PORT_PIN(B, 5, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{




	#if (1) // 0 == 0

		// Pin_Data_0 = 0
		// Pin_Data_1 = 0
		// Pin_Data_2 = 0
		// Pin_Data_3 = 0
		// Pin_RS = 0
		// Pin_E = 0
		SET_PORT_PIN(B, 0, 0);
		SET_PORT_PIN(B, 1, 0);
		SET_PORT_PIN(B, 2, 0);
		SET_PORT_PIN(B, 3, 0);
		SET_PORT_PIN(B, 4, 0);
		SET_PORT_PIN(B, 5, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}


/*========================================================================*\
   Use :lcd_16x2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :lut
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_lut__GetLUTCount()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	// .Return = NumVals
	FCR_RETVAL = 16;

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :keypad_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Blocking call that waits for one of the keys on the keypad to be pressed. The index of the key that was pressed  is passed back to the user.
       :
       :Returns : Index of the first key pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base__WaitPressed()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;
	MX_UINT8 FCR_RETVAL; // Index of the first key pressed.


	while (1)
	{

		FCL_INDEX = FCD_08c31_keypad_base__GetIndex();


		if ((FCL_INDEX == 255) == 0) break;
	}

	// .return = .index
	FCR_RETVAL = FCL_INDEX;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the ASCII value for the current keypress. If no key is pressed then the macro returns the value 255.
       :
       :Returns : ASCII code of the pressed switch (or 255 if none pressed)
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base__GetAscii()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;
	MX_UINT8 FCR_RETVAL; // ASCII code of the pressed switch (or 255 if none pressed)


	FCL_INDEX = FCD_08c31_keypad_base__GetIndex();

	if (FCL_INDEX < 255)
	{

		// .Return = Char$ (ascii_returns, .index)
		FCR_RETVAL = FCI_GETCHAR("123A456B789C*0#D", 17, FCL_INDEX);

	} else {

		// .Return = .index
		FCR_RETVAL = FCL_INDEX;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the ASCII value for the current keypress and returns in the form of a string. If no key pressed then the macro returns a null string.
       :
       :Returns : Single character representing the pressed key, or an empty string if none pressed.
\*=----------------------------------------------------------------------=*/
void FCD_08c31_keypad_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;


	FCL_INDEX = FCD_08c31_keypad_base__GetIndex();

	if (FCL_INDEX < 255)
	{

		// .Return = Mid$ (ascii_returns, .index,1)
		FCI_MIDSTRING("123A456B789C*0#D", 17, FCL_INDEX, 1, FCR_RETVAL,20);

	} else {

		// .Return = ""
		FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base__Prv_GetRow()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX = (0x0);
	MX_BOOL FCL_PIN_STATE = (0);
	MX_UINT8 FCR_RETVAL;


	// .index = 0
	// .Return = 255
	FCL_INDEX = 0;
	FCR_RETVAL = 255;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				// .pin_state = pin_row1
				FCL_PIN_STATE = GET_PORT_PIN(C, 4);

				break;
			}
			case 1:
			{
				// .pin_state = pin_row2
				FCL_PIN_STATE = GET_PORT_PIN(C, 5);

				break;
			}
			case 2:
			{
				// .pin_state = pin_row3
				FCL_PIN_STATE = GET_PORT_PIN(C, 6);

				break;
			}
			case 3:
			{
				// .pin_state = pin_row4
				FCL_PIN_STATE = GET_PORT_PIN(C, 7);

				break;
			}
			default:
			{
			}
		}

		if (FCL_PIN_STATE > 0)
		{

			// .Return = .index
			FCR_RETVAL = FCL_INDEX;

			goto FCC_Prv_GetRow_A;

		// } else {

		}

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

FCC_Prv_GetRow_A:
	;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the numeric value for the current keypress. If no key pressed then the macro returns the value 255.
       :
       :Returns : Number return value of the pressed key, or 255 if none pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base__GetNumber()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL; // Number return value of the pressed key, or 255 if none pressed.


	FCR_RETVAL = FCD_08c31_keypad_base__GetIndex();

	if (FCR_RETVAL < 255)
	{

		FCR_RETVAL = FCD_00fb1_lut__INTLIST(FCR_RETVAL);

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the index value for the current keypress. If no key pressed then the macro returns the value 255.
       :
       :Returns : Index of the pressed switch, or 255 if none pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base__GetIndex()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX = (0x0);
	MX_UINT8 FCL_ROW_STATE;
	MX_UINT8 FCR_RETVAL; // Index of the pressed switch, or 255 if none pressed.


	FCD_08c31_keypad_base__Prv_FloatColumns();

	// .index = 0
	// .Return = 255
	FCL_INDEX = 0;
	FCR_RETVAL = 255;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// pin_col1 = 1
					SET_PORT_PIN(C, 0, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// pin_col2 = 1
					SET_PORT_PIN(C, 1, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// pin_col3 = 1
					SET_PORT_PIN(C, 2, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// pin_col4 = 1
					SET_PORT_PIN(C, 3, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		FCI_DELAYBYTE_US(20);

		FCL_ROW_STATE = FCD_08c31_keypad_base__Prv_GetRow();

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// pin_col1 = 0
					SET_PORT_PIN(C, 0, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// pin_col2 = 0
					SET_PORT_PIN(C, 1, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// pin_col3 = 0
					SET_PORT_PIN(C, 2, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// pin_col4 = 0
					SET_PORT_PIN(C, 3, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		if (FCL_ROW_STATE < 255)
		{

			// .Return = (.row_state * num_columns) + .index
			FCR_RETVAL = (FCL_ROW_STATE * 4) + FCL_INDEX;

			goto FCC_GetIndex_A;

		// } else {

		}

		FCI_DELAYBYTE_US(50);

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

FCC_GetIndex_A:
	;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_08c31_keypad_base__Prv_FloatColumns()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;
	MX_UINT8 FCL_DUMMY;


	// .index = 0
	FCL_INDEX = 0;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// .dummy = pin_row1
					FCL_DUMMY = GET_PORT_PIN(C, 4);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// .dummy = pin_row2
					FCL_DUMMY = GET_PORT_PIN(C, 5);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// .dummy = pin_row3
					FCL_DUMMY = GET_PORT_PIN(C, 6);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// .dummy = pin_row4
					FCL_DUMMY = GET_PORT_PIN(C, 7);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

	// .index = 0
	FCL_INDEX = 0;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// pin_col1 = 0
					SET_PORT_PIN(C, 0, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// pin_col2 = 0
					SET_PORT_PIN(C, 1, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// pin_col3 = 0
					SET_PORT_PIN(C, 2, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// pin_col4 = 0
					SET_PORT_PIN(C, 3, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call that waits for the keys on the keypad to be released. If no key is pressed then the function will return immediatley.
\*=----------------------------------------------------------------------=*/
void FCD_08c31_keypad_base__WaitReleased()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;


	while (1)
	{

		FCL_INDEX = FCD_08c31_keypad_base__GetIndex();


		if ((FCL_INDEX < 255) == 0) break;
	}

}


/*========================================================================*\
   Use :keypad_4x4
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Blocking call that waits for one of the keys on the keypad to be pressed. The index of the key that was pressed  is passed back to the user.
       :
       :Returns : Index of the first key pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0a211_keypad_4x4__WaitPressed()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL; // Index of the first key pressed.


	// .Return = keypad_base :: WaitPressed ()
	FCR_RETVAL = FCD_08c31_keypad_base__WaitPressed();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the ASCII value for the current keypress. If no key is pressed then the macro returns the value 255.
       :
       :Returns : ASCII code of the pressed switch (or 255 if none pressed)
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0a211_keypad_4x4__GetAscii()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL; // ASCII code of the pressed switch (or 255 if none pressed)


	// .Return = keypad_base :: GetAscii ()
	FCR_RETVAL = FCD_08c31_keypad_base__GetAscii();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the ASCII value for the current keypress and returns in the form of a string. If no key pressed then the macro returns the value 255.
       :
       :Returns : Single character representing the pressed key, or an empty string if none pressed.
\*=----------------------------------------------------------------------=*/
void FCD_0a211_keypad_4x4__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions

	// .Return = keypad_base :: GetString ()
	FCD_08c31_keypad_base__GetString(FCR_RETVAL,20 );

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the numeric value for the current keypress. If no key pressed then the macro returns the value 255.
       :
       :Returns : Number return value of the pressed key, or 255 if none pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0a211_keypad_4x4__GetNumber()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL; // Number return value of the pressed key, or 255 if none pressed.


	// .Return = keypad_base :: GetNumber ()
	FCR_RETVAL = FCD_08c31_keypad_base__GetNumber();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the index value for the current keypress. If no key pressed then the macro returns the value 255.
       :
       :Returns : Index of the pressed switch, or 255 if none pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0a211_keypad_4x4__GetIndex()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL; // Index of the pressed switch, or 255 if none pressed.


	// .Return = keypad_base :: GetIndex ()
	FCR_RETVAL = FCD_08c31_keypad_base__GetIndex();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call that waits for the keys on the keypad to be released. If no key is pressed then the function will return immediatley.
\*=----------------------------------------------------------------------=*/
void FCD_0a211_keypad_4x4__WaitReleased()
{

	// keypad_base :: WaitReleased ()
	FCD_08c31_keypad_base__WaitReleased();

}


/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_modification_mdp()
{

	// Name: Calculation, Type: Calculation:
	// nbChiffre = 0
	FCV_NBCHIFFRE = 0;

	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Clear()
	FCD_0f9e1_lcd_16x2__Clear();

	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString("Entrer nouveau")
	FCD_0f9e1_lcd_16x2__PrintString("Entrer nouveau", 15);

	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(0, 1)
	FCD_0f9e1_lcd_16x2__Cursor(0, 1);

	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString("mot de passe")
	FCD_0f9e1_lcd_16x2__PrintString("mot de passe", 13);

	// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitPressed()
	FCD_0a211_keypad_4x4__WaitPressed();

	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Clear()
	FCD_0f9e1_lcd_16x2__Clear();

	// Name: Loop, Type: Loop: While validation == false
	while (FCV_VALIDATION == FCV_FALSE)
	{

		// Name: Loop, Type: Loop: Until nbChiffre >= 4
		while (!(FCV_NBCHIFFRE >= 4))
		{

			// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitPressed()
			FCD_0a211_keypad_4x4__WaitPressed();

			// Name: Call Component Macro, Type: Call Component Macro: Key=keypad_4x4::GetNumber()
			FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();

			// Name: Decision, Type: Decision: Key < 10?
			if (FCV_KEY < 10)
			{

				// Name: Calculation, Type: Calculation:
				// mdp[nbChiffre] = Key
				FCV_MDP[FCV_NBCHIFFRE] = FCV_KEY;

				// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(nbChiffre, 1)
				FCD_0f9e1_lcd_16x2__Cursor(FCV_NBCHIFFRE, 1);

				// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintNumber(Key)
				FCD_0f9e1_lcd_16x2__PrintNumber(FCV_KEY);

				// Name: Calculation, Type: Calculation:
				// nbChiffre = nbChiffre + 1
				FCV_NBCHIFFRE = FCV_NBCHIFFRE + 1;

			} else {

				// Name: Decision, Type: Decision: Key == 14 && nbChiffre > 0?
				if (FCV_KEY == 14 && FCV_NBCHIFFRE > 0)
				{

					// Name: Calculation, Type: Calculation:
					// nbChiffre = nbChiffre - 1
					FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;

					// Name: Calculation, Type: Calculation:
					// mdp[nbChiffre] = 0
					FCV_MDP[FCV_NBCHIFFRE] = 0;

					// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(nbChiffre, 1)
					FCD_0f9e1_lcd_16x2__Cursor(FCV_NBCHIFFRE, 1);

					// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString(" ")
					FCD_0f9e1_lcd_16x2__PrintString(" ", 2);

				// } else {

				}

			}

			// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitReleased()
			FCD_0a211_keypad_4x4__WaitReleased();


		}

		// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitPressed()
		FCD_0a211_keypad_4x4__WaitPressed();

		// Name: Call Component Macro, Type: Call Component Macro: Key=keypad_4x4::GetNumber()
		FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();

		// Name: Decision, Type: Decision: Key == 15?
		if (FCV_KEY == 15)
		{

			// Name: Calculation, Type: Calculation:
			// validation = true
			FCV_VALIDATION = FCV_TRUE;

		} else {

			// Name: Decision, Type: Decision: Key == 14?
			if (FCV_KEY == 14)
			{

				// Name: Calculation, Type: Calculation:
				// nbChiffre = nbChiffre - 1
				FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;

				// Name: Calculation, Type: Calculation:
				// code[nbChiffre] = 0
				FCV_CODE[FCV_NBCHIFFRE] = 0;

				// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(nbChiffre, 1)
				FCD_0f9e1_lcd_16x2__Cursor(FCV_NBCHIFFRE, 1);

				// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString(" ")
				FCD_0f9e1_lcd_16x2__PrintString(" ", 2);

				// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitReleased()
				FCD_0a211_keypad_4x4__WaitReleased();

			// } else {

			}

		}


	}

	// Name: Call Component Macro, Type: Call Component Macro: eeprom1::Write(1, mdp[0])
	FCD_06651_eeprom1__Write(1, FCV_MDP[0]);

	// Name: Call Component Macro, Type: Call Component Macro: eeprom1::Write(2, mdp[1])
	FCD_06651_eeprom1__Write(2, FCV_MDP[1]);

	// Name: Call Component Macro, Type: Call Component Macro: eeprom1::Write(3, mdp[2])
	FCD_06651_eeprom1__Write(3, FCV_MDP[2]);

	// Name: Call Component Macro, Type: Call Component Macro: eeprom1::Write(4, mdp[3])
	FCD_06651_eeprom1__Write(4, FCV_MDP[3]);

	// Name: Calculation, Type: Calculation:
	// validation = false
	FCV_VALIDATION = FCV_FALSE;

}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCM_custom_keypad_get_number()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	// Name: Loop, Type: Loop: While 1
	while (1)
	{


	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_identification()
{

	// Name: Calculation, Type: Calculation:
	// code[0] = 20
	// code[1] = 20
	// code[2] = 20
	// code[3] = 20
	FCV_CODE[0] = 20;
	FCV_CODE[1] = 20;
	FCV_CODE[2] = 20;
	FCV_CODE[3] = 20;

	// Name: Call Component Macro, Type: Call Component Macro: mdp[0]=eeprom1::Read(1)
	FCV_MDP[0] = FCD_06651_eeprom1__Read(1);

	// Name: Call Component Macro, Type: Call Component Macro: mdp[1]=eeprom1::Read(2)
	FCV_MDP[1] = FCD_06651_eeprom1__Read(2);

	// Name: Call Component Macro, Type: Call Component Macro: mdp[2]=eeprom1::Read(3)
	FCV_MDP[2] = FCD_06651_eeprom1__Read(3);

	// Name: Call Component Macro, Type: Call Component Macro: mdp[3]=eeprom1::Read(4)
	FCV_MDP[3] = FCD_06651_eeprom1__Read(4);

	// Name: Loop, Type: Loop: While code[0] != mdp[0] || code[1] != mdp[1] || code[2] != mdp[2] || code[3] != mdp[3]
	while (FCV_CODE[0] != FCV_MDP[0] || FCV_CODE[1] != FCV_MDP[1] || FCV_CODE[2] != FCV_MDP[2] || FCV_CODE[3] != FCV_MDP[3])
	{

		// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Clear()
		FCD_0f9e1_lcd_16x2__Clear();

		// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(0, 0)
		FCD_0f9e1_lcd_16x2__Cursor(0, 0);

		// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString("Identifiez vous")
		FCD_0f9e1_lcd_16x2__PrintString("Identifiez vous", 16);

		// Name: Calculation, Type: Calculation:
		// nbChiffre = 0
		FCV_NBCHIFFRE = 0;

		// Name: Loop, Type: Loop: While validation == false
		while (FCV_VALIDATION == FCV_FALSE)
		{

			// Name: Loop, Type: Loop: Until nbChiffre >= 4
			while (!(FCV_NBCHIFFRE >= 4))
			{

				// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitPressed()
				FCD_0a211_keypad_4x4__WaitPressed();

				// Name: Call Component Macro, Type: Call Component Macro: Key=keypad_4x4::GetNumber()
				FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();

				// Name: Decision, Type: Decision: Key < 10?
				if (FCV_KEY < 10)
				{

					//Comment:
					//Record Key Press

					// Name: Calculation, Type: Calculation:
					// code[nbChiffre] = Key
					FCV_CODE[FCV_NBCHIFFRE] = FCV_KEY;

					// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(nbChiffre, 1)
					FCD_0f9e1_lcd_16x2__Cursor(FCV_NBCHIFFRE, 1);

					// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString("*")
					FCD_0f9e1_lcd_16x2__PrintString("*", 2);

					// Name: Calculation, Type: Calculation:
					// nbChiffre = nbChiffre + 1
					FCV_NBCHIFFRE = FCV_NBCHIFFRE + 1;

				} else {

					//Comment:
					//Delate a key

					// Name: Decision, Type: Decision: Key == 14 && nbChiffre > 0?
					if (FCV_KEY == 14 && FCV_NBCHIFFRE > 0)
					{

						// Name: Calculation, Type: Calculation:
						// nbChiffre = nbChiffre - 1
						FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;

						// Name: Calculation, Type: Calculation:
						// code[nbChiffre] = 0
						FCV_CODE[FCV_NBCHIFFRE] = 0;

						// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(nbChiffre, 1)
						FCD_0f9e1_lcd_16x2__Cursor(FCV_NBCHIFFRE, 1);

						// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString(" ")
						FCD_0f9e1_lcd_16x2__PrintString(" ", 2);

					// } else {

					}

				}

				// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitReleased()
				FCD_0a211_keypad_4x4__WaitReleased();


			}

			// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitPressed()
			FCD_0a211_keypad_4x4__WaitPressed();

			// Name: Call Component Macro, Type: Call Component Macro: Key=keypad_4x4::GetNumber()
			FCV_KEY = FCD_0a211_keypad_4x4__GetNumber();

			//Comment:
			//Delate a key

			// Name: Decision, Type: Decision: Key == 14?
			if (FCV_KEY == 14)
			{

				// Name: Calculation, Type: Calculation:
				// nbChiffre = nbChiffre - 1
				FCV_NBCHIFFRE = FCV_NBCHIFFRE - 1;

				// Name: Calculation, Type: Calculation:
				// code[nbChiffre] = 0
				FCV_CODE[FCV_NBCHIFFRE] = 0;

				// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Cursor(nbChiffre, 1)
				FCD_0f9e1_lcd_16x2__Cursor(FCV_NBCHIFFRE, 1);

				// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString(" ")
				FCD_0f9e1_lcd_16x2__PrintString(" ", 2);

				// Name: Call Component Macro, Type: Call Component Macro: keypad_4x4::WaitReleased()
				FCD_0a211_keypad_4x4__WaitReleased();

			// } else {

			}

			// Name: Decision, Type: Decision: Key == 15?
			if (FCV_KEY == 15)
			{

				// Name: Calculation, Type: Calculation:
				// validation = true
				FCV_VALIDATION = FCV_TRUE;

			// } else {

			}


		}

		// Name: Decision, Type: Decision: code[0] != mdp[0] || code[1] != mdp[1] || code[2] != mdp[2] || code[3] != mdp[3]?
		if (FCV_CODE[0] != FCV_MDP[0] || FCV_CODE[1] != FCV_MDP[1] || FCV_CODE[2] != FCV_MDP[2] || FCV_CODE[3] != FCV_MDP[3])
		{

			// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Clear()
			FCD_0f9e1_lcd_16x2__Clear();

			// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString("code faux")
			FCD_0f9e1_lcd_16x2__PrintString("code faux", 10);

			// Name: Delay, Type: Delay: 2 s
			FCI_DELAYBYTE_S(2);

		// } else {

		}

		// Name: Calculation, Type: Calculation:
		// validation = false
		FCV_VALIDATION = FCV_FALSE;


	}

	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Clear()
	FCD_0f9e1_lcd_16x2__Clear();

	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintString("Bienvenue")
	FCD_0f9e1_lcd_16x2__PrintString("Bienvenue", 10);

	// Name: Delay, Type: Delay: 1 s
	FCI_DELAYBYTE_S(1);

}



/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
ADCON1 = 0x07;

OPTION_REG = 0xC0;


	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Start()
	FCD_0f9e1_lcd_16x2__Start();

	//Comment:
	//First Authentification

	// Name: Call Component Macro, Type: Call Component Macro: has_set_password=eeprom1::Read(0)
	FCV_HAS_SET_PASSWORD = FCD_06651_eeprom1__Read(0);

	// Name: Decision, Type: Decision: has_set_password == false?
	if (FCV_HAS_SET_PASSWORD == FCV_FALSE)
	{

		// Name: Call Macro, Type: Call Macro: modification_mdp()
		FCM_modification_mdp();

		// Name: Calculation, Type: Calculation:
		// has_set_password = true
		FCV_HAS_SET_PASSWORD = FCV_TRUE;

		// Name: Call Component Macro, Type: Call Component Macro: eeprom1::Write(0, has_set_password)
		FCD_06651_eeprom1__Write(0, FCV_HAS_SET_PASSWORD);

	// } else {

	}

	//Comment:
	//First Authentification

	// Name: Call Macro, Type: Call Macro: identification()
	FCM_identification();

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

}




