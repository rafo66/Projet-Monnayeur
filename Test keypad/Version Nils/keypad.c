//************************************************************************************
//**  
//**  Source name:   C:\Users\USERX\OneDrive - Conseil régional Grand Est - Numérique Educatif\Lycée\Terminale\2I2D\Projet\Test keypad\keypad.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.16F.16F877
//**  
//**  Generated by:  Flowcode v8.2.2.15
//**  Date:          Tuesday, April 04, 2023 13:49:39
//**  Users:         1
//**  Registered to:  LYC-LORITZ54-V8
//**  License key: UJJ0K6
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  https://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_CAL_PIC

#define MX_CLK_SPEED 19660800

#define FCP_NULL Unconnected_Port


#include <xc.h>
#include <math.h>
//Chip Configuration Settings
__PROG_CONFIG(0x1, 0x3FF9);

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\internals.c"





/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_VAR 20
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_CHAR FCV_VAR[FCVsz_VAR];
MX_GLOBAL MX_UINT8 FCV_NUMBER;


/*========================================================================*\
   Use :ctrl_lcd
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_16x2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f9e1_lcd_16x2__Clear FCD_04071_LCD__Clear
#define FCD_0f9e1_lcd_16x2__PrintString FCD_04071_LCD__PrintString
#define FCD_0f9e1_lcd_16x2__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0f9e1_lcd_16x2__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0f9e1_lcd_16x2__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0f9e1_lcd_16x2__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0f9e1_lcd_16x2__Cursor FCD_04071_LCD__Cursor
#define FCD_0f9e1_lcd_16x2__Command FCD_04071_LCD__Command
#define FCD_0f9e1_lcd_16x2__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0f9e1_lcd_16x2__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0f9e1_lcd_16x2__RawSend FCD_04071_LCD__RawSend
#define FCD_0f9e1_lcd_16x2__RemapCharacter FCD_04071_LCD__RemapCharacter
#define FCD_0f9e1_lcd_16x2__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :lut
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_lut__FLOATFIXEDLIST 1
#define FCVsz_00fb1_lut__INTLIST 16
#define FCVsz_00fb1_lut__FLOATLIST 1
#define FCVsz_00fb1_lut__INTFIXEDLIST 1
#define FCD_00fb1_lut__INTLIST(ix) FCD_00fb1_lut__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_lut__INTLIST_LUT ROMARRAY_E =
{
// Property added elements
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
// Dynamically added elements
 
};

MX_UINT16 FCD_00fb1_lut__GetLUTCount();

/*========================================================================*\
   Use :keypad_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_08c31_keypad_base1__WaitPressed();
MX_UINT8 FCD_08c31_keypad_base1__GetAscii();
void FCD_08c31_keypad_base1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08c31_keypad_base1__Prv_GetRow();
MX_UINT8 FCD_08c31_keypad_base1__GetNumber();
MX_UINT8 FCD_08c31_keypad_base1__GetIndex();
void FCD_08c31_keypad_base1__Prv_FloatColumns();
void FCD_08c31_keypad_base1__WaitReleased();

/*========================================================================*\
   Use :keypad_hex1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_02111_keypad_hex1__WaitPressed FCD_08c31_keypad_base1__WaitPressed
#define FCD_02111_keypad_hex1__GetAscii FCD_08c31_keypad_base1__GetAscii
#define FCD_02111_keypad_hex1__GetString FCD_08c31_keypad_base1__GetString
#define FCD_02111_keypad_hex1__GetNumber FCD_08c31_keypad_base1__GetNumber
#define FCD_02111_keypad_hex1__GetIndex FCD_08c31_keypad_base1__GetIndex
#define FCD_02111_keypad_hex1__WaitReleased FCD_08c31_keypad_base1__WaitReleased

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Local variable definitions
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;


	// .count = Length$ (.Text)
	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		#else


			FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		#endif

		// .Idx = .Idx + 1
		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Local variable definitions
#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	// .s = ToString$ (.Number)
	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Local variable definitions
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		// .x = 0
		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			// .x = .x + 1
			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			// .y = 0x80
			FCL_Y = 0x80;

		} else {

			// .y = 0xC0
			FCL_Y = 0xC0;

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 2 == 4

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

	//Comment:
	//EB2 LCDs have occasional problems here if cursor command isn't called twice

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Local variable definitions
#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		// .s = STRING UNSIGNED .Number
		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		// .s = STRING SIGNED .Number
		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  Position : Holds the number of positions to shift the display
       :  Direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Local variable definitions
	MX_UINT8 FCL_CMD = (0x0);


	// .cmd = 0
	FCL_CMD = 0;

	if (FCL_DIRECTION == 0)
	{

		// .cmd = 0x18
		FCL_CMD = 0x18;


	} else {

		// .cmd = 0x1C
		FCL_CMD = 0x1C;


	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			// .Position = .Position - 1
			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Local variable definitions
	MX_UINT8 FCL_NIBBLE;


	//Comment:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		// Pin_Data_0 = 0
		// Pin_Data_1 = 0
		// Pin_Data_2 = 0
		// Pin_Data_3 = 0
		// Pin_RS = 0
		// Pin_E = 0
		SET_PORT_PIN(B, 0, 0);
		SET_PORT_PIN(B, 1, 0);
		SET_PORT_PIN(B, 2, 0);
		SET_PORT_PIN(B, 3, 0);
		SET_PORT_PIN(B, 4, 0);
		SET_PORT_PIN(B, 5, 0);

		#if (0)

		//Code has been optimised out by the pre-processor
		// #else

		#endif

		// .nibble = (.data >> 4)
		// Pin_Data_0 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_1 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_2 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_3 = (.nibble & 0x01)
		FCL_NIBBLE = (FCL_DATA >> 4);
		SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	//Comment:
	//Output byte to pins

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	//Comment:
	//Output byte to port

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	if (FCL_TYPE)
	{

		// Pin_RS = 1
		SET_PORT_PIN(B, 4, 1);

	// } else {

	}

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCI_DELAYBYTE_US(100);

	//Comment:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	// Pin_E = 1
	SET_PORT_PIN(B, 5, 1);

	FCI_DELAYBYTE_US(100);

	// Pin_E = 0
	SET_PORT_PIN(B, 5, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		// Pin_Data_0 = 0
		// Pin_Data_1 = 0
		// Pin_Data_2 = 0
		// Pin_Data_3 = 0
		// Pin_RS = 0
		SET_PORT_PIN(B, 0, 0);
		SET_PORT_PIN(B, 1, 0);
		SET_PORT_PIN(B, 2, 0);
		SET_PORT_PIN(B, 3, 0);
		SET_PORT_PIN(B, 4, 0);

		// .nibble = (.data & 0xf)
		// Pin_Data_0 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_1 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_2 = (.nibble & 0x01)
		// .nibble = .nibble >> 1
		// Pin_Data_3 = (.nibble & 0x01)
		FCL_NIBBLE = (FCL_DATA & 0xf);
		SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			// Pin_RS = 1
			SET_PORT_PIN(B, 4, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		// Pin_E = 1
		SET_PORT_PIN(B, 5, 1);

		FCI_DELAYBYTE_US(100);

		// Pin_E = 0
		SET_PORT_PIN(B, 5, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{




	#if (1) // 0 == 0

		// Pin_Data_0 = 0
		// Pin_Data_1 = 0
		// Pin_Data_2 = 0
		// Pin_Data_3 = 0
		// Pin_RS = 0
		// Pin_E = 0
		SET_PORT_PIN(B, 0, 0);
		SET_PORT_PIN(B, 1, 0);
		SET_PORT_PIN(B, 2, 0);
		SET_PORT_PIN(B, 3, 0);
		SET_PORT_PIN(B, 4, 0);
		SET_PORT_PIN(B, 5, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}


/*========================================================================*\
   Use :lcd_16x2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :lut
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_lut__GetLUTCount()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	// .Return = NumVals
	FCR_RETVAL = 16;

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :keypad_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Blocking call that waits for one of the keys on the keypad to be pressed. The index of the key that was pressed  is passed back to the user.
       :
       :Returns : Index of the first key pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base1__WaitPressed()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;
	MX_UINT8 FCR_RETVAL; // Index of the first key pressed.


	while (1)
	{

		FCL_INDEX = FCD_08c31_keypad_base1__GetIndex();


		if ((FCL_INDEX == 255) == 0) break;
	}

	// .return = .index
	FCR_RETVAL = FCL_INDEX;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the ASCII value for the current keypress. If no key is pressed then the macro returns the value 255.
       :
       :Returns : ASCII code of the pressed switch (or 255 if none pressed)
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base1__GetAscii()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;
	MX_UINT8 FCR_RETVAL; // ASCII code of the pressed switch (or 255 if none pressed)


	FCL_INDEX = FCD_08c31_keypad_base1__GetIndex();

	if (FCL_INDEX < 255)
	{

		// .Return = Char$ (ascii_returns, .index)
		FCR_RETVAL = FCI_GETCHAR("0123456789ABCDEF", 17, FCL_INDEX);

	} else {

		// .Return = .index
		FCR_RETVAL = FCL_INDEX;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the ASCII value for the current keypress and returns in the form of a string. If no key pressed then the macro returns a null string.
       :
       :Returns : Single character representing the pressed key, or an empty string if none pressed.
\*=----------------------------------------------------------------------=*/
void FCD_08c31_keypad_base1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;


	FCL_INDEX = FCD_08c31_keypad_base1__GetIndex();

	if (FCL_INDEX < 255)
	{

		// .Return = Mid$ (ascii_returns, .index,1)
		FCI_MIDSTRING("0123456789ABCDEF", 17, FCL_INDEX, 1, FCR_RETVAL,20);

	} else {

		// .Return = ""
		FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base1__Prv_GetRow()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX = (0x0);
	MX_BOOL FCL_PIN_STATE = (0);
	MX_UINT8 FCR_RETVAL;


	// .index = 0
	// .Return = 255
	FCL_INDEX = 0;
	FCR_RETVAL = 255;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				// .pin_state = pin_row1
				FCL_PIN_STATE = GET_PORT_PIN(C, 4);

				break;
			}
			case 1:
			{
				// .pin_state = pin_row2
				FCL_PIN_STATE = GET_PORT_PIN(C, 5);

				break;
			}
			case 2:
			{
				// .pin_state = pin_row3
				FCL_PIN_STATE = GET_PORT_PIN(C, 6);

				break;
			}
			case 3:
			{
				// .pin_state = pin_row4
				FCL_PIN_STATE = GET_PORT_PIN(C, 7);

				break;
			}
			default:
			{
			}
		}

		if (FCL_PIN_STATE > 0)
		{

			// .Return = .index
			FCR_RETVAL = FCL_INDEX;

			goto FCC_Prv_GetRow_A;

		// } else {

		}

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

FCC_Prv_GetRow_A:
	;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the numeric value for the current keypress. If no key pressed then the macro returns the value 255.
       :
       :Returns : Number return value of the pressed key, or 255 if none pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base1__GetNumber()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL; // Number return value of the pressed key, or 255 if none pressed.


	FCR_RETVAL = FCD_08c31_keypad_base1__GetIndex();

	if (FCR_RETVAL < 255)
	{

		FCR_RETVAL = FCD_00fb1_lut__INTLIST(FCR_RETVAL);

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the index value for the current keypress. If no key pressed then the macro returns the value 255.
       :
       :Returns : Index of the pressed switch, or 255 if none pressed.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08c31_keypad_base1__GetIndex()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX = (0x0);
	MX_UINT8 FCL_ROW_STATE;
	MX_UINT8 FCR_RETVAL; // Index of the pressed switch, or 255 if none pressed.


	FCD_08c31_keypad_base1__Prv_FloatColumns();

	// .index = 0
	// .Return = 255
	FCL_INDEX = 0;
	FCR_RETVAL = 255;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// pin_col1 = 1
					SET_PORT_PIN(C, 0, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// pin_col2 = 1
					SET_PORT_PIN(C, 1, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// pin_col3 = 1
					SET_PORT_PIN(C, 2, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// pin_col4 = 1
					SET_PORT_PIN(C, 3, 1);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		FCI_DELAYBYTE_US(20);

		FCL_ROW_STATE = FCD_08c31_keypad_base1__Prv_GetRow();

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// pin_col1 = 0
					SET_PORT_PIN(C, 0, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// pin_col2 = 0
					SET_PORT_PIN(C, 1, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// pin_col3 = 0
					SET_PORT_PIN(C, 2, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// pin_col4 = 0
					SET_PORT_PIN(C, 3, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		if (FCL_ROW_STATE < 255)
		{

			// .Return = (.row_state * num_columns) + .index
			FCR_RETVAL = (FCL_ROW_STATE * 4) + FCL_INDEX;

			goto FCC_GetIndex_A;

		// } else {

		}

		FCI_DELAYBYTE_US(50);

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

FCC_GetIndex_A:
	;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_08c31_keypad_base1__Prv_FloatColumns()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;
	MX_UINT8 FCL_DUMMY;


	// .index = 0
	FCL_INDEX = 0;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// .dummy = pin_row1
					FCL_DUMMY = GET_PORT_PIN(C, 4);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// .dummy = pin_row2
					FCL_DUMMY = GET_PORT_PIN(C, 5);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// .dummy = pin_row3
					FCL_DUMMY = GET_PORT_PIN(C, 6);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// .dummy = pin_row4
					FCL_DUMMY = GET_PORT_PIN(C, 7);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

	// .index = 0
	FCL_INDEX = 0;

	while (FCL_INDEX < 4)
	{

		switch (FCL_INDEX)
		{
			case 0:
			{
				#if (1) // 4 >= 1

					// pin_col1 = 0
					SET_PORT_PIN(C, 0, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 1:
			{
				#if (1) // 4 >= 2

					// pin_col2 = 0
					SET_PORT_PIN(C, 1, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 2:
			{
				#if (1) // 4 >= 3

					// pin_col3 = 0
					SET_PORT_PIN(C, 2, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			case 3:
			{
				#if (1) // 4 >= 4

					// pin_col4 = 0
					SET_PORT_PIN(C, 3, 0);

				// #else

				//Code has been optimised out by the pre-processor
				#endif

				break;
			}
			default:
			{
			}
		}

		// .index = .index + 1
		FCL_INDEX = FCL_INDEX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call that waits for the keys on the keypad to be released. If no key is pressed then the function will return immediatley.
\*=----------------------------------------------------------------------=*/
void FCD_08c31_keypad_base1__WaitReleased()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;


	while (1)
	{

		FCL_INDEX = FCD_08c31_keypad_base1__GetIndex();


		if ((FCL_INDEX < 255) == 0) break;
	}

}


/*========================================================================*\
   Use :keypad_hex1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
ADCON1 = 0x07;

OPTION_REG = 0xC0;


	// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Start()
	FCD_0f9e1_lcd_16x2__Start();

	// Name: Loop, Type: Loop: While 1
	while (1)
	{

		// Name: Call Component Macro, Type: Call Component Macro: keypad_hex1::WaitReleased()
		FCD_02111_keypad_hex1__WaitReleased();

		// Name: Call Component Macro, Type: Call Component Macro: keypad_hex1::WaitPressed()
		FCD_02111_keypad_hex1__WaitPressed();

		// Name: Call Component Macro, Type: Call Component Macro: number=keypad_hex1::GetNumber()
		FCV_NUMBER = FCD_02111_keypad_hex1__GetNumber();

		// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::Clear()
		FCD_0f9e1_lcd_16x2__Clear();

		// Name: Call Component Macro, Type: Call Component Macro: lcd_16x2::PrintNumber(number)
		FCD_0f9e1_lcd_16x2__PrintNumber(FCV_NUMBER);


	}

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

}




