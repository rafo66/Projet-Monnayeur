//************************************************************************************
//**  
//**  Source name:   C:\Users\USERX\OneDrive - Conseil régional Grand Est - Numérique Educatif\Lycée\Terminale\2I2D\Projet\Proteus final\Template flowcode 8\flowcode finalfcfx.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.16F.16F877
//**  
//**  Generated by:  Flowcode v8.2.2.15
//**  Date:          Friday, March 31, 2023 00:05:09
//**  Users:         1
//**  Registered to:  LYC-LORITZ54-V8
//**  License key: UJJ0K6
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  https://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_CAL_PIC

#define MX_CLK_SPEED 19660800

#define FCP_NULL Unconnected_Port


#include <xc.h>
#include <math.h>
//Chip Configuration Settings
__PROG_CONFIG(0x1, 0x3FF9);

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\internals.c"



MX_UINT8 FCLV_LOOP1;


/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)


/*========================================================================*\
   Use :auto_labels1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05268_switch_base1__ReadState();
void FCD_05268_switch_base1__WaitUntilHigh();
void FCD_05268_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target8
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f388_default_target8__ReadState FCD_05268_switch_base1__ReadState
#define FCD_0f388_default_target8__WaitUntilHigh FCD_05268_switch_base1__WaitUntilHigh
#define FCD_0f388_default_target8__WaitUntilLow FCD_05268_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05267_switch_base1__ReadState();
void FCD_05267_switch_base1__WaitUntilHigh();
void FCD_05267_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target7
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f387_default_target7__ReadState FCD_05267_switch_base1__ReadState
#define FCD_0f387_default_target7__WaitUntilHigh FCD_05267_switch_base1__WaitUntilHigh
#define FCD_0f387_default_target7__WaitUntilLow FCD_05267_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05266_switch_base1__ReadState();
void FCD_05266_switch_base1__WaitUntilHigh();
void FCD_05266_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target6
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f386_default_target6__ReadState FCD_05266_switch_base1__ReadState
#define FCD_0f386_default_target6__WaitUntilHigh FCD_05266_switch_base1__WaitUntilHigh
#define FCD_0f386_default_target6__WaitUntilLow FCD_05266_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05265_switch_base1__ReadState();
void FCD_05265_switch_base1__WaitUntilHigh();
void FCD_05265_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target5
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f385_default_target5__ReadState FCD_05265_switch_base1__ReadState
#define FCD_0f385_default_target5__WaitUntilHigh FCD_05265_switch_base1__WaitUntilHigh
#define FCD_0f385_default_target5__WaitUntilLow FCD_05265_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05264_switch_base1__ReadState();
void FCD_05264_switch_base1__WaitUntilHigh();
void FCD_05264_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f384_default_target4__ReadState FCD_05264_switch_base1__ReadState
#define FCD_0f384_default_target4__WaitUntilHigh FCD_05264_switch_base1__WaitUntilHigh
#define FCD_0f384_default_target4__WaitUntilLow FCD_05264_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05263_switch_base1__ReadState();
void FCD_05263_switch_base1__WaitUntilHigh();
void FCD_05263_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target3
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f383_default_target3__ReadState FCD_05263_switch_base1__ReadState
#define FCD_0f383_default_target3__WaitUntilHigh FCD_05263_switch_base1__WaitUntilHigh
#define FCD_0f383_default_target3__WaitUntilLow FCD_05263_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05262_switch_base1__ReadState();
void FCD_05262_switch_base1__WaitUntilHigh();
void FCD_05262_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f382_default_target2__ReadState FCD_05262_switch_base1__ReadState
#define FCD_0f382_default_target2__WaitUntilHigh FCD_05262_switch_base1__WaitUntilHigh
#define FCD_0f382_default_target2__WaitUntilLow FCD_05262_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05261_switch_base1__ReadState();
void FCD_05261_switch_base1__WaitUntilHigh();
void FCD_05261_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :default_target1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0f381_default_target1__ReadState FCD_05261_switch_base1__ReadState
#define FCD_0f381_default_target1__WaitUntilHigh FCD_05261_switch_base1__WaitUntilHigh
#define FCD_0f381_default_target1__WaitUntilLow FCD_05261_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN7
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN6
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN5
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN3
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :EN0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :shape_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :shape_cuboid1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S7
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S6
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S5
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S3
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :S0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :Servo_Controller1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_SERVO_CCPR1H 38
#define MX_SERVO_CCPR1L 107
#define MX_Servo_Channel_Count 8


/*=----------------------------------------------------------------------=*\
   Use :Servo_Controller1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#ifdef MX_CAL_PIC

	#define MX_SERVO_REG_CCPR1H		CCPR1H
	#define MX_SERVO_REG_CCPR1L		CCPR1L
	#define MX_SERVO_REG_CCPR2H		CCPR2H
	#define MX_SERVO_REG_CCPR2L		CCPR2L
	#define MX_SERVO_REG_T1CON		T1CON
	#define MX_SERVO_REG_CCP1CON	CCP1CON
	#define MX_SERVO_REG_CCP2CON 	CCP2CON

#ifdef _PIE6_CCP1IE_POSN
	#define MX_SERVO_REG_CCP1EN		PIE6
	#define MX_SERVO_REG_CCP1F		PIR6
	#define MX_SERVO_REG_CCP2EN		PIE6
	#define MX_SERVO_REG_CCP2F		PIR6
	#define MX_SERVO_CCP1CON	    0x8b
	#define MX_SERVO_CCP2CON	    0x8a
	#define MX_SERVO_T1CON		    0x01
    #define MX_SERVO_T1_CLK         0x01
#else
  #ifdef _PIE3_CCP1IE_POSN
	#define MX_SERVO_REG_CCP1EN		PIE3
	#define MX_SERVO_REG_CCP1F		PIR3
	#define MX_SERVO_REG_CCP2EN		PIE3
	#define MX_SERVO_REG_CCP2F		PIR3
	#define MX_SERVO_CCP1CON	    0x0b
	#define MX_SERVO_CCP2CON	    0x0a
	#define MX_SERVO_T1CON		    0x01
  #else
    #ifdef _PIE4_CCP1IE_POSN
	  #define MX_SERVO_REG_CCP1EN	PIE4
	  #define MX_SERVO_REG_CCP1F	PIR4
	  #define MX_SERVO_REG_CCP2EN	PIE4
	  #define MX_SERVO_REG_CCP2F	PIR4
	  #define MX_SERVO_CCP1CON	    0x8b
	  #define MX_SERVO_CCP2CON	    0x8a
	  #define MX_SERVO_T1CON		0x01
    #else
	  #define MX_SERVO_REG_CCP1EN	PIE1
	  #define MX_SERVO_REG_CCP1F	PIR1
	  #define MX_SERVO_REG_CCP2EN	PIE2
	  #define MX_SERVO_REG_CCP2F	PIR2
	  #define MX_SERVO_CCP1CON	    0x0b
	  #define MX_SERVO_CCP2CON	    0x0a
	  #define MX_SERVO_T1CON		0x01
    #endif
  #endif
#endif

	#define MX_SERVO_FLAG_CCP1EN	CCP1IE
	#define MX_SERVO_FLAG_CCP2EN	CCP2IE
	#define MX_SERVO_FLAG_CCP1F		CCP1IF
	#define MX_SERVO_FLAG_CCP2F		CCP2IF
	#define MX_SERVO_REG_INT		INTCON
	#define MX_SERVO_FLAG_GLOB		GIE
	#define MX_SERVO_FLAG_PERIPH	PEIE

	#define MX_CCP1_INT_START		if (ts_bit(MX_SERVO_REG_CCP1F, MX_SERVO_FLAG_CCP1F) && ts_bit(MX_SERVO_REG_CCP1EN, MX_SERVO_FLAG_CCP1EN))
	#define MX_CCP2_INT_START		if (ts_bit(MX_SERVO_REG_CCP2F, MX_SERVO_FLAG_CCP2F) && ts_bit(MX_SERVO_REG_CCP2EN, MX_SERVO_FLAG_CCP2EN))

#endif

#ifdef MX_CAL_PIC16

	#define MX_SERVO_REG_CCP1F		IFS0bits
	#define MX_SERVO_FLAG_CCP1F		T3IF

	#define MX_SERVO_REG_CCP2F		IFS0bits
	#define MX_SERVO_FLAG_CCP2F		T2IF

	#define MX_CCP1_INT_START		void _ISR _T3Interrupt(void)
	#define MX_CCP2_INT_START		void _ISR _T2Interrupt(void)

#endif

#ifdef MX_CAL_AVR

	MX_UINT8	mx_servo_dummy;

	#ifdef MX_XMEGA

		#define OCR1AL	TCC1.CCA
		#define OCR1BL	TCC1.CCB
		#define TCCR1A	TCC1.CTRLA
		#define TCCR1B	TCC1.CTRLB
		#define TIMSK1	TCC1.INTCTRLB
		#define TIFR1	TCC1.INTFLAGS
		#define OCF1A	4
		#define OCF1B	5
		#define OCIE1A	0
		#define OCIE1B	2

	#else

		#ifndef TIMSK1
			#ifdef TIMSK
				#define TIMSK1	TIMSK
			#endif
		#endif

		#ifndef TIFR1
			#ifdef TIFR
				#define TIFR1	TIFR
			#endif
		#endif

		#ifndef OCR1AH
			#ifdef OCR1A
				#define OCR1AH	mx_servo_dummy
			#endif
		#endif

		#ifndef OCR1AL
			#ifdef OCR1A
				#define OCR1AL	OCR1A
			#endif
		#endif

		#ifndef OCR1BH
			#ifdef OCR1B
				#define OCR1BH	mx_servo_dummy
			#endif
		#endif

		#ifndef OCR1BL
			#ifdef OCR1B
				#define OCR1BL	TCC1.CCB
			#endif
		#endif

	#endif

	#define MX_SERVO_T1CON		0x01

	#define MX_SERVO_REG_CCPR1H		OCR1AH
	#define MX_SERVO_REG_CCPR1L		OCR1AL
	#define MX_SERVO_REG_CCPR2H		OCR1BH
	#define MX_SERVO_REG_CCPR2L		OCR1BL
	#define MX_SERVO_REG_T1CON		mx_servo_dummy
	#define MX_SERVO_REG_CCP1CON	TCCR1A
	#define MX_SERVO_REG_CCP2CON 	TCCR1B
	#define MX_SERVO_REG_CCP1EN		TIMSK1
	#define MX_SERVO_REG_CCP2EN		TIMSK1
	#define MX_SERVO_FLAG_CCP1EN	OCIE1A
	#define MX_SERVO_FLAG_CCP2EN	OCIE1B
	#define MX_SERVO_REG_CCP1F		TIFR1
	#define MX_SERVO_REG_CCP2F		TIFR1
	#define MX_SERVO_FLAG_CCP1F		OCF1A
	#define MX_SERVO_FLAG_CCP2F		OCF1B
	#define MX_SERVO_REG_INT		mx_servo_dummy
	#define MX_SERVO_FLAG_GLOB		0
	#define MX_SERVO_FLAG_PERIPH	0

	#define MX_SERVO_CCP1CON	0x00
	#define MX_SERVO_CCP2CON	0x09	//CTC mode with PWM prescale / 8

	#define MX_CCP1_INT_START		ISR(TIMER1_COMPA_vect)
	#define MX_CCP2_INT_START		ISR(TIMER1_COMPB_vect)

#endif

#ifdef MX_CAL_ARD

	MX_UINT8	mx_servo_dummy;

	#ifdef MX_XMEGA

		#define OCR1AL	TCC1.CCA
		#define OCR1BL	TCC1.CCB
		#define TCCR1A	TCC1.CTRLA
		#define TCCR1B	TCC1.CTRLB
		#define TIMSK1	TCC1.INTCTRLB
		#define TIFR1	TCC1.INTFLAGS
		#define OCF1A	4
		#define OCF1B	5
		#define OCIE1A	0
		#define OCIE1B	2

	#else

		#ifndef TIMSK1
			#ifdef TIMSK
				#define TIMSK1	TIMSK
			#endif
		#endif

		#ifndef TIFR1
			#ifdef TIFR
				#define TIFR1	TIFR
			#endif
		#endif

		#ifndef OCR1AH
			#ifdef OCR1A
				#define OCR1AH	mx_servo_dummy
			#endif
		#endif

		#ifndef OCR1AL
			#ifdef OCR1A
				#define OCR1AL	OCR1A
			#endif
		#endif

		#ifndef OCR1BH
			#ifdef OCR1B
				#define OCR1BH	mx_servo_dummy
			#endif
		#endif

		#ifndef OCR1BL
			#ifdef OCR1B
				#define OCR1BL	TCC1.CCB
			#endif
		#endif

	#endif

	#define MX_SERVO_T1CON		0x01

	#define MX_SERVO_REG_CCPR1H		OCR1AH
	#define MX_SERVO_REG_CCPR1L		OCR1AL
	#define MX_SERVO_REG_CCPR2H		OCR1BH
	#define MX_SERVO_REG_CCPR2L		OCR1BL
	#define MX_SERVO_REG_T1CON		mx_servo_dummy
	#define MX_SERVO_REG_CCP1CON	TCCR1A
	#define MX_SERVO_REG_CCP2CON 	TCCR1B
	#define MX_SERVO_REG_CCP1EN		TIMSK1
	#define MX_SERVO_REG_CCP2EN		TIMSK1
	#define MX_SERVO_FLAG_CCP1EN	OCIE1A
	#define MX_SERVO_FLAG_CCP2EN	OCIE1B
	#define MX_SERVO_REG_CCP1F		TIFR1
	#define MX_SERVO_REG_CCP2F		TIFR1
	#define MX_SERVO_FLAG_CCP1F		OCF1A
	#define MX_SERVO_FLAG_CCP2F		OCF1B
	#define MX_SERVO_REG_INT		mx_servo_dummy
	#define MX_SERVO_FLAG_GLOB		0
	#define MX_SERVO_FLAG_PERIPH	0

	#define MX_SERVO_CCP1CON	0x00
	#define MX_SERVO_CCP2CON	0x09	//CTC mode with PWM prescale / 8

	#define MX_CCP1_INT_START		ISR(TIMER1_COMPA_vect)
	#define MX_CCP2_INT_START		ISR(TIMER1_COMPB_vect)

#endif

#if defined MX_CAL_STARM

	#define TIM_SERVO_INSTANCE				TIM3
	#define TIM_SERVO_IRQHandler			TIM3_IRQHandler
	#define MX_ISR_TIM_SERVO				MX_ISR_TIM3
	#define __HAL_RCC_TIM_SERVO_CLK_ENABLE	__HAL_RCC_TIM3_CLK_ENABLE
	#define TIM_SERVO_IRQn					TIM3_IRQn

	TIM_HandleTypeDef		MX_HANDLE_TIM_SERVO;
	TIM_OC_InitTypeDef		MX_CONFIG_OC_SERVO;

	#define MX_CCP1_INT_START \
		void TIM_SERVO_IRQHandler(void) \
		{ \
			HAL_TIM_IRQHandler(&(MX_HANDLE_TIM_SERVO)); \
		} \
		void MX_ISR_TIM_SERVO()

	#define MX_CCP2_INT_START		void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)

#elif defined MX_CAL_ARM

	MX_UINT8	mx_servo_dummy;

	#define MX_SERVO_REG_CCP1F		mx_servo_dummy
	#define MX_SERVO_REG_CCP2F		mx_servo_dummy
	#define MX_SERVO_FLAG_CCP1F		0
	#define MX_SERVO_FLAG_CCP2F		1

	#define MX_CCP1_INT_START		if ((periphID == AT91C_ID_TC2) && (IFlags & AT91C_TC_CPCS))
	#define MX_CCP2_INT_START		if ((periphID == AT91C_ID_TC2) && (IFlags & AT91C_TC_CPAS))

#endif
#define FCVsz_0dd21_Servo_Controller1__SERVO_POSITION 8
#define FCVsz_0dd21_Servo_Controller1__SERVO_TRIM 8
#define FCVsz_0dd21_Servo_Controller1__SERVO_REQUIRED 8
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__SERVO_ENABLED = (0x0);
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__AUTOMOVING = (0x0);
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__SERVO_IDX = (0x0);
MX_GLOBAL MX_UINT16 FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCVsz_0dd21_Servo_Controller1__SERVO_POSITION];
MX_GLOBAL MX_SINT16 FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCVsz_0dd21_Servo_Controller1__SERVO_TRIM];
MX_GLOBAL MX_UINT16 FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCVsz_0dd21_Servo_Controller1__SERVO_REQUIRED];
MX_GLOBAL MX_UINT16 FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = (0x1);

void FCD_0dd21_Servo_Controller1__DisableServo(MX_UINT8 FCL_CHANNEL);
void FCD_0dd21_Servo_Controller1__SetPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION);
MX_UINT8 FCD_0dd21_Servo_Controller1__MoveToPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION);
void FCD_0dd21_Servo_Controller1__SetPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION);
MX_UINT8 FCD_0dd21_Servo_Controller1__MoveToPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION);
void FCD_0dd21_Servo_Controller1__SetTrim(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_TRIM);
MX_UINT8 FCD_0dd21_Servo_Controller1__IsAutoMoving();
void FCD_0dd21_Servo_Controller1__SetAutoMoveSpeedInt(MX_UINT16 FCL_SPEED);
MX_UINT8 FCD_0dd21_Servo_Controller1__IsServoAutoMoving(MX_UINT8 FCL_CHANNEL);
void FCD_0dd21_Servo_Controller1__AutoMoveToPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION);
void FCD_0dd21_Servo_Controller1__EnableServo(MX_UINT8 FCL_CHANNEL);
void FCD_0dd21_Servo_Controller1__SetAutoMoveSpeed(MX_UINT8 FCL_SPEED);
void FCD_0dd21_Servo_Controller1__AutoMoveToPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION);
void FCD_0dd21_Servo_Controller1__Initialise();

/*========================================================================*\
   Use :TimeStamp1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_spi1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_SPI_SS_TRIS_1 trisc
#define MX_SPI_MISO_PORT_1 portc
#define MX_SPI_SCK_TRIS_1 trisc
#define MX_SPI_SCK_PIN_1 (3)
#define MX_SPI_MOSI_TRIS_1 trisc
#define MX_SPI_BMODE_1 (1)
#define MX_SPI_MISO_TRIS_1 trisc
#define MX_SPI_MOSI_PIN_1 (5)
#define MX_SPI_MISO_PIN_1 (4)
#define MX_SPI_SS_PIN_1 (2)
#define MX_SPI_PR_SCALE_1 (4)
#define MX_SPI_SS_PORT_1 portc
#define MX_SPI_USESS_1 0
#define MX_SPI_SCK_PORT_1 portc
#define MX_SPI_MOSI_PORT_1 portc
#define MX_SPI_CHANNEL_1 (0)


/*=----------------------------------------------------------------------=*\
   Use :cal_spi1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_SPI_REF1

MX_GLOBAL MX_UINT32 FCV_01531_cal_spi1__CONSOLELOG;

void FCD_01531_cal_spi1__Master_Enable_CS();
void FC_CAL_SPI_Slave_Uninit_1();
void FCD_01531_cal_spi1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_COLOUR, MX_UINT8 FCL_APPENDTIMESTAMP);
MX_UINT8 FC_CAL_SPI_Transaction_1(MX_UINT8 *FCL_BUFFER, MX_UINT16 FCLsz_BUFFER, MX_UINT16 FCL_LENGTH);
void FCD_01531_cal_spi1__Prv_SimShowWaveform(MX_UINT8 FCL_RXDATA, MX_UINT16 FCL_TXDATA);
void FC_CAL_SPI_Slave_Init_1();
void FCD_01531_cal_spi1__Master_Disable_CS();
void FC_CAL_SPI_Master_Uninit_1();
MX_UINT8 FC_CAL_SPI_Master_Byte_1(MX_UINT8 FCL_DATAOUT);
void FC_CAL_SPI_Slave_TxByte_1(MX_UINT8 FCL_DATA);
MX_UINT8 FC_CAL_SPI_Slave_RxByte_1();
void FC_CAL_SPI_SetPrescaler_1(MX_UINT8 FCL_PRESCALER);
MX_UINT8 FC_CAL_SPI_Master_Init_1();

/*========================================================================*\
   Use :ASCIIData
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_ASCIIData__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCIIData__INTLIST 475
#define FCVsz_00fb1_ASCIIData__FLOATLIST 1
#define FCVsz_00fb1_ASCIIData__INTFIXEDLIST 1
#define FCD_00fb1_ASCIIData__INTLIST(ix) FCD_00fb1_ASCIIData__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCIIData__INTLIST_LUT ROMARRAY_E =
{
// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8, 0, 224, 96, 0, 0,
 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16, 8, 4, 2, 62,
 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73, 73, 70, 34, 73,
 73, 73, 54, 24, 20, 18, 127, 16, 39, 69, 69, 69, 57, 60, 74, 73,
 73, 48, 1, 113, 9, 5, 3, 54, 73, 73, 73, 54, 6, 73, 73, 41,
 30, 0, 108, 108, 0, 0, 0, 236, 108, 0, 0, 8, 20, 34, 65, 0,
 36, 36, 36, 36, 36, 0, 65, 34, 20, 8, 2, 1, 89, 9, 6, 62,
 65, 93, 85, 30, 126, 9, 9, 9, 126, 127, 73, 73, 73, 54, 62, 65,
 65, 65, 34, 127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9,
 9, 1, 62, 65, 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65,
 0, 48, 64, 64, 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64,
 127, 2, 4, 2, 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62, 127,
 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0, 2, 4, 8, 16, 32,
 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128, 128, 128, 128, 0,
 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68, 68, 56, 56, 68,
 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84, 24, 8, 126, 9,
 9, 0, 24, 164, 164, 164, 124, 127, 4, 4, 120, 0, 0, 0, 125, 0,
 0, 64, 128, 132, 125, 0, 127, 16, 40, 68, 0, 0, 0, 127, 64, 0,
 124, 4, 24, 4, 120, 124, 4, 4, 120, 0, 56, 68, 68, 68, 56, 252,
 68, 68, 68, 56, 56, 68, 68, 68, 252, 68, 120, 68, 4, 8, 8, 84,
 84, 84, 32, 4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64,
 32, 28, 60, 96, 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60,
 0, 100, 84, 84, 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0,
 0, 65, 65, 62, 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};

MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount();

/*========================================================================*\
   Use :Base_GLCD
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);

/*========================================================================*\
   Use :gLCD_ILI9341_SPI1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION = (0x0);

void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOn();
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(MX_UINT8 FCL_DATA);
void FCD_0a2b1_gLCD_ILI9341_SPI1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(MX_UINT8 FCL_DATA);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0a2b1_gLCD_ILI9341_SPI1__FastPlot();
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOff();
void FCD_0a2b1_gLCD_ILI9341_SPI1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0a2b1_gLCD_ILI9341_SPI1__ClearDisplay();
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Initialise();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\includes.c"


/*========================================================================*\
   Use :auto_labels1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05268_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 7))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05268_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 7);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05268_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 7);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target8
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05267_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 6))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05267_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 6);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05267_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 6);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target7
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05266_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 5))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05266_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 5);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05266_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 5);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target6
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05265_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 4))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05265_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 4);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05265_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 4);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target5
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05264_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 3))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05264_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 3);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05264_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 3);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target4
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05263_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 2))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05263_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 2);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05263_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 2);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target3
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05262_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 1))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05262_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 1);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05262_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 1);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05261_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(B, 0))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05261_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 0);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05261_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(B, 0);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :default_target1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :servo_base
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN7
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN6
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN5
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN4
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN3
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :EN0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :shape_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :shape_cuboid1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S7
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S6
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S5
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S4
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S3
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :S0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :Servo_Controller1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Disables a servo channel effectivly disabling the motor.
       :
       :Parameters for macro DisableServo:
       :  Channel : The channel to set the position for.  First channel is zero.
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__DisableServo(MX_UINT8 FCL_CHANNEL)
{
	//Local variable definitions
	MX_UINT8 FCL_DUMMY;


	switch (FCL_CHANNEL)
	{
		case 1:
		{
			#if (1) // 8 > 1

				// .Dummy = pin1
				FCL_DUMMY = GET_PORT_PIN(D, 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 2:
		{
			#if (1) // 8 > 2

				// .Dummy = pin2
				FCL_DUMMY = GET_PORT_PIN(D, 2);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 3:
		{
			#if (1) // 8 > 3

				// .Dummy = pin3
				FCL_DUMMY = GET_PORT_PIN(D, 3);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 4:
		{
			#if (1) // 8 > 4

				// .Dummy = pin4
				FCL_DUMMY = GET_PORT_PIN(D, 4);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 5:
		{
			#if (1) // 8 > 5

				// .Dummy = pin5
				FCL_DUMMY = GET_PORT_PIN(D, 5);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 6:
		{
			#if (1) // 8 > 6

				// .Dummy = pin6
				FCL_DUMMY = GET_PORT_PIN(D, 6);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 7:
		{
			#if (1) // 8 > 7

				// .Dummy = pin7
				FCL_DUMMY = GET_PORT_PIN(D, 7);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		default:
		{
			// .Dummy = pin0
			FCL_DUMMY = GET_PORT_PIN(D, 0);

		}
	}

	if (FCL_CHANNEL < 8)
	{

		// Servo_Enabled = Servo_Enabled & ~ (0x01 << .Channel)
		FCV_0dd21_Servo_Controller1__SERVO_ENABLED = FCV_0dd21_Servo_Controller1__SERVO_ENABLED & ~(0x01 << FCL_CHANNEL);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves directly to the specified position with no interpolation.
       :
       :Parameters for macro SetPosition:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to jump to. Range: 0-255
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION)
{

	if (FCL_CHANNEL < 8)
	{

		// Servo_Position[.Channel] = .Position * Servo_Period_Multiplier
		// Servo_Required[.Channel] = .Position * Servo_Period_Multiplier
		FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCL_POSITION * 19;
		FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCL_POSITION * 19;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves a single step towards the new position, the rate of movement is determined by how often the move to macro is called. 
       :Returns 1 if the position has been reached.
       :
       :Parameters for macro MoveToPositionInt:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Target position to move towards. Range: 0-65535
       :
       :Returns : 1 = reached target, 0 = target not reached.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__MoveToPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION)
{
	//Local variable definitions
	MX_UINT16 FCL_POS;
	MX_UINT8 FCR_RETVAL; // 1 = reached target, 0 = target not reached.


	// .Return = 1
	FCR_RETVAL = 1;

	// .Pos = .Position * IntScaler
	FCL_POS = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.075059));

	if (FCL_CHANNEL < 8)
	{

		if (FCL_POS != FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
		{

			// .Return = 0
			FCR_RETVAL = 0;

			if (FCL_POS > FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
			{

				// Servo_Position[.Channel] = Servo_Position[.Channel] + 1
				FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] + 1;

			} else {

				// Servo_Position[.Channel] = Servo_Position[.Channel] - 1
				FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] - 1;

			}

			// Servo_Required[.Channel] = Servo_Position[.Channel]
			FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL];

		// } else {

		}

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Moves directly to the specified position with no interpolation.
       :Uses a 16-bit position parameter to add extra precision.
       :
       :Parameters for macro SetPositionInt:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to jump to. Range: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION)
{

	if (FCL_CHANNEL < 8)
	{

		// Servo_Position[.Channel] = .Position * IntScaler
		// Servo_Required[.Channel] = .Position * IntScaler
		FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.075059));
		FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.075059));

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves a single step towards the new position, the rate of movement is determined by how often the move to macro is called. 
       :Returns 1 if the position has been reached.
       :
       :Parameters for macro MoveToPosition:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Target position to move towards. Range: 0-255
       :
       :Returns : 1 = reached target, 0 = target not reached.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__MoveToPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION)
{
	//Local variable definitions
	MX_UINT16 FCL_POS;
	MX_UINT8 FCR_RETVAL; // 1 = reached target, 0 = target not reached.


	// .Return = 1
	FCR_RETVAL = 1;

	// .Pos = .Position * Servo_Period_Multiplier
	FCL_POS = FCL_POSITION * 19;

	if (FCL_CHANNEL < 8)
	{

		if (FCL_POS != FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
		{

			// .Return = 0
			FCR_RETVAL = 0;

			if (FCL_POS > FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
			{

				if (FCL_POS > (FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] + 19))
				{

					// Servo_Position[.Channel] = Servo_Position[.Channel] + Servo_Period_Multiplier
					FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] + 19;

				} else {

					// Servo_Position[.Channel] = .Pos
					FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCL_POS;

				}

			} else {

				if (FCL_POS < (FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] - 19))
				{

					// Servo_Position[.Channel] = Servo_Position[.Channel] - Servo_Period_Multiplier
					FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] - 19;

				} else {

					// Servo_Position[.Channel] = .Pos
					FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCL_POS;

				}

			}

			// Servo_Required[.Channel] = Servo_Position[.Channel]
			FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL];

		// } else {

		}

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows the level of trim for each servo channel to be adjusted progmatically.
       :
       :Parameters for macro SetTrim:
       :  Channel : The channel to set the position for.  First channel is zero.
       :  Trim : Legacy: 0=0us, 1=+25us, 2=+50us, 3=+75us, 4=+100us, 5=-25us, 6=-50us, 7=-75us, 8=-100us or Smooth: 0-200
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetTrim(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_TRIM)
{
	//Local variable definitions
	MX_SINT16 FCL_TCALC;


	#if (1)

		if (FCL_CHANNEL < 8)
		{

			if (FCL_TRIM < 200)
			{

				// .tcalc = .Trim - 100
				FCL_TCALC = FCL_TRIM - 100;

				// Servo_Trim[.Channel] = .tcalc * (Servo_Clock_Count_25 / 50)
				FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCL_CHANNEL] = FCL_TCALC * (122 / 50);

			// } else {

			}

		// } else {

		}

	#else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Is the AutoMoveToPosition movement complete.
       : 
       :Returns 1 if the servos are still moving.
       :
       :Returns 0 if all servo movement is complete.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__IsAutoMoving()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	if (FCV_0dd21_Servo_Controller1__AUTOMOVING > 0)
	{

		// .Return = 1
		FCR_RETVAL = 1;

	} else {

		// .Return = 0
		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the speed of the auto move to position macro.
       :
       :Default speed is shown in the Servo_Period_Multiplier property.
       :
       :Parameters for macro SetAutoMoveSpeedInt:
       :  Speed : 1=Slowest (Default), 2= Double, 3=Triple, 4=Quadruple
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetAutoMoveSpeedInt(MX_UINT16 FCL_SPEED)
{

	if (FCL_SPEED < 1)
	{

		// .Speed = 1
		FCL_SPEED = 1;

	} else {

		if (FCL_SPEED > 65500)
		{

			// .Speed = 65500
			FCL_SPEED = 65500;

		// } else {

		}

	}

	// AutoMoveSpeed = .Speed * Servo_Period_Multiplier
	FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = FCL_SPEED * 19;

}

/*=----------------------------------------------------------------------=*\
   Use :Is the AutoMoveToPosition movement complete for a specific servo output.
       :
       :Returns 1 if the servo is still moving.
       : 
       :Returns 0 if the servo movement is complete.
       :
       :Parameters for macro IsServoAutoMoving:
       :  Channel : Servo Motor Output Range: 0-7
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__IsServoAutoMoving(MX_UINT8 FCL_CHANNEL)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	if (FCV_0dd21_Servo_Controller1__AUTOMOVING & (1 << FCL_CHANNEL))
	{

		// .Return = 1
		FCR_RETVAL = 1;

	} else {

		// .Return = 0
		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Automatically moves towards the new position at a fixed rate determined by the AutoMoveSpeed.
       :
       :Parameters for macro AutoMoveToPosition:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to automatically move to. Range: 0-255
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__AutoMoveToPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION)
{

	if (FCL_CHANNEL < 8)
	{

		if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (1 << FCL_CHANNEL))
		{

			// Servo_Required[.Channel] = .Position * Servo_Period_Multiplier
			FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCL_POSITION * 19;

			// AutoMoving = AutoMoving | (1 << .Channel)
			FCV_0dd21_Servo_Controller1__AUTOMOVING = FCV_0dd21_Servo_Controller1__AUTOMOVING | (1 << FCL_CHANNEL);

		// } else {

		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Enables a servo channel effectivly setting the position of the motor to the value in the local position variable.
       :
       :Parameters for macro EnableServo:
       :  Channel : The channel to set the position for.  First channel is zero.
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__EnableServo(MX_UINT8 FCL_CHANNEL)
{
	//Local variable definitions
	MX_UINT8 FCL_DUMMY;


	switch (FCL_CHANNEL)
	{
		case 1:
		{
			#if (1) // 8 > 1

				// pin1 = 0
				SET_PORT_PIN(D, 1, 0);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 2:
		{
			#if (1) // 8 > 2

				// pin2 = 0
				SET_PORT_PIN(D, 2, 0);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 3:
		{
			#if (1) // 8 > 3

				// pin3 = 0
				SET_PORT_PIN(D, 3, 0);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 4:
		{
			#if (1) // 8 > 4

				// pin4 = 0
				SET_PORT_PIN(D, 4, 0);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 5:
		{
			#if (1) // 8 > 5

				// pin5 = 0
				SET_PORT_PIN(D, 5, 0);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 6:
		{
			#if (1) // 8 > 6

				// pin6 = 0
				SET_PORT_PIN(D, 6, 0);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 7:
		{
			#if (1) // 8 > 7

				// pin7 = 0
				SET_PORT_PIN(D, 7, 0);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		default:
		{
			// pin0 = 0
			SET_PORT_PIN(D, 0, 0);

		}
	}

	if (FCL_CHANNEL < 8)
	{

		// Servo_Enabled = Servo_Enabled | (0x01 << .Channel)
		FCV_0dd21_Servo_Controller1__SERVO_ENABLED = FCV_0dd21_Servo_Controller1__SERVO_ENABLED | (0x01 << FCL_CHANNEL);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the speed of the auto move to position macro.
       :
       :Default speed is shown in the Servo_Period_Multiplier property.
       :
       :Parameters for macro SetAutoMoveSpeed:
       :  Speed : 1=Slowest (Default), 2= Double, 3=Triple, 4=Quadruple
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetAutoMoveSpeed(MX_UINT8 FCL_SPEED)
{

	if (FCL_SPEED < 1)
	{

		// .Speed = 1
		FCL_SPEED = 1;

	} else {

		if (FCL_SPEED > 250)
		{

			// .Speed = 250
			FCL_SPEED = 250;

		// } else {

		}

	}

	// AutoMoveSpeed = .Speed * Servo_Period_Multiplier
	FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = FCL_SPEED * 19;

}

/*=----------------------------------------------------------------------=*\
   Use :Automatically moves towards the new 16-bit position at a fixed rate determined by the AutoMoveSpeed.
       :
       :Parameters for macro AutoMoveToPositionInt:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to automatically move to. Range: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__AutoMoveToPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION)
{

	if (FCL_CHANNEL < 8)
	{

		if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (1 << FCL_CHANNEL))
		{

			// Servo_Required[.Channel] = .Position * IntScaler
			FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.075059));

			// AutoMoving = AutoMoving | (1 << .Channel)
			FCV_0dd21_Servo_Controller1__AUTOMOVING = FCV_0dd21_Servo_Controller1__AUTOMOVING | (1 << FCL_CHANNEL);

		// } else {

		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sets up the servo motor interrupts
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__Initialise()
{

	// AutoMoveSpeed = Servo_Period_Multiplier
	FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = 19;

	// Servo_Idx = 0
	FCV_0dd21_Servo_Controller1__SERVO_IDX = 0;

	while (FCV_0dd21_Servo_Controller1__SERVO_IDX < 8)
	{

		// Servo_Position[Servo_Idx] = 128 * Servo_Period_Multiplier
		// Servo_Required[Servo_Idx] = 128 * Servo_Period_Multiplier
		// Servo_Trim[Servo_Idx] = 0
		FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = 128 * 19;
		FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] = 128 * 19;
		FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCV_0dd21_Servo_Controller1__SERVO_IDX] = 0;

		// Servo_Idx = Servo_Idx + 1
		FCV_0dd21_Servo_Controller1__SERVO_IDX = FCV_0dd21_Servo_Controller1__SERVO_IDX + 1;


	}









	// Servo_Idx = 0
	FCV_0dd21_Servo_Controller1__SERVO_IDX = 0;

	//Comment:
	//Calculate Trim timings

	#if (1) // 8 > 0

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 8 > 1

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 8 > 2

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 8 > 3

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 8 > 4

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 8 > 5

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 8 > 6

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 8 > 7

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if defined MX_CAL_STARM

		MX_UINT32 TIM_SERVO_CLOCK_FREQ;
		RCC_ClkInitTypeDef TIM_SERVO_CLOCK_CONF;
		uint32_t Flatency;
		HAL_RCC_GetClockConfig(&TIM_SERVO_CLOCK_CONF, &Flatency);
		if (TIM_SERVO_CLOCK_CONF.APB1CLKDivider == RCC_HCLK_DIV1)
			TIM_SERVO_CLOCK_FREQ = HAL_RCC_GetPCLK1Freq();
		else
			TIM_SERVO_CLOCK_FREQ = HAL_RCC_GetPCLK1Freq() * 2;
		#define TIM_SERVO_PRESCALER ((TIM_SERVO_CLOCK_FREQ/1000000)-1)

		MX_HANDLE_TIM_SERVO.Instance = TIM_SERVO_INSTANCE;
		MX_HANDLE_TIM_SERVO.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
		MX_HANDLE_TIM_SERVO.Init.CounterMode = TIM_COUNTERMODE_UP;
		MX_HANDLE_TIM_SERVO.Init.RepetitionCounter = 0;
		MX_HANDLE_TIM_SERVO.Init.Prescaler = TIM_SERVO_PRESCALER;
		MX_HANDLE_TIM_SERVO.Init.Period = 3000;	// 3mS interval = 24mS repeat

		__HAL_RCC_TIM_SERVO_CLK_ENABLE();
		HAL_NVIC_SetPriority(TIM_SERVO_IRQn, 3, 0);
		HAL_TIM_Base_Init(&(MX_HANDLE_TIM_SERVO));

		TIM_ClockConfigTypeDef MX_CONFIG_CLK_SERVO;
		MX_CONFIG_CLK_SERVO.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
		MX_CONFIG_CLK_SERVO.ClockPolarity = TIM_CLOCKPOLARITY_RISING;
		MX_CONFIG_CLK_SERVO.ClockPrescaler = TIM_CLOCKPRESCALER_DIV1;
		MX_CONFIG_CLK_SERVO.ClockFilter = 0;
		HAL_TIM_ConfigClockSource(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_CLK_SERVO);

		HAL_TIM_OC_Init(&MX_HANDLE_TIM_SERVO);

		TIM_MasterConfigTypeDef MX_CONFIG_MASTER_SERVO;
		MX_CONFIG_MASTER_SERVO.MasterOutputTrigger = TIM_TRGO_RESET;
		MX_CONFIG_MASTER_SERVO.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
		HAL_TIMEx_MasterConfigSynchronization(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_MASTER_SERVO);

		MX_CONFIG_OC_SERVO.OCMode = TIM_OCMODE_TIMING;
		MX_CONFIG_OC_SERVO.Pulse = 1500;
		MX_CONFIG_OC_SERVO.OCPolarity = TIM_OCPOLARITY_HIGH;
		HAL_TIM_OC_ConfigChannel(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_OC_SERVO, TIM_CHANNEL_1);


		HAL_NVIC_EnableIRQ(TIM_SERVO_IRQn);
		HAL_TIM_Base_Start_IT(&(MX_HANDLE_TIM_SERVO));
		HAL_TIM_OC_Start_IT(&MX_HANDLE_TIM_SERVO, TIM_CHANNEL_1);


	#elif defined MX_CAL_ARM

		AT91F_TC2_CfgPMC();
		AT91C_BASE_TC2->TC_CMR = (AT91C_TC_WAVE | AT91C_TC_CPCTRG | AT91C_TC_CLKS_TIMER_DIV2_CLOCK);
		AT91C_BASE_TC2->TC_CCR = (AT91C_TC_SWTRG | AT91C_TC_CLKEN);
		AT91C_BASE_TC2->TC_RC = MX_SERVO_PERIOD;
		AT91C_BASE_TC2->TC_CMR |= AT91C_TC_CLKI;
		AT91C_BASE_TC2->TC_IER = AT91C_TC_CPCS;
		AT91C_BASE_TC2->TC_IER = AT91C_TC_CPAS;

	#else

		#ifdef MX_CAL_PIC16

			PR3 = (MX_SERVO_CCPR1H << 8) | MX_SERVO_CCPR1L;

			//#if (MX_CLKS_PER_INST == 2)
			//	PR3 = PR3 * 2;
			//#endif

			T2CON = 0;				//Stop TMR2
			IFS0bits.T2IF = 0;		//Clear interrupt
			IEC0bits.T2IE = 1;		//Enable TMR2 interrupts

			T3CON = 0;				//Stop TMR3
			IFS0bits.T3IF = 0;		//Clear interrupt

			TMR3 = 0;				//Clear TMR3
			IEC0bits.T3IE = 1;		//Enable TMR3 interrupts
			T3CON = 0x8000;			//Start TMR3

		#else

			MX_SERVO_REG_CCPR1H = MX_SERVO_CCPR1H;					//Set capture compare setpoint
			MX_SERVO_REG_CCPR1L = MX_SERVO_CCPR1L;
			MX_SERVO_REG_T1CON = MX_SERVO_T1CON;					//Setup timer and start running

	        #ifdef MX_SERVO_T1_CLK
	            T1CLK = MX_SERVO_T1_CLK;
	        #endif

			MX_SERVO_REG_CCP1CON = MX_SERVO_CCP1CON;				//Configure CCP1 settings
			st_bit(MX_SERVO_REG_CCP1EN, MX_SERVO_FLAG_CCP1EN);		//Enable CCP1 interrupt
			MX_SERVO_REG_CCP2CON = MX_SERVO_CCP2CON;				//Configure CCP2 settings

			st_bit(MX_SERVO_REG_CCP2EN, MX_SERVO_FLAG_CCP2EN);		//Enable CCP2 interrupt
			st_bit(MX_SERVO_REG_INT, MX_SERVO_FLAG_PERIPH);			//Enable Interrupts
			st_bit(MX_SERVO_REG_INT, MX_SERVO_FLAG_GLOB);

			#ifdef MX_CAL_AVR
				sei();
			#endif
			#ifdef MX_CAL_ARD
				sei();
			#endif
		#endif
	#endif

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}


/*========================================================================*\
   Use :TimeStamp1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_spi1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Outputs a low signal to the chip select pin to select the remote slave device.
\*=----------------------------------------------------------------------=*/
void FCD_01531_cal_spi1__Master_Enable_CS()
{
	//Local variable definitions
#define FCLsz_STR 20
	MX_CHAR FCL_STR[FCLsz_STR];


	#if (1)

		#if (1) // 0 == 0

			#if (0)

			//Code has been optimised out by the pre-processor
			// #else

			#endif

		// #else

		//Code has been optimised out by the pre-processor
		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	//Local variable definitions
#undef FCLsz_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Send text to the SPI console.
       :Exposed as part of the CAL_SPI component to allow none AutoCS pins and other.
       :
       :Parameters for macro Prv_TextConsole:
       :  str[20] : MX_CHAR (by-ref)
       :  Colour : 0=Default, 1=TX, 2=RX
       :  AppendTimestamp : 0=Don't Append / 1=Do Append
\*=----------------------------------------------------------------------=*/
void FCD_01531_cal_spi1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_COLOUR, MX_UINT8 FCL_APPENDTIMESTAMP)
{
	//Local variable definitions
#define FCLsz_TSTR 20
	MX_CHAR FCL_TSTR[FCLsz_TSTR];


	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	//Local variable definitions
#undef FCLsz_TSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_SimShowWaveform:
       :  RXData : MX_UINT8
       :  TXData : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_01531_cal_spi1__Prv_SimShowWaveform(MX_UINT8 FCL_RXDATA, MX_UINT16 FCL_TXDATA)
{

	#if (1)

		for (FCLV_LOOP1=0; (FCLV_LOOP1)<(8); (FCLV_LOOP1)++)
		{

			#if (1) // (1 & 0x02) == 0

				#if (0) // (1 & 0x01) == 0

				//Code has been optimised out by the pre-processor
				#else

					// CLK = 0
					SET_PORT_PIN(C, 3, 0);

				#endif

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			if (FCL_TXDATA & 0x80)
			{

				// MOSI = 1
				SET_PORT_PIN(C, 5, 1);

			} else {

				// MOSI = 0
				SET_PORT_PIN(C, 5, 0);

			}

			#if (1) // (1 & 0x04) == 0

				if (FCL_RXDATA & 0x80)
				{

					// MISO = 1
					SET_PORT_PIN(C, 4, 1);

				} else {

					// MISO = 0
					SET_PORT_PIN(C, 4, 0);

				}

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			FCI_DELAYBYTE_US(0);

			#if (0) // (1 & 0x02) == 2

			//Code has been optimised out by the pre-processor
			#else

				#if (0) // (1 & 0x01) == 0

				//Code has been optimised out by the pre-processor
				#else

					// CLK = 1
					SET_PORT_PIN(C, 3, 1);

				#endif

			#endif

			#if (0) // (1 & 0x04) == 4

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			FCI_DELAYBYTE_US(0);

			#if (0) // (1 & 0x02) == 2

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .TXData = .TXData << 1
			// .RXData = .RXData << 1
			FCL_TXDATA = FCL_TXDATA << 1;
			FCL_RXDATA = FCL_RXDATA << 1;


		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Outputs a high signal to the chip select pin to deselect the remote slave device.
\*=----------------------------------------------------------------------=*/
void FCD_01531_cal_spi1__Master_Disable_CS()
{
	//Local variable definitions
#define FCLsz_STR 20
	MX_CHAR FCL_STR[FCLsz_STR];


	#if (1)

		#if (1) // 0 == 0

			#if (0)

			//Code has been optimised out by the pre-processor
			// #else

			#endif

		// #else

		//Code has been optimised out by the pre-processor
		#endif

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	//Local variable definitions
#undef FCLsz_STR
}


/*========================================================================*\
   Use :ASCIIData
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	// .Return = NumVals
	FCR_RETVAL = 475;

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :Base_GLCD
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Local variable definitions
	MX_UINT16 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		if (FCL_POS_STR > 94)
		{

			// .Return = 0xaa
			FCR_RETVAL = 0xaa;

		} else {

			// .position = (.pos_str * 5) + .count
			FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

			FCR_RETVAL = FCD_00fb1_ASCIIData__INTLIST(FCL_POSITION);

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_ILI9341_SPI1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the backlight enable pin allowing the display backlight to switch on.
       :Switching the backlight on and off at high speed allow the light to be dimmed.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOn()
{

	#if (1)

		// led_pin = 1
		SET_PORT_PIN(C, 6, 1);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro LCD_Write_Reg:
       :  data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(MX_UINT8 FCL_DATA)
{

	// dc_pin = 0
	SET_PORT_PIN(C, 1, 0);

	FC_CAL_SPI_Master_Byte_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Parameters for macro PrintNumber:
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Range: 0 to 31 - 0=5x8, 1=10x8, 2=10x16, 3=5x16, 4-31=Extended Sizes
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Local variable definitions
#define FCLsz_TEMP 8
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	// .temp = ToString$ (.Number)
	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,8);

	FCD_0a2b1_gLCD_ILI9341_SPI1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Local variable definitions
#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Local variable definitions
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);
	MX_SINT16 FCL_X;
	MX_SINT16 FCL_Y;


	// .PixelX = .X2 - .X1
	// .PixelY = .Y2 - .Y1
	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	// .X = .X1
	// .Y = .Y1
	FCL_X = FCL_X1;
	FCL_Y = FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		// .Xinc = -1
		// .PixelX = .PixelX * -1
		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		// .Yinc = -1
		// .PixelY = .PixelY * -1
		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		// .C1 = 2 * .PixelX
		// .M1 = 2 * .PixelY
		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X != FCL_X2)
		{

			FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X, FCL_Y);

			// .X = .X + .Xinc
			FCL_X = FCL_X + FCL_XINC;

			// .D1 = .D1 + .M1
			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				// .Y = .Y + .Yinc
				FCL_Y = FCL_Y + FCL_YINC;

				// .D1 = .D1 - .C1
				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		// .C1 = 2 * .PixelY
		// .M1 = 2 * .PixelX
		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y != FCL_Y2)
		{

			FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X, FCL_Y);

			// .Y = .Y + .Yinc
			FCL_Y = FCL_Y + FCL_YINC;

			// .D1 = .D1 + .M1
			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				// .X = .X + .Xinc
				FCL_X = FCL_X + FCL_XINC;

				// .D1 = .D1 - .C1
				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X, FCL_Y);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro LCD_Write_Data8:
       :  data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(MX_UINT8 FCL_DATA)
{

	// dc_pin = 1
	SET_PORT_PIN(C, 1, 1);

	FC_CAL_SPI_Master_Byte_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse object on the display with the center of the ellipse at the location X,Y
       :
       :Parameters for macro DrawEllipse:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  XRadius : Radius of the circle on the X axis specified in pixels
       :  YRadius : Radius of the circle on the Y axis specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Local variable definitions
	MX_SINT16 FCL_ERR;
	MX_SINT16 FCL_CURX;
	MX_SINT16 FCL_CURY;
	MX_UINT32 FCL_BGCOL;
	MX_UINT32 FCL_FGCOL;
	MX_UINT8 FCL_REP = (0x0);
	MX_SINT16 FCL_E2;
	MX_FLOAT FCL_K;


	if (FCL_SOLID == 1)
	{

	FCC_DrawEllipse_A:
		;

		// .CurX = 0
		// .CurY = 0 - .YRadius
		FCL_CURX = 0;
		FCL_CURY = 0 - FCL_YRADIUS;

		// .err = 2 - (2 * .XRadius)
		FCL_ERR = 2 - (2 * FCL_XRADIUS);

		// .K = FLOAT (FLOAT .YRadius / FLOAT .XRadius)
		FCL_K = (flt_div(flt_fromi(FCL_YRADIUS), flt_fromi(FCL_XRADIUS)));

		while (1)
		{

			FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY, flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY);

			FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY, flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY);

			// .e2 = .err
			FCL_E2 = FCL_ERR;

			if (FCL_E2 <= FCL_CURX)
			{

				// .CurX = .CurX + 1
				// .err = .err + ((.CurX * 2) + 1)
				FCL_CURX = FCL_CURX + 1;
				FCL_ERR = FCL_ERR + ((FCL_CURX * 2) + 1);

				if ((0 - FCL_CURY == FCL_CURX) && (FCL_E2 <= FCL_CURY))
				{

					// .e2 = 0
					FCL_E2 = 0;

				// } else {

				}

			// } else {

			}

			if (FCL_E2 > FCL_CURY)
			{

				// .CurY = .CurY + 1
				// .err = .err + ((.CurY * 2) + 1)
				FCL_CURY = FCL_CURY + 1;
				FCL_ERR = FCL_ERR + ((FCL_CURY * 2) + 1);

			// } else {

			}


			if ((FCL_CURY <= 0) == 0) break;
		}

	} else {

		if (FCL_TRANSPARENT == 1)
		{

		FCC_DrawEllipse_B:
			;

			// .CurX = 0
			// .CurY = 0 - .YRadius
			FCL_CURX = 0;
			FCL_CURY = 0 - FCL_YRADIUS;

			// .err = 2 - (2 * .XRadius)
			FCL_ERR = 2 - (2 * FCL_XRADIUS);

			// .K = FLOAT (FLOAT .YRadius / FLOAT .XRadius)
			FCL_K = (flt_div(flt_fromi(FCL_YRADIUS), flt_fromi(FCL_XRADIUS)));

			while (1)
			{

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY);

				// .e2 = .err
				FCL_E2 = FCL_ERR;

				if (FCL_E2 <= FCL_CURX)
				{

					// .CurX = .CurX + 1
					// .err = .err + ((.CurX * 2) + 1)
					FCL_CURX = FCL_CURX + 1;
					FCL_ERR = FCL_ERR + ((FCL_CURX * 2) + 1);

					if ((0 - FCL_CURY == FCL_CURX) && (FCL_E2 <= FCL_CURY))
					{

						// .e2 = 0
						FCL_E2 = 0;

					// } else {

					}

				// } else {

				}

				if (FCL_E2 > FCL_CURY)
				{

					// .CurY = .CurY + 1
					// .err = .err + ((.CurY * 2) + 1)
					FCL_CURY = FCL_CURY + 1;
					FCL_ERR = FCL_ERR + ((FCL_CURY * 2) + 1);

				// } else {

				}


				if ((FCL_CURY <= 0) == 0) break;
			}

		} else {

			// .FGCol = foreground_col_var
			// .BGCol = background_col_var
			FCL_FGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR;
			FCL_BGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR;

			// foreground_col_var = .BGCol
			FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_BGCOL;

			// .Rep = 1
			FCL_REP = 1;

			goto FCC_DrawEllipse_A;

		}

	}

	if (FCL_REP == 1)
	{

		// .Rep = .Rep + 1
		FCL_REP = FCL_REP + 1;

		// foreground_col_var = .FGCol
		FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_FGCOL;

		goto FCC_DrawEllipse_B;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Local variable definitions
	MX_UINT16 FCL_TEMP;


	switch (FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION)
	{
		case 1:
		{
			// .temp = pixel_width - (.Y1 + 1)
			// .Y1 = .X1
			// .X1 = .temp
			FCL_TEMP = 240 - (FCL_Y1 + 1);
			FCL_Y1 = FCL_X1;
			FCL_X1 = FCL_TEMP;

			break;
		}
		case 2:
		{
			// .X1 = pixel_width - (.X1 + 1)
			// .Y1 = pixel_height - (.Y1 + 1)
			FCL_X1 = 240 - (FCL_X1 + 1);
			FCL_Y1 = 320 - (FCL_Y1 + 1);

			break;
		}
		case 3:
		{
			// .temp = .Y1
			// .Y1 = pixel_height - (.X1 + 1)
			// .X1 = .temp
			FCL_TEMP = FCL_Y1;
			FCL_Y1 = 320 - (FCL_X1 + 1);
			FCL_X1 = FCL_TEMP;

			break;
		}
		// default:

	}

	FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1, FCL_Y1, FCL_X1, FCL_Y1);

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR);

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at current pixel location.
       :Not compatible with orientations other than 0.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__FastPlot()
{

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR);

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Parameters for macro SetDisplayOrientation:
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	// Orientation = .Orientation
	FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Clears the backlight enable pin allowing the display backlight to switch off.
       :Switching the backlight on and off at high speed allow the light to be dimmed.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOff()
{

	#if (1)

		// led_pin = 0
		SET_PORT_PIN(C, 6, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Local variable definitions
	MX_UINT16 FCL_TEMP;


	switch (FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION)
	{
		case 1:
		{
			// .temp = pixel_width - (.Y1 + 1)
			// .Y1 = .X1
			// .X1 = .temp
			FCL_TEMP = 240 - (FCL_Y1 + 1);
			FCL_Y1 = FCL_X1;
			FCL_X1 = FCL_TEMP;

			break;
		}
		case 2:
		{
			// .X1 = pixel_width - (.X1 + 1)
			// .Y1 = pixel_height - (.Y1 + 1)
			FCL_X1 = 240 - (FCL_X1 + 1);
			FCL_Y1 = 320 - (FCL_Y1 + 1);

			break;
		}
		case 3:
		{
			// .temp = .Y1
			// .Y1 = pixel_height - (.X1 + 1)
			// .X1 = .temp
			FCL_TEMP = FCL_Y1;
			FCL_Y1 = 320 - (FCL_X1 + 1);
			FCL_X1 = FCL_TEMP;

			break;
		}
		// default:

	}

	FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1, FCL_Y1, FCL_X1, FCL_Y1);

	// chip_sel_pin = 0
	SET_PORT_PIN(C, 2, 0);

	FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR);

	// chip_sel_pin = 1
	SET_PORT_PIN(C, 2, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Window:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	//Comment:
	//Set Column Address

	// dc_pin = 0
	SET_PORT_PIN(C, 1, 0);

	FC_CAL_SPI_Master_Byte_1(0x2A);

	// dc_pin = 1
	SET_PORT_PIN(C, 1, 1);

	FC_CAL_SPI_Master_Byte_1(FCL_X1 >> 8);

	FC_CAL_SPI_Master_Byte_1(FCL_X1);

	FC_CAL_SPI_Master_Byte_1(FCL_X2 >> 8);

	FC_CAL_SPI_Master_Byte_1(FCL_X2);

	//Comment:
	//Set Row Address

	// dc_pin = 0
	SET_PORT_PIN(C, 1, 0);

	FC_CAL_SPI_Master_Byte_1(0x2B);

	// dc_pin = 1
	SET_PORT_PIN(C, 1, 1);

	FC_CAL_SPI_Master_Byte_1(FCL_Y1 >> 8);

	FC_CAL_SPI_Master_Byte_1(FCL_Y1);

	FC_CAL_SPI_Master_Byte_1(FCL_Y2 >> 8);

	FC_CAL_SPI_Master_Byte_1(FCL_Y2);

	//Comment:
	//Prep for data

	// dc_pin = 0
	SET_PORT_PIN(C, 1, 0);

	FC_CAL_SPI_Master_Byte_1(0x2C);

	// dc_pin = 1
	SET_PORT_PIN(C, 1, 1);

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Parameters for macro Print:
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Range: 0 to 31 - 0=5x8, 1=10x8, 2=10x16, 3=5x16, 4-31=Extended Sizes
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Local variable definitions
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	MX_UINT8 FCL_POSITION;
#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];
	MX_UINT8 FCL_DAT;


	switch (FCL_FONT)
	{
		case 1:
		{
			// .font_width = 2
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			// .font_width = 2
			// .font_height = 2
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			// .font_height = 2
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 4:
		{
			// .font_width = 2
			// .font_height = 3
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 5:
		{
			// .font_width = 2
			// .font_height = 4
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 6:
		{
			// .font_width = 2
			// .font_height = 5
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 7:
		{
			// .font_width = 2
			// .font_height = 6
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 8:
		{
			// .font_width = 3
			// .font_height = 1
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		case 9:
		{
			// .font_width = 3
			// .font_height = 2
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 10:
		{
			// .font_width = 3
			// .font_height = 3
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		// default:

	}

	switch (FCL_FONT)
	{
		case 11:
		{
			// .font_width = 3
			// .font_height = 4
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 12:
		{
			// .font_width = 3
			// .font_height = 5
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 13:
		{
			// .font_width = 3
			// .font_height = 6
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 14:
		{
			// .font_width = 4
			// .font_height = 1
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		case 15:
		{
			// .font_width = 4
			// .font_height = 2
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 16:
		{
			// .font_width = 4
			// .font_height = 3
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 17:
		{
			// .font_width = 4
			// .font_height = 4
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 18:
		{
			// .font_width = 4
			// .font_height = 5
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 19:
		{
			// .font_width = 4
			// .font_height = 6
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 20:
		{
			// .font_width = 5
			// .font_height = 1
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		// default:

	}

	switch (FCL_FONT)
	{
		case 21:
		{
			// .font_width = 5
			// .font_height = 2
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 22:
		{
			// .font_width = 5
			// .font_height = 3
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 23:
		{
			// .font_width = 5
			// .font_height = 4
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 24:
		{
			// .font_width = 5
			// .font_height = 5
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 25:
		{
			// .font_width = 5
			// .font_height = 6
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 26:
		{
			// .font_width = 6
			// .font_height = 1
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		case 27:
		{
			// .font_width = 6
			// .font_height = 2
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 28:
		{
			// .font_width = 6
			// .font_height = 3
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 29:
		{
			// .font_width = 6
			// .font_height = 4
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 30:
		{
			// .font_width = 6
			// .font_height = 5
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		// default:

	}

	switch (FCL_FONT)
	{
		case 31:
		{
			// .font_width = 6
			// .font_height = 6
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		// default:

	}

	switch (FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION)
	{
		case 1:
		{
			// .temp[0] = pixel_width - .Y1
			// .Y1 = .X1
			// .X1 = .temp[0]
			FCL_TEMP[0] = 240 - FCL_Y1;
			FCL_Y1 = FCL_X1;
			FCL_X1 = FCL_TEMP[0];

			break;
		}
		case 2:
		{
			// .X1 = pixel_width - .X1
			// .Y1 = pixel_height - .Y1
			FCL_X1 = 240 - FCL_X1;
			FCL_Y1 = 320 - FCL_Y1;

			break;
		}
		case 3:
		{
			// .temp[0] = .Y1
			// .Y1 = pixel_height - .X1
			// .X1 = .temp[0]
			FCL_TEMP[0] = FCL_Y1;
			FCL_Y1 = 320 - FCL_X1;
			FCL_X1 = FCL_TEMP[0];

			break;
		}
		// default:

	}

	// .xcount = 0
	// .idx = 0
	// .temp[5] = 0
	FCL_XCOUNT = 0;
	FCL_IDX = 0;
	FCL_TEMP[5] = 0;

	// .len_str = Length$ (.Str)
	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		// .pos_str = .Str[.idx] - 32
		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		// .count = 0
		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			// .count = .count + 1
			FCL_COUNT = FCL_COUNT + 1;


		}

		// .temp[.count] = 0
		FCL_TEMP[FCL_COUNT] = 0;

		// .xpix = 0
		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			// .width = 0
			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				switch (FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION)
				{
					case 1:
					{
						FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1, FCL_Y1 + FCL_XCOUNT, FCL_X1 + (FCL_FONT_HEIGHT * 8), FCL_Y1 + FCL_XCOUNT);

						break;
					}
					case 2:
					{
						FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1 + FCL_XCOUNT, FCL_Y1, FCL_X1 + FCL_XCOUNT, FCL_Y1 + (FCL_FONT_HEIGHT * 8));

						break;
					}
					case 3:
					{
						FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1, FCL_Y1 - FCL_XCOUNT, FCL_X1 + (FCL_FONT_HEIGHT * 8), FCL_Y1 - FCL_XCOUNT);

						break;
					}
					default:
					{
						FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1 + FCL_XCOUNT, FCL_Y1, FCL_X1 + FCL_XCOUNT, FCL_Y1 + (FCL_FONT_HEIGHT * 8));

					}
				}

				// .ycount = 0
				FCL_YCOUNT = 0;

				// .ypix = 0
				FCL_YPIX = 0;

				// dc_pin = 1
				SET_PORT_PIN(C, 1, 1);

				// chip_sel_pin = 0
				SET_PORT_PIN(C, 2, 0);

				while (FCL_YPIX < 8)
				{

					// .height = 0
					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						switch (FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION)
						{
							case 1:
							{
								// .dat = .temp[.xpix] & (0x80 >> .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x80 >> FCL_YPIX);

								break;
							}
							case 2:
							{
								// .dat = .temp[.xpix] & (0x01 << .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX);

								break;
							}
							case 3:
							{
								// .dat = .temp[.xpix] & (0x01 << .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX);

								break;
							}
							default:
							{
								// .dat = .temp[.xpix] & (0x01 << .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX);

							}
						}

						if (FCL_DAT)
						{

							FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR >> 8);

							FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR >> 8);

								FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR);

							} else {

								FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR >> 8);

								FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR);

							}

						}

						// .height = .height + 1
						// .ycount = .ycount + 1
						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					// .ypix = .ypix + 1
					FCL_YPIX = FCL_YPIX + 1;


				}

				#if 0 // Disabled code
				// chip_sel_pin = 1
				SET_PORT_PIN(C, 2, 1);

				#endif // #if 0: Disabled code
				// .width = .width + 1
				// .xcount = .xcount + 1
				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			// .xpix = .xpix + 1
			FCL_XPIX = FCL_XPIX + 1;


		}

		// .idx = .idx + 1
		FCL_IDX = FCL_IDX + 1;


	}

	//Local variable definitions
#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__ClearDisplay()
{
	//Local variable definitions
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	FCD_0a2b1_gLCD_ILI9341_SPI1__Window(0, 0, 240 - 1, 320 - 1);

	// dc_pin = 1
	SET_PORT_PIN(C, 1, 1);

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	while (FCL_Y < 320)
	{

		// .X = 0
		FCL_X = 0;

		while (FCL_X < 240)
		{

			FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR >> 8);

			FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR);

			// .X = .X + 1
			FCL_X = FCL_X + 1;


		}

		// .Y = .Y + 1
		FCL_Y = FCL_Y + 1;


	}

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetBackgroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

	// .Red = .Red >> (8 - red_bit_depth)
	// .Green = .Green >> (8 - green_bit_depth)
	// .Blue = .Blue >> (8 - blue_bit_depth)
	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	// background_col_var = .Blue | (.Green << blue_bit_depth)
	// background_col_var = background_col_var | (.Red << (green_bit_depth + blue_bit_depth))
	FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR = FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Local variable definitions
	MX_SINT16 FCL_D;
	MX_SINT16 FCL_CURX;
	MX_SINT16 FCL_CURY;
	MX_UINT32 FCL_BGCOL;
	MX_UINT32 FCL_FGCOL;
	MX_UINT8 FCL_REP = (0x0);


	if (FCL_SOLID == 1)
	{

	FCC_DrawCircle_A:
		;

		// .D = 3 - (.Radius << 1)
		FCL_D = 3 - (FCL_RADIUS << 1);

		// .CurX = 0
		// .CurY = .Radius
		FCL_CURX = 0;
		FCL_CURY = FCL_RADIUS;

		while (FCL_CURX <= FCL_CURY)
		{

			if (FCL_CURY > 0)
			{

				FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURY, FCL_Y + FCL_CURX, FCL_X + FCL_CURY, FCL_Y + FCL_CURX);

				FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURY, FCL_Y - FCL_CURX, FCL_X + FCL_CURY, FCL_Y - FCL_CURX);

			// } else {

			}

			if (FCL_CURX > 0)
			{

				FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURX, FCL_Y - FCL_CURY, FCL_X + FCL_CURX, FCL_Y - FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURX, FCL_Y + FCL_CURY, FCL_X + FCL_CURX, FCL_Y + FCL_CURY);

			// } else {

			}

			if (FCL_D < 0)
			{

				// .D = .D + ((.CurX << 2) + 6)
				FCL_D = FCL_D + ((FCL_CURX << 2) + 6);

			} else {

				// .D = .D + (((.CurX - .CurY) << 2) + 10)
				FCL_D = FCL_D + (((FCL_CURX - FCL_CURY) << 2) + 10);

				// .CurY = .CurY - 1
				FCL_CURY = FCL_CURY - 1;

			}

			// .CurX = .CurX + 1
			FCL_CURX = FCL_CURX + 1;


		}

	} else {

		if (FCL_TRANSPARENT == 1)
		{

		FCC_DrawCircle_B:
			;

			// .D = 3 - (.Radius << 1)
			FCL_D = 3 - (FCL_RADIUS << 1);

			// .CurX = 0
			// .CurY = .Radius
			FCL_CURX = 0;
			FCL_CURY = FCL_RADIUS;

			while (FCL_CURX <= FCL_CURY)
			{

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURX, FCL_Y - FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURX, FCL_Y - FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURY, FCL_Y - FCL_CURX);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURY, FCL_Y - FCL_CURX);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURX, FCL_Y + FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURX, FCL_Y + FCL_CURY);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURY, FCL_Y + FCL_CURX);

				FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURY, FCL_Y + FCL_CURX);

				if (FCL_D < 0)
				{

					// .D = .D + ((.CurX << 2) + 6)
					FCL_D = FCL_D + ((FCL_CURX << 2) + 6);

				} else {

					// .D = .D + (((.CurX - .CurY) << 2) + 10)
					FCL_D = FCL_D + (((FCL_CURX - FCL_CURY) << 2) + 10);

					// .CurY = .CurY - 1
					FCL_CURY = FCL_CURY - 1;

				}

				// .CurX = .CurX + 1
				FCL_CURX = FCL_CURX + 1;


			}

		} else {

			// .FGCol = foreground_col_var
			// .BGCol = background_col_var
			FCL_FGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR;
			FCL_BGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR;

			// foreground_col_var = .BGCol
			FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_BGCOL;

			// .Rep = 1
			FCL_REP = 1;

			goto FCC_DrawCircle_A;

		}

	}

	if (FCL_REP == 1)
	{

		// .Rep = .Rep + 1
		FCL_REP = FCL_REP + 1;

		// foreground_col_var = .FGCol
		FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_FGCOL;

		goto FCC_DrawCircle_B;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetForegroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

	// .Red = .Red >> (8 - red_bit_depth)
	// .Green = .Green >> (8 - green_bit_depth)
	// .Blue = .Blue >> (8 - blue_bit_depth)
	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	// foreground_col_var = .Blue | (.Green << blue_bit_depth)
	// foreground_col_var = foreground_col_var | (.Red << (green_bit_depth + blue_bit_depth))
	FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Local variable definitions
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			// .Xmax = .X1
			// .Xmin = .X2 + 1
			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			// .Xmax = .X2
			// .Xmin = .X1 + 1
			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			// .Ymax = .Y1
			// .Ymin = .Y2 + 1
			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			// .Ymax = .Y2
			// .Ymin = .Y1 + 1
			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		// .Y1 = .Ymin
		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			// .X1 = .Xmin
			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0a2b1_gLCD_ILI9341_SPI1__BPlot(FCL_X1, FCL_Y1);

				}

				// .X1 = .X1 + 1
				FCL_X1 = FCL_X1 + 1;


			}

			// .Y1 = .Y1 + 1
			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0a2b1_gLCD_ILI9341_SPI1__Initialise()
{

	FC_CAL_SPI_Master_Init_1();

	// reset_pin = 1
	SET_PORT_PIN(C, 0, 1);

	FCI_DELAYBYTE_MS(5);

	// reset_pin = 0
	SET_PORT_PIN(C, 0, 0);

	FCI_DELAYBYTE_MS(5);

	// dc_pin = 0
	// chip_sel_pin = 1
	SET_PORT_PIN(C, 1, 0);
	SET_PORT_PIN(C, 2, 1);

	// reset_pin = 1
	SET_PORT_PIN(C, 0, 1);

	FCI_DELAYBYTE_MS(5);

	// chip_sel_pin = 0
	SET_PORT_PIN(C, 2, 0);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xCB);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x39);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x2C);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x34);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x02);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xCF);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0xC1);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x30);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xE8);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x85);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x78);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xEA);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xED);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x64);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x03);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x12);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x81);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xF7);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x20);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC0);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x23);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC1);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x10);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC5);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x3E);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x28);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC7);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x86);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x36);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x48);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x3A);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x55);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xB1);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x18);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xB6);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x08);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x82);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x27);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xF2);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x26);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x01);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xE0);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0F);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x31);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x2B);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0C);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0E);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x08);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x4E);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0xF1);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x37);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x07);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x10);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x3);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0E);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x09);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xE1);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0E);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x14);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x03);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x11);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x07);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x31);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0xC1);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x48);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x08);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0F);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0C);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x31);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x36);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0F);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x11);

	FCI_DELAYBYTE_MS(120);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x29);

	FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x2C);

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	// foreground_col_var = FGCOL
	// background_col_var = BGCOL
	FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = 65503;
	FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR = 0;

	FCD_0a2b1_gLCD_ILI9341_SPI1__ClearDisplay();

}


/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
ADCON1 = 0x07;

OPTION_REG = 0xC0;


	// Name: Call Component Macro, Type: Call Component Macro: Servo_Controller1::Initialise()
	FCD_0dd21_Servo_Controller1__Initialise();

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341_SPI1::Initialise()
	FCD_0a2b1_gLCD_ILI9341_SPI1__Initialise();

	// Name: Call Component Macro, Type: Call Component Macro: 
	//No code generated because there is no macro name

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

	MX_CCP1_INT_START
	{

	//Comment:
	//Servo Mark - each channel fires once for at least Minimum us
	//Up to Maximum us

	MX_UINT32 FCL_SERVOCAL;
	MX_SINT16 FCL_TRIM;

	if (FCV_0dd21_Servo_Controller1__SERVO_IDX < 8)
	{

		if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (0x01 << FCV_0dd21_Servo_Controller1__SERVO_IDX))
		{

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 0)
			{

				// pin0 = 1
				SET_PORT_PIN(D, 0, 1);

			// } else {

			}

			#if (MX_Servo_Channel_Count > 1)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 1)
			{

				// pin1 = 1
				SET_PORT_PIN(D, 1, 1);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 2)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 2)
			{

				// pin2 = 1
				SET_PORT_PIN(D, 2, 1);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 3)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 3)
			{

				// pin3 = 1
				SET_PORT_PIN(D, 3, 1);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 4)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 4)
			{

				// pin4 = 1
				SET_PORT_PIN(D, 4, 1);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 5)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 5)
			{

				// pin5 = 1
				SET_PORT_PIN(D, 5, 1);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 6)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 6)
			{

				// pin6 = 1
				SET_PORT_PIN(D, 6, 1);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 7)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 7)
			{

				// pin7 = 1
				SET_PORT_PIN(D, 7, 1);

			// } else {

			}

			#endif

		// } else {

		}

	// } else {

	}

	// .ServoCal = Servo_Position[Servo_Idx]
	// .ServoCal = .ServoCal + Servo_Clock_Count_1280
	// .ServoCal = .ServoCal + Servo_Trim[Servo_Idx]
	FCL_SERVOCAL = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX];
	FCL_SERVOCAL = FCL_SERVOCAL + 4916;
	FCL_SERVOCAL = FCL_SERVOCAL + FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCV_0dd21_Servo_Controller1__SERVO_IDX];

	//Comment:
	//These did work to give a slightly more accurate top end
	//However using it Medelec experienced problems with max duty bleeding
	//and effecting other channels.

	#if 0 // Disabled code
	if (0 == 1)
	{

		// .ServoCal = .ServoCal + (Servo_Position[Servo_Idx] >> 1)
		FCL_SERVOCAL = FCL_SERVOCAL + (FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] >> 1);

	// } else {

	}

	#endif // #if 0: Disabled code
	#if 0 // Disabled code
	if (FCL_SERVOCAL > ((38 << 8) | 107))
	{

		// .ServoCal = ((CCPHi << 8) | CCPLo)
		FCL_SERVOCAL = ((38 << 8) | 107);

	// } else {

	}

	#endif // #if 0: Disabled code
	#if defined MX_CAL_STARM
		MX_CONFIG_OC_SERVO.Pulse = FCL_SERVOCAL;
		HAL_TIM_OC_ConfigChannel(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_OC_SERVO, TIM_CHANNEL_1);

	#elif defined MX_CAL_ARM
		AT91C_BASE_TC2->TC_RA = FCL_SERVOCAL;											//Setup capture compare registers
	#else
		#ifdef MX_CAL_PIC16
			PR2 = FCL_SERVOCAL;
			TMR2 = 0;
			T2CON = 0x8000;
		#else
			MX_SERVO_REG_CCPR2H = ( FCL_SERVOCAL >> 8 );								//Setup capture compare registers
			MX_SERVO_REG_CCPR2L = ( FCL_SERVOCAL & 0xFF );
		#endif
	#endif

	if (0)
	{

		//Comment:
		//Only PIC16 can run fast enough for problems?

		#ifdef MX_CAL_PIC16

		  T2CON |= 0x0010;

		#endif

	// } else {

	}

	#if defined MX_CAL_STARM

	#elif defined MX_CAL_PIC16
		MX_SERVO_REG_CCP1F.MX_SERVO_FLAG_CCP1F = 0;											//Clear interrupt
	#else
		cr_bit(MX_SERVO_REG_CCP1F, MX_SERVO_FLAG_CCP1F);									//Clear interrupt
	#endif

	}


	MX_CCP2_INT_START
	{

	MX_SINT16 FCL_CALC;

	//Comment:
	//Servo Space - Fills the remainder of the period with output low

	if (FCV_0dd21_Servo_Controller1__SERVO_IDX < 8)
	{

		if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (0x01 << FCV_0dd21_Servo_Controller1__SERVO_IDX))
		{

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 0)
			{

				// pin0 = 0
				SET_PORT_PIN(D, 0, 0);

			// } else {

			}

			#if (MX_Servo_Channel_Count > 1)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 1)
			{

				// pin1 = 0
				SET_PORT_PIN(D, 1, 0);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 2)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 2)
			{

				// pin2 = 0
				SET_PORT_PIN(D, 2, 0);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 3)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 3)
			{

				// pin3 = 0
				SET_PORT_PIN(D, 3, 0);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 4)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 4)
			{

				// pin4 = 0
				SET_PORT_PIN(D, 4, 0);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 5)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 5)
			{

				// pin5 = 0
				SET_PORT_PIN(D, 5, 0);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 6)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 6)
			{

				// pin6 = 0
				SET_PORT_PIN(D, 6, 0);

			// } else {

			}

			#endif

			#if (MX_Servo_Channel_Count > 7)

			if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 7)
			{

				// pin7 = 0
				SET_PORT_PIN(D, 7, 0);

			// } else {

			}

			#endif

		// } else {

		}

	// } else {

	}

	// Servo_Idx = (Servo_Idx + 1) & 0x07
	FCV_0dd21_Servo_Controller1__SERVO_IDX = (FCV_0dd21_Servo_Controller1__SERVO_IDX + 1) & 0x07;

	if (FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] > FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX])
	{

		// .calc = Servo_Position[Servo_Idx] + AutoMoveSpeed
		FCL_CALC = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] + FCV_0dd21_Servo_Controller1__AUTOMOVESPEED;

		if (FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] > FCL_CALC)
		{

			// Servo_Position[Servo_Idx] = .calc
			FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = FCL_CALC;

		} else {

			// Servo_Position[Servo_Idx] = Servo_Required[Servo_Idx]
			FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX];

		}

	} else {

		if (FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] < FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX])
		{

			// .calc = Servo_Position[Servo_Idx] - AutoMoveSpeed
			FCL_CALC = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] - FCV_0dd21_Servo_Controller1__AUTOMOVESPEED;

			if (FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] < FCL_CALC)
			{

				// Servo_Position[Servo_Idx] = .calc
				FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = FCL_CALC;

			} else {

				// Servo_Position[Servo_Idx] = Servo_Required[Servo_Idx]
				FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX];

			}

		} else {

			// AutoMoving = AutoMoving & ~ (1 << Servo_Idx)
			FCV_0dd21_Servo_Controller1__AUTOMOVING = FCV_0dd21_Servo_Controller1__AUTOMOVING & ~(1 << FCV_0dd21_Servo_Controller1__SERVO_IDX);

		}

	}

	#if defined MX_CAL_STARM
	#elif defined MX_CAL_PIC16
		T2CON = 0;
		MX_SERVO_REG_CCP2F.MX_SERVO_FLAG_CCP2F = 0;								//Clear interrupt
	#else
		cr_bit(MX_SERVO_REG_CCP2F, MX_SERVO_FLAG_CCP2F);						//Clear interrupt
	#endif

	}

}




