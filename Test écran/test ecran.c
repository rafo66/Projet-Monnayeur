//************************************************************************************
//**  
//**  Source name:   C:\Users\USERX\OneDrive - Conseil régional Grand Est - Numérique Educatif\Lycée\Terminale\2I2D\Projet\Test écran\test ecran.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.16F.16F877
//**  
//**  Generated by:  Flowcode v8.2.2.15
//**  Date:          Thursday, March 30, 2023 22:39:59
//**  Users:         1
//**  Registered to:  LYC-LORITZ54-V8
//**  License key: UJJ0K6
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  https://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_CAL_PIC

#define MX_CLK_SPEED 19660800

#define FCP_NULL Unconnected_Port


#include <xc.h>
#include <math.h>
//Chip Configuration Settings
__PROG_CONFIG(0x1, 0x3FF9);

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\internals.c"



MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;


/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_NOMBRE;
MX_GLOBAL MX_UINT8 FCV_COORD_Y;
MX_GLOBAL MX_UINT8 FCV_NOMBRE2;
MX_GLOBAL MX_UINT8 FCV_COORD_X;

void FCM_drawMenuBar();
void FCM_drawMenuList();
void FCM_drawMenu();

/*========================================================================*\
   Use :ASCIIData
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_ASCIIData__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCIIData__INTLIST 475
#define FCVsz_00fb1_ASCIIData__FLOATLIST 1
#define FCVsz_00fb1_ASCIIData__INTFIXEDLIST 1
#define FCD_00fb1_ASCIIData__INTLIST(ix) FCD_00fb1_ASCIIData__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCIIData__INTLIST_LUT ROMARRAY_E =
{
// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8, 0, 224, 96, 0, 0,
 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16, 8, 4, 2, 62,
 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73, 73, 70, 34, 73,
 73, 73, 54, 24, 20, 18, 127, 16, 39, 69, 69, 69, 57, 60, 74, 73,
 73, 48, 1, 113, 9, 5, 3, 54, 73, 73, 73, 54, 6, 73, 73, 41,
 30, 0, 108, 108, 0, 0, 0, 236, 108, 0, 0, 8, 20, 34, 65, 0,
 36, 36, 36, 36, 36, 0, 65, 34, 20, 8, 2, 1, 89, 9, 6, 62,
 65, 93, 85, 30, 126, 9, 9, 9, 126, 127, 73, 73, 73, 54, 62, 65,
 65, 65, 34, 127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9,
 9, 1, 62, 65, 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65,
 0, 48, 64, 64, 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64,
 127, 2, 4, 2, 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62, 127,
 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0, 2, 4, 8, 16, 32,
 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128, 128, 128, 128, 0,
 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68, 68, 56, 56, 68,
 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84, 24, 8, 126, 9,
 9, 0, 24, 164, 164, 164, 124, 127, 4, 4, 120, 0, 0, 0, 125, 0,
 0, 64, 128, 132, 125, 0, 127, 16, 40, 68, 0, 0, 0, 127, 64, 0,
 124, 4, 24, 4, 120, 124, 4, 4, 120, 0, 56, 68, 68, 68, 56, 252,
 68, 68, 68, 56, 56, 68, 68, 68, 252, 68, 120, 68, 4, 8, 8, 84,
 84, 84, 32, 4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64,
 32, 28, 60, 96, 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60,
 0, 100, 84, 84, 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0,
 0, 65, 65, 62, 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};

MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount();

/*========================================================================*\
   Use :Base_GLCD
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);

/*========================================================================*\
   Use :gLCD_ILI9341
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ee11_gLCD_ILI9341__ORIENTATION = (0x0);

void FCD_0ee11_gLCD_ILI9341__BacklightOn();
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(MX_UINT8 FCL_DATA);
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(MX_UINT16 FCL_DATA);
void FCD_0ee11_gLCD_ILI9341__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ee11_gLCD_ILI9341__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(MX_UINT8 FCL_DATA);
void FCD_0ee11_gLCD_ILI9341__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ee11_gLCD_ILI9341__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ee11_gLCD_ILI9341__FastPlot();
void FCD_0ee11_gLCD_ILI9341__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ee11_gLCD_ILI9341__BacklightOff();
void FCD_0ee11_gLCD_ILI9341__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ee11_gLCD_ILI9341__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ee11_gLCD_ILI9341__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ee11_gLCD_ILI9341__ClearDisplay();
void FCD_0ee11_gLCD_ILI9341__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ee11_gLCD_ILI9341__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ee11_gLCD_ILI9341__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ee11_gLCD_ILI9341__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ee11_gLCD_ILI9341__Initialise();
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus8(MX_UINT8 FCL_DATA);

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\includes.c"


/*========================================================================*\
   Use :ASCIIData
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	// .Return = NumVals
	FCR_RETVAL = 475;

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :Base_GLCD
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Local variable definitions
	MX_UINT16 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		if (FCL_POS_STR > 94)
		{

			// .Return = 0xaa
			FCR_RETVAL = 0xaa;

		} else {

			// .position = (.pos_str * 5) + .count
			FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

			FCR_RETVAL = FCD_00fb1_ASCIIData__INTLIST(FCL_POSITION);

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_ILI9341
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the backlight enable pin allowing the display backlight to switch on.
       :Switching the backlight on and off at high speed allow the light to be dimmed.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__BacklightOn()
{

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro LCD_Write_Reg:
       :  data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(MX_UINT8 FCL_DATA)
{

	// dc_pin = 0
	SET_PORT_PIN(B, 3, 0);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus8(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro LCD_Write_Bus16:
       :  data : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(MX_UINT16 FCL_DATA)
{

	#if (1)

		// chip_sel_pin = 0
		SET_PORT_PIN(B, 2, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 0 == 0

		for (FCLV_LOOP2=0; (FCLV_LOOP2)<(16); (FCLV_LOOP2)++)
		{

			if (FCL_DATA & 0x8000)
			{

				// dataout_pin = 1
				SET_PORT_PIN(B, 0, 1);

			} else {

				// dataout_pin = 0
				SET_PORT_PIN(B, 0, 0);

			}

			// clock_pin = 0
			SET_PORT_PIN(B, 1, 0);

			// clock_pin = 1
			SET_PORT_PIN(B, 1, 1);

			// .data = .data << 1
			FCL_DATA = FCL_DATA << 1;


		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (1)

		// chip_sel_pin = 1
		SET_PORT_PIN(B, 2, 1);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Parameters for macro PrintNumber:
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Range: 0 to 31 - 0=5x8, 1=10x8, 2=10x16, 3=5x16, 4-31=Extended Sizes
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Local variable definitions
#define FCLsz_TEMP 8
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	// .temp = ToString$ (.Number)
	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,8);

	FCD_0ee11_gLCD_ILI9341__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Local variable definitions
#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Local variable definitions
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);
	MX_SINT16 FCL_X;
	MX_SINT16 FCL_Y;


	// .PixelX = .X2 - .X1
	// .PixelY = .Y2 - .Y1
	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	// .X = .X1
	// .Y = .Y1
	FCL_X = FCL_X1;
	FCL_Y = FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		// .Xinc = -1
		// .PixelX = .PixelX * -1
		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		// .Yinc = -1
		// .PixelY = .PixelY * -1
		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		// .C1 = 2 * .PixelX
		// .M1 = 2 * .PixelY
		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X != FCL_X2)
		{

			FCD_0ee11_gLCD_ILI9341__Plot(FCL_X, FCL_Y);

			// .X = .X + .Xinc
			FCL_X = FCL_X + FCL_XINC;

			// .D1 = .D1 + .M1
			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				// .Y = .Y + .Yinc
				FCL_Y = FCL_Y + FCL_YINC;

				// .D1 = .D1 - .C1
				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		// .C1 = 2 * .PixelY
		// .M1 = 2 * .PixelX
		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y != FCL_Y2)
		{

			FCD_0ee11_gLCD_ILI9341__Plot(FCL_X, FCL_Y);

			// .Y = .Y + .Yinc
			FCL_Y = FCL_Y + FCL_YINC;

			// .D1 = .D1 + .M1
			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				// .X = .X + .Xinc
				FCL_X = FCL_X + FCL_XINC;

				// .D1 = .D1 - .C1
				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ee11_gLCD_ILI9341__Plot(FCL_X, FCL_Y);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro LCD_Write_Data8:
       :  data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(MX_UINT8 FCL_DATA)
{

	// dc_pin = 1
	SET_PORT_PIN(B, 3, 1);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus8(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse object on the display with the center of the ellipse at the location X,Y
       :
       :Parameters for macro DrawEllipse:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  XRadius : Radius of the circle on the X axis specified in pixels
       :  YRadius : Radius of the circle on the Y axis specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Local variable definitions
	MX_SINT16 FCL_ERR;
	MX_SINT16 FCL_CURX;
	MX_SINT16 FCL_CURY;
	MX_UINT32 FCL_BGCOL;
	MX_UINT32 FCL_FGCOL;
	MX_UINT8 FCL_REP = (0x0);
	MX_SINT16 FCL_E2;
	MX_FLOAT FCL_K;


	if (FCL_SOLID == 1)
	{

	FCC_DrawEllipse_A:
		;

		// .CurX = 0
		// .CurY = 0 - .YRadius
		FCL_CURX = 0;
		FCL_CURY = 0 - FCL_YRADIUS;

		// .err = 2 - (2 * .XRadius)
		FCL_ERR = 2 - (2 * FCL_XRADIUS);

		// .K = FLOAT (FLOAT .YRadius / FLOAT .XRadius)
		FCL_K = (flt_div(flt_fromi(FCL_YRADIUS), flt_fromi(FCL_XRADIUS)));

		while (1)
		{

			FCD_0ee11_gLCD_ILI9341__DrawLine(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY, flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY);

			FCD_0ee11_gLCD_ILI9341__DrawLine(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY, flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY);

			// .e2 = .err
			FCL_E2 = FCL_ERR;

			if (FCL_E2 <= FCL_CURX)
			{

				// .CurX = .CurX + 1
				// .err = .err + ((.CurX * 2) + 1)
				FCL_CURX = FCL_CURX + 1;
				FCL_ERR = FCL_ERR + ((FCL_CURX * 2) + 1);

				if ((0 - FCL_CURY == FCL_CURX) && (FCL_E2 <= FCL_CURY))
				{

					// .e2 = 0
					FCL_E2 = 0;

				// } else {

				}

			// } else {

			}

			if (FCL_E2 > FCL_CURY)
			{

				// .CurY = .CurY + 1
				// .err = .err + ((.CurY * 2) + 1)
				FCL_CURY = FCL_CURY + 1;
				FCL_ERR = FCL_ERR + ((FCL_CURY * 2) + 1);

			// } else {

			}


			if ((FCL_CURY <= 0) == 0) break;
		}

	} else {

		if (FCL_TRANSPARENT == 1)
		{

		FCC_DrawEllipse_B:
			;

			// .CurX = 0
			// .CurY = 0 - .YRadius
			FCL_CURX = 0;
			FCL_CURY = 0 - FCL_YRADIUS;

			// .err = 2 - (2 * .XRadius)
			FCL_ERR = 2 - (2 * FCL_XRADIUS);

			// .K = FLOAT (FLOAT .YRadius / FLOAT .XRadius)
			FCL_K = (flt_div(flt_fromi(FCL_YRADIUS), flt_fromi(FCL_XRADIUS)));

			while (1)
			{

				FCD_0ee11_gLCD_ILI9341__Plot(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__Plot(flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y + FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__Plot(flt_toi(flt_add(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__Plot(flt_toi(flt_sub(flt_fromi(FCL_X), (flt_div(flt_fromi(FCL_CURX), FCL_K)))), FCL_Y - FCL_CURY);

				// .e2 = .err
				FCL_E2 = FCL_ERR;

				if (FCL_E2 <= FCL_CURX)
				{

					// .CurX = .CurX + 1
					// .err = .err + ((.CurX * 2) + 1)
					FCL_CURX = FCL_CURX + 1;
					FCL_ERR = FCL_ERR + ((FCL_CURX * 2) + 1);

					if ((0 - FCL_CURY == FCL_CURX) && (FCL_E2 <= FCL_CURY))
					{

						// .e2 = 0
						FCL_E2 = 0;

					// } else {

					}

				// } else {

				}

				if (FCL_E2 > FCL_CURY)
				{

					// .CurY = .CurY + 1
					// .err = .err + ((.CurY * 2) + 1)
					FCL_CURY = FCL_CURY + 1;
					FCL_ERR = FCL_ERR + ((FCL_CURY * 2) + 1);

				// } else {

				}


				if ((FCL_CURY <= 0) == 0) break;
			}

		} else {

			// .FGCol = foreground_col_var
			// .BGCol = background_col_var
			FCL_FGCOL = FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR;
			FCL_BGCOL = FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR;

			// foreground_col_var = .BGCol
			FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR = FCL_BGCOL;

			// .Rep = 1
			FCL_REP = 1;

			goto FCC_DrawEllipse_A;

		}

	}

	if (FCL_REP == 1)
	{

		// .Rep = .Rep + 1
		FCL_REP = FCL_REP + 1;

		// foreground_col_var = .FGCol
		FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR = FCL_FGCOL;

		goto FCC_DrawEllipse_B;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Local variable definitions
	MX_UINT16 FCL_TEMP;


	switch (FCV_0ee11_gLCD_ILI9341__ORIENTATION)
	{
		case 1:
		{
			// .temp = pixel_width - (.Y1 + 1)
			// .Y1 = .X1
			// .X1 = .temp
			FCL_TEMP = 320 - (FCL_Y1 + 1);
			FCL_Y1 = FCL_X1;
			FCL_X1 = FCL_TEMP;

			break;
		}
		case 2:
		{
			// .X1 = pixel_width - (.X1 + 1)
			// .Y1 = pixel_height - (.Y1 + 1)
			FCL_X1 = 320 - (FCL_X1 + 1);
			FCL_Y1 = 240 - (FCL_Y1 + 1);

			break;
		}
		case 3:
		{
			// .temp = .Y1
			// .Y1 = pixel_height - (.X1 + 1)
			// .X1 = .temp
			FCL_TEMP = FCL_Y1;
			FCL_Y1 = 240 - (FCL_X1 + 1);
			FCL_X1 = FCL_TEMP;

			break;
		}
		// default:

	}

	FCD_0ee11_gLCD_ILI9341__Window(FCL_X1, FCL_Y1, FCL_X1, FCL_Y1);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at current pixel location.
       :Not compatible with orientations other than 0.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__FastPlot()
{
	//Local variable definitions
	MX_UINT16 FCL_TEMP;


	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Parameters for macro SetDisplayOrientation:
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	// Orientation = .Orientation
	FCV_0ee11_gLCD_ILI9341__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Clears the backlight enable pin allowing the display backlight to switch off.
       :Switching the backlight on and off at high speed allow the light to be dimmed.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__BacklightOff()
{

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Local variable definitions
	MX_UINT16 FCL_TEMP;


	switch (FCV_0ee11_gLCD_ILI9341__ORIENTATION)
	{
		case 1:
		{
			// .temp = pixel_width - (.Y1 + 1)
			// .Y1 = .X1
			// .X1 = .temp
			FCL_TEMP = 320 - (FCL_Y1 + 1);
			FCL_Y1 = FCL_X1;
			FCL_X1 = FCL_TEMP;

			break;
		}
		case 2:
		{
			// .X1 = pixel_width - (.X1 + 1)
			// .Y1 = pixel_height - (.Y1 + 1)
			FCL_X1 = 320 - (FCL_X1 + 1);
			FCL_Y1 = 240 - (FCL_Y1 + 1);

			break;
		}
		case 3:
		{
			// .temp = .Y1
			// .Y1 = pixel_height - (.X1 + 1)
			// .X1 = .temp
			FCL_TEMP = FCL_Y1;
			FCL_Y1 = 240 - (FCL_X1 + 1);
			FCL_X1 = FCL_TEMP;

			break;
		}
		// default:

	}

	FCD_0ee11_gLCD_ILI9341__Window(FCL_X1, FCL_Y1, FCL_X1, FCL_Y1);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Window:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

	//Comment:
	//Set Column Address

	// dc_pin = 0
	SET_PORT_PIN(B, 3, 0);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus8(0x2A);

	// dc_pin = 1
	SET_PORT_PIN(B, 3, 1);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCL_X1);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCL_X2);

	//Comment:
	//Set Row Address

	// dc_pin = 0
	SET_PORT_PIN(B, 3, 0);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus8(0x2B);

	// dc_pin = 1
	SET_PORT_PIN(B, 3, 1);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCL_Y1);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCL_Y2);

	//Comment:
	//Prep for data

	// dc_pin = 0
	SET_PORT_PIN(B, 3, 0);

	FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus8(0x2C);

	// dc_pin = 1
	SET_PORT_PIN(B, 3, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Parameters for macro Print:
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Range: 0 to 31 - 0=5x8, 1=10x8, 2=10x16, 3=5x16, 4-31=Extended Sizes
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Local variable definitions
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT16 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	MX_UINT8 FCL_POSITION;
#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];
	MX_UINT8 FCL_DAT;


	switch (FCL_FONT)
	{
		case 1:
		{
			// .font_width = 2
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			// .font_width = 2
			// .font_height = 2
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			// .font_height = 2
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 4:
		{
			// .font_width = 2
			// .font_height = 3
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 5:
		{
			// .font_width = 2
			// .font_height = 4
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 6:
		{
			// .font_width = 2
			// .font_height = 5
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 7:
		{
			// .font_width = 2
			// .font_height = 6
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 8:
		{
			// .font_width = 3
			// .font_height = 1
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		case 9:
		{
			// .font_width = 3
			// .font_height = 2
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 10:
		{
			// .font_width = 3
			// .font_height = 3
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		// default:

	}

	switch (FCL_FONT)
	{
		case 11:
		{
			// .font_width = 3
			// .font_height = 4
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 12:
		{
			// .font_width = 3
			// .font_height = 5
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 13:
		{
			// .font_width = 3
			// .font_height = 6
			FCL_FONT_WIDTH = 3;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 14:
		{
			// .font_width = 4
			// .font_height = 1
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		case 15:
		{
			// .font_width = 4
			// .font_height = 2
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 16:
		{
			// .font_width = 4
			// .font_height = 3
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 17:
		{
			// .font_width = 4
			// .font_height = 4
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 18:
		{
			// .font_width = 4
			// .font_height = 5
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 19:
		{
			// .font_width = 4
			// .font_height = 6
			FCL_FONT_WIDTH = 4;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 20:
		{
			// .font_width = 5
			// .font_height = 1
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		// default:

	}

	switch (FCL_FONT)
	{
		case 21:
		{
			// .font_width = 5
			// .font_height = 2
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 22:
		{
			// .font_width = 5
			// .font_height = 3
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 23:
		{
			// .font_width = 5
			// .font_height = 4
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 24:
		{
			// .font_width = 5
			// .font_height = 5
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		case 25:
		{
			// .font_width = 5
			// .font_height = 6
			FCL_FONT_WIDTH = 5;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		case 26:
		{
			// .font_width = 6
			// .font_height = 1
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 1;

			break;
		}
		case 27:
		{
			// .font_width = 6
			// .font_height = 2
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 28:
		{
			// .font_width = 6
			// .font_height = 3
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 3;

			break;
		}
		case 29:
		{
			// .font_width = 6
			// .font_height = 4
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 4;

			break;
		}
		case 30:
		{
			// .font_width = 6
			// .font_height = 5
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 5;

			break;
		}
		// default:

	}

	switch (FCL_FONT)
	{
		case 31:
		{
			// .font_width = 6
			// .font_height = 6
			FCL_FONT_WIDTH = 6;
			FCL_FONT_HEIGHT = 6;

			break;
		}
		// default:

	}

	switch (FCV_0ee11_gLCD_ILI9341__ORIENTATION)
	{
		case 1:
		{
			// .temp[0] = pixel_width - .Y1
			// .Y1 = .X1
			// .X1 = .temp[0]
			FCL_TEMP[0] = 320 - FCL_Y1;
			FCL_Y1 = FCL_X1;
			FCL_X1 = FCL_TEMP[0];

			break;
		}
		case 2:
		{
			// .X1 = pixel_width - .X1
			// .Y1 = pixel_height - .Y1
			FCL_X1 = 320 - FCL_X1;
			FCL_Y1 = 240 - FCL_Y1;

			break;
		}
		case 3:
		{
			// .temp[0] = .Y1
			// .Y1 = pixel_height - .X1
			// .X1 = .temp[0]
			FCL_TEMP[0] = FCL_Y1;
			FCL_Y1 = 240 - FCL_X1;
			FCL_X1 = FCL_TEMP[0];

			break;
		}
		// default:

	}

	// .xcount = 0
	// .idx = 0
	// .temp[5] = 0
	FCL_XCOUNT = 0;
	FCL_IDX = 0;
	FCL_TEMP[5] = 0;

	// .len_str = Length$ (.Str)
	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		// .pos_str = .Str[.idx] - 32
		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		// .count = 0
		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			// .count = .count + 1
			FCL_COUNT = FCL_COUNT + 1;


		}

		// .temp[.count] = 0
		FCL_TEMP[FCL_COUNT] = 0;

		// .xpix = 0
		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			// .width = 0
			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				switch (FCV_0ee11_gLCD_ILI9341__ORIENTATION)
				{
					case 1:
					{
						FCD_0ee11_gLCD_ILI9341__Window(FCL_X1, FCL_Y1 + FCL_XCOUNT, FCL_X1 + (FCL_FONT_HEIGHT * 8), FCL_Y1 + FCL_XCOUNT);

						break;
					}
					case 2:
					{
						FCD_0ee11_gLCD_ILI9341__Window(FCL_X1 + FCL_XCOUNT, FCL_Y1, FCL_X1 + FCL_XCOUNT, FCL_Y1 + (FCL_FONT_HEIGHT * 8));

						break;
					}
					case 3:
					{
						FCD_0ee11_gLCD_ILI9341__Window(FCL_X1, FCL_Y1 - FCL_XCOUNT, FCL_X1 + (FCL_FONT_HEIGHT * 8), FCL_Y1 - FCL_XCOUNT);

						break;
					}
					default:
					{
						FCD_0ee11_gLCD_ILI9341__Window(FCL_X1 + FCL_XCOUNT, FCL_Y1, FCL_X1 + FCL_XCOUNT, FCL_Y1 + (FCL_FONT_HEIGHT * 8));

					}
				}

				// .ycount = 0
				FCL_YCOUNT = 0;

				// .ypix = 0
				FCL_YPIX = 0;

				// dc_pin = 1
				SET_PORT_PIN(B, 3, 1);

				#if 0 // Disabled code
				// chip_sel_pin = 0
				SET_PORT_PIN(B, 2, 0);

				#endif // #if 0: Disabled code
				while (FCL_YPIX < 8)
				{

					// .height = 0
					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						switch (FCV_0ee11_gLCD_ILI9341__ORIENTATION)
						{
							case 1:
							{
								// .dat = .temp[.xpix] & (0x80 >> .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x80 >> FCL_YPIX);

								break;
							}
							case 2:
							{
								// .dat = .temp[.xpix] & (0x01 << .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX);

								break;
							}
							case 3:
							{
								// .dat = .temp[.xpix] & (0x01 << .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX);

								break;
							}
							default:
							{
								// .dat = .temp[.xpix] & (0x01 << .ypix)
								FCL_DAT = FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX);

							}
						}

						if (FCL_DAT)
						{

							FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR);

							} else {

								FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR);

							}

						}

						// .height = .height + 1
						// .ycount = .ycount + 1
						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					// .ypix = .ypix + 1
					FCL_YPIX = FCL_YPIX + 1;


				}

				#if 0 // Disabled code
				// chip_sel_pin = 1
				SET_PORT_PIN(B, 2, 1);

				#endif // #if 0: Disabled code
				// .width = .width + 1
				// .xcount = .xcount + 1
				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			// .xpix = .xpix + 1
			FCL_XPIX = FCL_XPIX + 1;


		}

		// .idx = .idx + 1
		FCL_IDX = FCL_IDX + 1;


	}

	//Local variable definitions
#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__ClearDisplay()
{
	//Local variable definitions
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	FCD_0ee11_gLCD_ILI9341__Window(0, 0, 320 - 1, 240 - 1);

	// dc_pin = 1
	SET_PORT_PIN(B, 3, 1);

	while (FCL_Y < 240)
	{

		// .X = 0
		FCL_X = 0;

		while (FCL_X < 320)
		{

			FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus16(FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR);

			// .X = .X + 1
			FCL_X = FCL_X + 1;


		}

		// .Y = .Y + 1
		FCL_Y = FCL_Y + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetBackgroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

	// .Red = .Red >> (8 - red_bit_depth)
	// .Green = .Green >> (8 - green_bit_depth)
	// .Blue = .Blue >> (8 - blue_bit_depth)
	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	// background_col_var = .Blue | (.Green << blue_bit_depth)
	// background_col_var = background_col_var | (.Red << (green_bit_depth + blue_bit_depth))
	FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR = FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Local variable definitions
	MX_SINT16 FCL_D;
	MX_SINT16 FCL_CURX;
	MX_SINT16 FCL_CURY;
	MX_UINT32 FCL_BGCOL;
	MX_UINT32 FCL_FGCOL;
	MX_UINT8 FCL_REP = (0x0);


	if (FCL_SOLID == 1)
	{

	FCC_DrawCircle_A:
		;

		// .D = 3 - (.Radius << 1)
		FCL_D = 3 - (FCL_RADIUS << 1);

		// .CurX = 0
		// .CurY = .Radius
		FCL_CURX = 0;
		FCL_CURY = FCL_RADIUS;

		while (FCL_CURX <= FCL_CURY)
		{

			if (FCL_CURY > 0)
			{

				FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X - FCL_CURY, FCL_Y + FCL_CURX, FCL_X + FCL_CURY, FCL_Y + FCL_CURX);

				FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X - FCL_CURY, FCL_Y - FCL_CURX, FCL_X + FCL_CURY, FCL_Y - FCL_CURX);

			// } else {

			}

			if (FCL_CURX > 0)
			{

				FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X - FCL_CURX, FCL_Y - FCL_CURY, FCL_X + FCL_CURX, FCL_Y - FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X - FCL_CURX, FCL_Y + FCL_CURY, FCL_X + FCL_CURX, FCL_Y + FCL_CURY);

			// } else {

			}

			if (FCL_D < 0)
			{

				// .D = .D + ((.CurX << 2) + 6)
				FCL_D = FCL_D + ((FCL_CURX << 2) + 6);

			} else {

				// .D = .D + (((.CurX - .CurY) << 2) + 10)
				FCL_D = FCL_D + (((FCL_CURX - FCL_CURY) << 2) + 10);

				// .CurY = .CurY - 1
				FCL_CURY = FCL_CURY - 1;

			}

			// .CurX = .CurX + 1
			FCL_CURX = FCL_CURX + 1;


		}

	} else {

		if (FCL_TRANSPARENT == 1)
		{

		FCC_DrawCircle_B:
			;

			// .D = 3 - (.Radius << 1)
			FCL_D = 3 - (FCL_RADIUS << 1);

			// .CurX = 0
			// .CurY = .Radius
			FCL_CURX = 0;
			FCL_CURY = FCL_RADIUS;

			while (FCL_CURX <= FCL_CURY)
			{

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X + FCL_CURX, FCL_Y - FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X - FCL_CURX, FCL_Y - FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X + FCL_CURY, FCL_Y - FCL_CURX);

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X - FCL_CURY, FCL_Y - FCL_CURX);

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X + FCL_CURX, FCL_Y + FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X - FCL_CURX, FCL_Y + FCL_CURY);

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X + FCL_CURY, FCL_Y + FCL_CURX);

				FCD_0ee11_gLCD_ILI9341__Plot(FCL_X - FCL_CURY, FCL_Y + FCL_CURX);

				if (FCL_D < 0)
				{

					// .D = .D + ((.CurX << 2) + 6)
					FCL_D = FCL_D + ((FCL_CURX << 2) + 6);

				} else {

					// .D = .D + (((.CurX - .CurY) << 2) + 10)
					FCL_D = FCL_D + (((FCL_CURX - FCL_CURY) << 2) + 10);

					// .CurY = .CurY - 1
					FCL_CURY = FCL_CURY - 1;

				}

				// .CurX = .CurX + 1
				FCL_CURX = FCL_CURX + 1;


			}

		} else {

			// .FGCol = foreground_col_var
			// .BGCol = background_col_var
			FCL_FGCOL = FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR;
			FCL_BGCOL = FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR;

			// foreground_col_var = .BGCol
			FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR = FCL_BGCOL;

			// .Rep = 1
			FCL_REP = 1;

			goto FCC_DrawCircle_A;

		}

	}

	if (FCL_REP == 1)
	{

		// .Rep = .Rep + 1
		FCL_REP = FCL_REP + 1;

		// foreground_col_var = .FGCol
		FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR = FCL_FGCOL;

		goto FCC_DrawCircle_B;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetForegroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

	// .Red = .Red >> (8 - red_bit_depth)
	// .Green = .Green >> (8 - green_bit_depth)
	// .Blue = .Blue >> (8 - blue_bit_depth)
	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	// foreground_col_var = .Blue | (.Green << blue_bit_depth)
	// foreground_col_var = foreground_col_var | (.Red << (green_bit_depth + blue_bit_depth))
	FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR = FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Local variable definitions
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ee11_gLCD_ILI9341__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			// .Xmax = .X1
			// .Xmin = .X2 + 1
			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			// .Xmax = .X2
			// .Xmin = .X1 + 1
			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			// .Ymax = .Y1
			// .Ymin = .Y2 + 1
			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			// .Ymax = .Y2
			// .Ymin = .Y1 + 1
			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		// .Y1 = .Ymin
		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			// .X1 = .Xmin
			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ee11_gLCD_ILI9341__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ee11_gLCD_ILI9341__BPlot(FCL_X1, FCL_Y1);

				}

				// .X1 = .X1 + 1
				FCL_X1 = FCL_X1 + 1;


			}

			// .Y1 = .Y1 + 1
			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__Initialise()
{

	// reset_pin = 1
	SET_PORT_PIN(B, 4, 1);

	FCI_DELAYBYTE_MS(5);

	// reset_pin = 0
	SET_PORT_PIN(B, 4, 0);

	FCI_DELAYBYTE_MS(5);

	// dc_pin = 0
	// chip_sel_pin = 1
	SET_PORT_PIN(B, 3, 0);
	SET_PORT_PIN(B, 2, 1);

	#if (1) // 0 == 0

		// dataout_pin = 1
		// clock_pin = 1
		SET_PORT_PIN(B, 0, 1);
		SET_PORT_PIN(B, 1, 1);

	#else

	//Code has been optimised out by the pre-processor
	#endif

	// reset_pin = 1
	SET_PORT_PIN(B, 4, 1);

	FCI_DELAYBYTE_MS(5);

	#if (1)

	#else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1)

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xCB);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x39);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x2C);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x34);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x02);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xCF);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0xC1);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x30);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xE8);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x85);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x78);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xEA);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xED);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x64);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x03);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x12);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x81);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xF7);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x20);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xC0);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x23);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xC1);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x10);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xC5);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x3E);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x28);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xC7);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x86);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0x36);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x48);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0x3A);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x55);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xB1);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x18);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xB6);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x08);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x82);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x27);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xF2);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0x26);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x01);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xE0);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0F);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x31);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x2B);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0C);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0E);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x08);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x4E);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0xF1);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x37);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x07);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x10);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x3);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0E);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x09);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0xE1);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x00);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0E);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x14);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x03);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x11);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x07);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x31);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0xC1);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x48);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x08);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0F);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0C);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x31);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x36);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Data8(0x0F);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0x11);

		FCI_DELAYBYTE_MS(120);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0x29);

		FCD_0ee11_gLCD_ILI9341__LCD_Write_Reg(0x2C);

	#else

	//Code has been optimised out by the pre-processor
	#endif

	// foreground_col_var = FGCOL
	// background_col_var = BGCOL
	FCV_0ee11_gLCD_ILI9341__FOREGROUND_COL_VAR = 0;
	FCV_0ee11_gLCD_ILI9341__BACKGROUND_COL_VAR = 65535;

	FCD_0ee11_gLCD_ILI9341__ClearDisplay();

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro LCD_Write_Bus8:
       :  data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0ee11_gLCD_ILI9341__LCD_Write_Bus8(MX_UINT8 FCL_DATA)
{

	#if (1)

		// chip_sel_pin = 0
		SET_PORT_PIN(B, 2, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1) // 0 == 0

		for (FCLV_LOOP3=0; (FCLV_LOOP3)<(8); (FCLV_LOOP3)++)
		{

			if (FCL_DATA & 0x80)
			{

				// dataout_pin = 1
				SET_PORT_PIN(B, 0, 1);

			} else {

				// dataout_pin = 0
				SET_PORT_PIN(B, 0, 0);

			}

			// clock_pin = 0
			SET_PORT_PIN(B, 1, 0);

			// clock_pin = 1
			SET_PORT_PIN(B, 1, 1);

			// .data = .data << 1
			FCL_DATA = FCL_DATA << 1;


		}

	#else

	//Code has been optimised out by the pre-processor
	#endif

	#if (1)

		// chip_sel_pin = 1
		SET_PORT_PIN(B, 2, 1);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_drawMenuBar()
{

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::SetForegroundColour(136, 174, 215)
	FCD_0ee11_gLCD_ILI9341__SetForegroundColour(136, 174, 215);

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::DrawRectangle(0, 0, 320, 30, 0, 1)
	FCD_0ee11_gLCD_ILI9341__DrawRectangle(0, 0, 320, 30, 0, 1);

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::SetForegroundColour(255, 255, 255)
	FCD_0ee11_gLCD_ILI9341__SetForegroundColour(255, 255, 255);

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::Print("MENU", 10, 10, 2, 1)
	FCD_0ee11_gLCD_ILI9341__Print("MENU", 5, 10, 10, 2, 1);

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::DrawCircle(290, 15, 10, 0, 0)
	FCD_0ee11_gLCD_ILI9341__DrawCircle(290, 15, 10, 0, 0);

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::SetForegroundColour(37, 111, 190)
	FCD_0ee11_gLCD_ILI9341__SetForegroundColour(37, 111, 190);

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::DrawRectangle(0, 30, 320, 32, 0, 1)
	FCD_0ee11_gLCD_ILI9341__DrawRectangle(0, 30, 320, 32, 0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_drawMenuList()
{
	//Local variable definitions
#define FCLsz_TEXTE1 14
	#define FCL_TEXTE1 "Afficher somme"
#define FCLsz_TEXTE2 13
	#define FCL_TEXTE2 "Retirer somme"
#define FCLsz_TEXTE3 20
	#define FCL_TEXTE3 "Changer mot de passe"
#define FCLsz_TEXTE4 8
	#define FCL_TEXTE4 "Eteindre"


	// Name: Calculation, Type: Calculation:
	// coord_x = 20
	// coord_y = 50
	FCV_COORD_X = 20;
	FCV_COORD_Y = 50;

	// Name: à, Type: Call Component Macro: gLCD_ILI9341::SetForegroundColour(0, 0, 0)
	FCD_0ee11_gLCD_ILI9341__SetForegroundColour(0, 0, 0);

	// Name: Loop, Type: Loop: Loop  4 times
	for (FCLV_LOOP1=0; (FCLV_LOOP1)<(4); (FCLV_LOOP1)++)
	{

		// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::DrawCircle(coord_x, coord_y, 4, 0, 1)
		FCD_0ee11_gLCD_ILI9341__DrawCircle(FCV_COORD_X, FCV_COORD_Y, 4, 0, 1);

		// Name: Calculation, Type: Calculation:
		// coord_y = coord_y + 30
		FCV_COORD_Y = FCV_COORD_Y + 30;


	}

	// Name: Calculation, Type: Calculation:
	// coord_x = 35
	// coord_y = 43
	FCV_COORD_X = 35;
	FCV_COORD_Y = 43;

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::Print(.texte1, coord_x, coord_y, 2, 1)
	FCD_0ee11_gLCD_ILI9341__Print(FCL_TEXTE1, FCLsz_TEXTE1, FCV_COORD_X, FCV_COORD_Y, 2, 1);

	// Name: Calculation, Type: Calculation:
	// coord_y = coord_y + 30
	FCV_COORD_Y = FCV_COORD_Y + 30;

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::Print(.texte2, coord_x, coord_y, 2, 1)
	FCD_0ee11_gLCD_ILI9341__Print(FCL_TEXTE2, FCLsz_TEXTE2, FCV_COORD_X, FCV_COORD_Y, 2, 1);

	// Name: Calculation, Type: Calculation:
	// coord_y = coord_y + 30
	FCV_COORD_Y = FCV_COORD_Y + 30;

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::Print(.texte3, coord_x, coord_y, 2, 1)
	FCD_0ee11_gLCD_ILI9341__Print(FCL_TEXTE3, FCLsz_TEXTE3, FCV_COORD_X, FCV_COORD_Y, 2, 1);

	// Name: Calculation, Type: Calculation:
	// coord_y = coord_y + 30
	FCV_COORD_Y = FCV_COORD_Y + 30;

	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::Print(.texte4, coord_x, coord_y, 2, 1)
	FCD_0ee11_gLCD_ILI9341__Print(FCL_TEXTE4, FCLsz_TEXTE4, FCV_COORD_X, FCV_COORD_Y, 2, 1);

	//Local variable definitions
#undef FCLsz_TEXTE1
	#undef FCL_TEXTE1
#undef FCLsz_TEXTE2
	#undef FCL_TEXTE2
#undef FCLsz_TEXTE3
	#undef FCL_TEXTE3
#undef FCLsz_TEXTE4
	#undef FCL_TEXTE4
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_drawMenu()
{

	// Name: Call Macro, Type: Call Macro: drawMenuBar()
	FCM_drawMenuBar();

	// Name: Call Macro, Type: Call Macro: drawMenuList()
	FCM_drawMenuList();

}



/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
ADCON1 = 0x07;

OPTION_REG = 0xC0;


	// Name: Call Component Macro, Type: Call Component Macro: gLCD_ILI9341::Initialise()
	FCD_0ee11_gLCD_ILI9341__Initialise();

	// Name: Call Macro, Type: Call Macro: drawMenu()
	FCM_drawMenu();

	// Name: Loop, Type: Loop: While 1
	while (1)
	{


	}

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

}




