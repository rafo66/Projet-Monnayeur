
# 1 "test ecran 2.c"

# 26 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\htc.h"
extern const char __xc8_OPTIM_SPEED;

extern double __fpnormalize(double);


# 13 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 50 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\pic16f874.h"
extern volatile unsigned char INDF @ 0x000;

asm("INDF equ 00h");




extern volatile unsigned char TMR0 @ 0x001;

asm("TMR0 equ 01h");




extern volatile unsigned char PCL @ 0x002;

asm("PCL equ 02h");




extern volatile unsigned char STATUS @ 0x003;

asm("STATUS equ 03h");


typedef union {
struct {
unsigned C :1;
unsigned DC :1;
unsigned Z :1;
unsigned nPD :1;
unsigned nTO :1;
unsigned RP :2;
unsigned IRP :1;
};
struct {
unsigned :5;
unsigned RP0 :1;
unsigned RP1 :1;
};
struct {
unsigned CARRY :1;
unsigned :1;
unsigned ZERO :1;
};
} STATUSbits_t;
extern volatile STATUSbits_t STATUSbits @ 0x003;

# 157
extern volatile unsigned char FSR @ 0x004;

asm("FSR equ 04h");




extern volatile unsigned char PORTA @ 0x005;

asm("PORTA equ 05h");


typedef union {
struct {
unsigned RA0 :1;
unsigned RA1 :1;
unsigned RA2 :1;
unsigned RA3 :1;
unsigned RA4 :1;
unsigned RA5 :1;
};
} PORTAbits_t;
extern volatile PORTAbits_t PORTAbits @ 0x005;

# 214
extern volatile unsigned char PORTB @ 0x006;

asm("PORTB equ 06h");


typedef union {
struct {
unsigned RB0 :1;
unsigned RB1 :1;
unsigned RB2 :1;
unsigned RB3 :1;
unsigned RB4 :1;
unsigned RB5 :1;
unsigned RB6 :1;
unsigned RB7 :1;
};
} PORTBbits_t;
extern volatile PORTBbits_t PORTBbits @ 0x006;

# 276
extern volatile unsigned char PORTC @ 0x007;

asm("PORTC equ 07h");


typedef union {
struct {
unsigned RC0 :1;
unsigned RC1 :1;
unsigned RC2 :1;
unsigned RC3 :1;
unsigned RC4 :1;
unsigned RC5 :1;
unsigned RC6 :1;
unsigned RC7 :1;
};
} PORTCbits_t;
extern volatile PORTCbits_t PORTCbits @ 0x007;

# 338
extern volatile unsigned char PORTD @ 0x008;

asm("PORTD equ 08h");


typedef union {
struct {
unsigned RD0 :1;
unsigned RD1 :1;
unsigned RD2 :1;
unsigned RD3 :1;
unsigned RD4 :1;
unsigned RD5 :1;
unsigned RD6 :1;
unsigned RD7 :1;
};
} PORTDbits_t;
extern volatile PORTDbits_t PORTDbits @ 0x008;

# 400
extern volatile unsigned char PORTE @ 0x009;

asm("PORTE equ 09h");


typedef union {
struct {
unsigned RE0 :1;
unsigned RE1 :1;
unsigned RE2 :1;
};
} PORTEbits_t;
extern volatile PORTEbits_t PORTEbits @ 0x009;

# 432
extern volatile unsigned char PCLATH @ 0x00A;

asm("PCLATH equ 0Ah");


typedef union {
struct {
unsigned PCLATH :5;
};
} PCLATHbits_t;
extern volatile PCLATHbits_t PCLATHbits @ 0x00A;

# 452
extern volatile unsigned char INTCON @ 0x00B;

asm("INTCON equ 0Bh");


typedef union {
struct {
unsigned RBIF :1;
unsigned INTF :1;
unsigned T0IF :1;
unsigned RBIE :1;
unsigned INTE :1;
unsigned T0IE :1;
unsigned PEIE :1;
unsigned GIE :1;
};
struct {
unsigned :2;
unsigned TMR0IF :1;
unsigned :2;
unsigned TMR0IE :1;
};
} INTCONbits_t;
extern volatile INTCONbits_t INTCONbits @ 0x00B;

# 530
extern volatile unsigned char PIR1 @ 0x00C;

asm("PIR1 equ 0Ch");


typedef union {
struct {
unsigned TMR1IF :1;
unsigned TMR2IF :1;
unsigned CCP1IF :1;
unsigned SSPIF :1;
unsigned TXIF :1;
unsigned RCIF :1;
unsigned ADIF :1;
unsigned PSPIF :1;
};
} PIR1bits_t;
extern volatile PIR1bits_t PIR1bits @ 0x00C;

# 592
extern volatile unsigned char PIR2 @ 0x00D;

asm("PIR2 equ 0Dh");


typedef union {
struct {
unsigned CCP2IF :1;
unsigned :2;
unsigned BCLIF :1;
unsigned EEIF :1;
};
} PIR2bits_t;
extern volatile PIR2bits_t PIR2bits @ 0x00D;

# 625
extern volatile unsigned short TMR1 @ 0x00E;

asm("TMR1 equ 0Eh");




extern volatile unsigned char TMR1L @ 0x00E;

asm("TMR1L equ 0Eh");




extern volatile unsigned char TMR1H @ 0x00F;

asm("TMR1H equ 0Fh");




extern volatile unsigned char T1CON @ 0x010;

asm("T1CON equ 010h");


typedef union {
struct {
unsigned TMR1ON :1;
unsigned TMR1CS :1;
unsigned nT1SYNC :1;
unsigned T1OSCEN :1;
unsigned T1CKPS :2;
};
struct {
unsigned :4;
unsigned T1CKPS0 :1;
unsigned T1CKPS1 :1;
};
struct {
unsigned :2;
unsigned T1INSYNC :1;
};
struct {
unsigned :2;
unsigned T1SYNC :1;
};
} T1CONbits_t;
extern volatile T1CONbits_t T1CONbits @ 0x010;

# 723
extern volatile unsigned char TMR2 @ 0x011;

asm("TMR2 equ 011h");




extern volatile unsigned char T2CON @ 0x012;

asm("T2CON equ 012h");


typedef union {
struct {
unsigned T2CKPS :2;
unsigned TMR2ON :1;
unsigned TOUTPS :4;
};
struct {
unsigned T2CKPS0 :1;
unsigned T2CKPS1 :1;
unsigned :1;
unsigned TOUTPS0 :1;
unsigned TOUTPS1 :1;
unsigned TOUTPS2 :1;
unsigned TOUTPS3 :1;
};
} T2CONbits_t;
extern volatile T2CONbits_t T2CONbits @ 0x012;

# 801
extern volatile unsigned char SSPBUF @ 0x013;

asm("SSPBUF equ 013h");




extern volatile unsigned char SSPCON @ 0x014;

asm("SSPCON equ 014h");


typedef union {
struct {
unsigned SSPM :4;
unsigned CKP :1;
unsigned SSPEN :1;
unsigned SSPOV :1;
unsigned WCOL :1;
};
struct {
unsigned SSPM0 :1;
unsigned SSPM1 :1;
unsigned SSPM2 :1;
unsigned SSPM3 :1;
};
} SSPCONbits_t;
extern volatile SSPCONbits_t SSPCONbits @ 0x014;

# 878
extern volatile unsigned short CCPR1 @ 0x015;

asm("CCPR1 equ 015h");




extern volatile unsigned char CCPR1L @ 0x015;

asm("CCPR1L equ 015h");




extern volatile unsigned char CCPR1H @ 0x016;

asm("CCPR1H equ 016h");




extern volatile unsigned char CCP1CON @ 0x017;

asm("CCP1CON equ 017h");


typedef union {
struct {
unsigned CCP1M :4;
unsigned CCP1Y :1;
unsigned CCP1X :1;
};
struct {
unsigned CCP1M0 :1;
unsigned CCP1M1 :1;
unsigned CCP1M2 :1;
unsigned CCP1M3 :1;
};
} CCP1CONbits_t;
extern volatile CCP1CONbits_t CCP1CONbits @ 0x017;

# 957
extern volatile unsigned char RCSTA @ 0x018;

asm("RCSTA equ 018h");


typedef union {
struct {
unsigned RX9D :1;
unsigned OERR :1;
unsigned FERR :1;
unsigned ADDEN :1;
unsigned CREN :1;
unsigned SREN :1;
unsigned RX9 :1;
unsigned SPEN :1;
};
struct {
unsigned RCD8 :1;
unsigned :5;
unsigned RC9 :1;
};
struct {
unsigned :6;
unsigned nRC8 :1;
};
struct {
unsigned :6;
unsigned RC8_9 :1;
};
} RCSTAbits_t;
extern volatile RCSTAbits_t RCSTAbits @ 0x018;

# 1052
extern volatile unsigned char TXREG @ 0x019;

asm("TXREG equ 019h");




extern volatile unsigned char RCREG @ 0x01A;

asm("RCREG equ 01Ah");




extern volatile unsigned short CCPR2 @ 0x01B;

asm("CCPR2 equ 01Bh");




extern volatile unsigned char CCPR2L @ 0x01B;

asm("CCPR2L equ 01Bh");




extern volatile unsigned char CCPR2H @ 0x01C;

asm("CCPR2H equ 01Ch");




extern volatile unsigned char CCP2CON @ 0x01D;

asm("CCP2CON equ 01Dh");


typedef union {
struct {
unsigned CCP2M :4;
unsigned CCP2Y :1;
unsigned CCP2X :1;
};
struct {
unsigned CCP2M0 :1;
unsigned CCP2M1 :1;
unsigned CCP2M2 :1;
unsigned CCP2M3 :1;
};
} CCP2CONbits_t;
extern volatile CCP2CONbits_t CCP2CONbits @ 0x01D;

# 1145
extern volatile unsigned char ADRESH @ 0x01E;

asm("ADRESH equ 01Eh");




extern volatile unsigned char ADCON0 @ 0x01F;

asm("ADCON0 equ 01Fh");


typedef union {
struct {
unsigned ADON :1;
unsigned :1;
unsigned GO_nDONE :1;
unsigned CHS :3;
unsigned ADCS :2;
};
struct {
unsigned :2;
unsigned GO :1;
unsigned CHS0 :1;
unsigned CHS1 :1;
unsigned CHS2 :1;
unsigned ADCS0 :1;
unsigned ADCS1 :1;
};
struct {
unsigned :2;
unsigned nDONE :1;
};
struct {
unsigned :2;
unsigned GO_DONE :1;
};
} ADCON0bits_t;
extern volatile ADCON0bits_t ADCON0bits @ 0x01F;

# 1248
extern volatile unsigned char OPTION_REG @ 0x081;

asm("OPTION_REG equ 081h");


typedef union {
struct {
unsigned PS :3;
unsigned PSA :1;
unsigned T0SE :1;
unsigned T0CS :1;
unsigned INTEDG :1;
unsigned nRBPU :1;
};
struct {
unsigned PS0 :1;
unsigned PS1 :1;
unsigned PS2 :1;
};
} OPTION_REGbits_t;
extern volatile OPTION_REGbits_t OPTION_REGbits @ 0x081;

# 1318
extern volatile unsigned char TRISA @ 0x085;

asm("TRISA equ 085h");


typedef union {
struct {
unsigned TRISA0 :1;
unsigned TRISA1 :1;
unsigned TRISA2 :1;
unsigned TRISA3 :1;
unsigned TRISA4 :1;
unsigned TRISA5 :1;
};
} TRISAbits_t;
extern volatile TRISAbits_t TRISAbits @ 0x085;

# 1368
extern volatile unsigned char TRISB @ 0x086;

asm("TRISB equ 086h");


typedef union {
struct {
unsigned TRISB0 :1;
unsigned TRISB1 :1;
unsigned TRISB2 :1;
unsigned TRISB3 :1;
unsigned TRISB4 :1;
unsigned TRISB5 :1;
unsigned TRISB6 :1;
unsigned TRISB7 :1;
};
} TRISBbits_t;
extern volatile TRISBbits_t TRISBbits @ 0x086;

# 1430
extern volatile unsigned char TRISC @ 0x087;

asm("TRISC equ 087h");


typedef union {
struct {
unsigned TRISC0 :1;
unsigned TRISC1 :1;
unsigned TRISC2 :1;
unsigned TRISC3 :1;
unsigned TRISC4 :1;
unsigned TRISC5 :1;
unsigned TRISC6 :1;
unsigned TRISC7 :1;
};
} TRISCbits_t;
extern volatile TRISCbits_t TRISCbits @ 0x087;

# 1492
extern volatile unsigned char TRISD @ 0x088;

asm("TRISD equ 088h");


typedef union {
struct {
unsigned TRISD0 :1;
unsigned TRISD1 :1;
unsigned TRISD2 :1;
unsigned TRISD3 :1;
unsigned TRISD4 :1;
unsigned TRISD5 :1;
unsigned TRISD6 :1;
unsigned TRISD7 :1;
};
} TRISDbits_t;
extern volatile TRISDbits_t TRISDbits @ 0x088;

# 1554
extern volatile unsigned char TRISE @ 0x089;

asm("TRISE equ 089h");


typedef union {
struct {
unsigned TRISE0 :1;
unsigned TRISE1 :1;
unsigned TRISE2 :1;
unsigned :1;
unsigned PSPMODE :1;
unsigned IBOV :1;
unsigned OBF :1;
unsigned IBF :1;
};
} TRISEbits_t;
extern volatile TRISEbits_t TRISEbits @ 0x089;

# 1611
extern volatile unsigned char PIE1 @ 0x08C;

asm("PIE1 equ 08Ch");


typedef union {
struct {
unsigned TMR1IE :1;
unsigned TMR2IE :1;
unsigned CCP1IE :1;
unsigned SSPIE :1;
unsigned TXIE :1;
unsigned RCIE :1;
unsigned ADIE :1;
unsigned PSPIE :1;
};
} PIE1bits_t;
extern volatile PIE1bits_t PIE1bits @ 0x08C;

# 1673
extern volatile unsigned char PIE2 @ 0x08D;

asm("PIE2 equ 08Dh");


typedef union {
struct {
unsigned CCP2IE :1;
unsigned :2;
unsigned BCLIE :1;
unsigned EEIE :1;
};
} PIE2bits_t;
extern volatile PIE2bits_t PIE2bits @ 0x08D;

# 1706
extern volatile unsigned char PCON @ 0x08E;

asm("PCON equ 08Eh");


typedef union {
struct {
unsigned nBOR :1;
unsigned nPOR :1;
};
struct {
unsigned nBO :1;
};
} PCONbits_t;
extern volatile PCONbits_t PCONbits @ 0x08E;

# 1740
extern volatile unsigned char SSPCON2 @ 0x091;

asm("SSPCON2 equ 091h");


typedef union {
struct {
unsigned SEN :1;
unsigned RSEN :1;
unsigned PEN :1;
unsigned RCEN :1;
unsigned ACKEN :1;
unsigned ACKDT :1;
unsigned ACKSTAT :1;
unsigned GCEN :1;
};
} SSPCON2bits_t;
extern volatile SSPCON2bits_t SSPCON2bits @ 0x091;

# 1802
extern volatile unsigned char PR2 @ 0x092;

asm("PR2 equ 092h");




extern volatile unsigned char SSPADD @ 0x093;

asm("SSPADD equ 093h");




extern volatile unsigned char SSPSTAT @ 0x094;

asm("SSPSTAT equ 094h");


typedef union {
struct {
unsigned BF :1;
unsigned UA :1;
unsigned R_nW :1;
unsigned S :1;
unsigned P :1;
unsigned D_nA :1;
unsigned CKE :1;
unsigned SMP :1;
};
struct {
unsigned :2;
unsigned R :1;
unsigned :2;
unsigned D :1;
};
struct {
unsigned :2;
unsigned I2C_READ :1;
unsigned I2C_START :1;
unsigned I2C_STOP :1;
unsigned I2C_DATA :1;
};
struct {
unsigned :2;
unsigned nW :1;
unsigned :2;
unsigned nA :1;
};
struct {
unsigned :2;
unsigned nWRITE :1;
unsigned :2;
unsigned nADDRESS :1;
};
struct {
unsigned :2;
unsigned R_W :1;
unsigned :2;
unsigned D_A :1;
};
struct {
unsigned :2;
unsigned READ_WRITE :1;
unsigned :2;
unsigned DATA_ADDRESS :1;
};
} SSPSTATbits_t;
extern volatile SSPSTATbits_t SSPSTATbits @ 0x094;

# 1985
extern volatile unsigned char TXSTA @ 0x098;

asm("TXSTA equ 098h");


typedef union {
struct {
unsigned TX9D :1;
unsigned TRMT :1;
unsigned BRGH :1;
unsigned :1;
unsigned SYNC :1;
unsigned TXEN :1;
unsigned TX9 :1;
unsigned CSRC :1;
};
struct {
unsigned TXD8 :1;
unsigned :5;
unsigned nTX8 :1;
};
struct {
unsigned :6;
unsigned TX8_9 :1;
};
} TXSTAbits_t;
extern volatile TXSTAbits_t TXSTAbits @ 0x098;

# 2066
extern volatile unsigned char SPBRG @ 0x099;

asm("SPBRG equ 099h");




extern volatile unsigned char ADRESL @ 0x09E;

asm("ADRESL equ 09Eh");




extern volatile unsigned char ADCON1 @ 0x09F;

asm("ADCON1 equ 09Fh");


typedef union {
struct {
unsigned PCFG :4;
unsigned :3;
unsigned ADFM :1;
};
struct {
unsigned PCFG0 :1;
unsigned PCFG1 :1;
unsigned PCFG2 :1;
unsigned PCFG3 :1;
};
} ADCON1bits_t;
extern volatile ADCON1bits_t ADCON1bits @ 0x09F;

# 2133
extern volatile unsigned char EEDATA @ 0x10C;

asm("EEDATA equ 010Ch");




extern volatile unsigned char EEADR @ 0x10D;

asm("EEADR equ 010Dh");




extern volatile unsigned char EEDATH @ 0x10E;

asm("EEDATH equ 010Eh");




extern volatile unsigned char EEADRH @ 0x10F;

asm("EEADRH equ 010Fh");




extern volatile unsigned char EECON1 @ 0x18C;

asm("EECON1 equ 018Ch");


typedef union {
struct {
unsigned RD :1;
unsigned WR :1;
unsigned WREN :1;
unsigned WRERR :1;
unsigned :3;
unsigned EEPGD :1;
};
} EECON1bits_t;
extern volatile EECON1bits_t EECON1bits @ 0x18C;

# 2206
extern volatile unsigned char EECON2 @ 0x18D;

asm("EECON2 equ 018Dh");

# 2218
extern volatile __bit ACKDT @ (((unsigned) &SSPCON2)*8) + 5;

extern volatile __bit ACKEN @ (((unsigned) &SSPCON2)*8) + 4;

extern volatile __bit ACKSTAT @ (((unsigned) &SSPCON2)*8) + 6;

extern volatile __bit ADCS0 @ (((unsigned) &ADCON0)*8) + 6;

extern volatile __bit ADCS1 @ (((unsigned) &ADCON0)*8) + 7;

extern volatile __bit ADDEN @ (((unsigned) &RCSTA)*8) + 3;

extern volatile __bit ADFM @ (((unsigned) &ADCON1)*8) + 7;

extern volatile __bit ADIE @ (((unsigned) &PIE1)*8) + 6;

extern volatile __bit ADIF @ (((unsigned) &PIR1)*8) + 6;

extern volatile __bit ADON @ (((unsigned) &ADCON0)*8) + 0;

extern volatile __bit BCLIE @ (((unsigned) &PIE2)*8) + 3;

extern volatile __bit BCLIF @ (((unsigned) &PIR2)*8) + 3;

extern volatile __bit BF @ (((unsigned) &SSPSTAT)*8) + 0;

extern volatile __bit BRGH @ (((unsigned) &TXSTA)*8) + 2;

extern volatile __bit CARRY @ (((unsigned) &STATUS)*8) + 0;

extern volatile __bit CCP1IE @ (((unsigned) &PIE1)*8) + 2;

extern volatile __bit CCP1IF @ (((unsigned) &PIR1)*8) + 2;

extern volatile __bit CCP1M0 @ (((unsigned) &CCP1CON)*8) + 0;

extern volatile __bit CCP1M1 @ (((unsigned) &CCP1CON)*8) + 1;

extern volatile __bit CCP1M2 @ (((unsigned) &CCP1CON)*8) + 2;

extern volatile __bit CCP1M3 @ (((unsigned) &CCP1CON)*8) + 3;

extern volatile __bit CCP1X @ (((unsigned) &CCP1CON)*8) + 5;

extern volatile __bit CCP1Y @ (((unsigned) &CCP1CON)*8) + 4;

extern volatile __bit CCP2IE @ (((unsigned) &PIE2)*8) + 0;

extern volatile __bit CCP2IF @ (((unsigned) &PIR2)*8) + 0;

extern volatile __bit CCP2M0 @ (((unsigned) &CCP2CON)*8) + 0;

extern volatile __bit CCP2M1 @ (((unsigned) &CCP2CON)*8) + 1;

extern volatile __bit CCP2M2 @ (((unsigned) &CCP2CON)*8) + 2;

extern volatile __bit CCP2M3 @ (((unsigned) &CCP2CON)*8) + 3;

extern volatile __bit CCP2X @ (((unsigned) &CCP2CON)*8) + 5;

extern volatile __bit CCP2Y @ (((unsigned) &CCP2CON)*8) + 4;

extern volatile __bit CHS0 @ (((unsigned) &ADCON0)*8) + 3;

extern volatile __bit CHS1 @ (((unsigned) &ADCON0)*8) + 4;

extern volatile __bit CHS2 @ (((unsigned) &ADCON0)*8) + 5;

extern volatile __bit CKE @ (((unsigned) &SSPSTAT)*8) + 6;

extern volatile __bit CKP @ (((unsigned) &SSPCON)*8) + 4;

extern volatile __bit CREN @ (((unsigned) &RCSTA)*8) + 4;

extern volatile __bit CSRC @ (((unsigned) &TXSTA)*8) + 7;

extern volatile __bit DATA_ADDRESS @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit DC @ (((unsigned) &STATUS)*8) + 1;

extern volatile __bit D_A @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit D_nA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit EEIE @ (((unsigned) &PIE2)*8) + 4;

extern volatile __bit EEIF @ (((unsigned) &PIR2)*8) + 4;

extern volatile __bit EEPGD @ (((unsigned) &EECON1)*8) + 7;

extern volatile __bit FERR @ (((unsigned) &RCSTA)*8) + 2;

extern volatile __bit GCEN @ (((unsigned) &SSPCON2)*8) + 7;

extern volatile __bit GIE @ (((unsigned) &INTCON)*8) + 7;

extern volatile __bit GO @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit GO_DONE @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit GO_nDONE @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit I2C_DATA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit I2C_READ @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit I2C_START @ (((unsigned) &SSPSTAT)*8) + 3;

extern volatile __bit I2C_STOP @ (((unsigned) &SSPSTAT)*8) + 4;

extern volatile __bit IBF @ (((unsigned) &TRISE)*8) + 7;

extern volatile __bit IBOV @ (((unsigned) &TRISE)*8) + 5;

extern volatile __bit INTE @ (((unsigned) &INTCON)*8) + 4;

extern volatile __bit INTEDG @ (((unsigned) &OPTION_REG)*8) + 6;

extern volatile __bit INTF @ (((unsigned) &INTCON)*8) + 1;

extern volatile __bit IRP @ (((unsigned) &STATUS)*8) + 7;

extern volatile __bit OBF @ (((unsigned) &TRISE)*8) + 6;

extern volatile __bit OERR @ (((unsigned) &RCSTA)*8) + 1;

extern volatile __bit PCFG0 @ (((unsigned) &ADCON1)*8) + 0;

extern volatile __bit PCFG1 @ (((unsigned) &ADCON1)*8) + 1;

extern volatile __bit PCFG2 @ (((unsigned) &ADCON1)*8) + 2;

extern volatile __bit PCFG3 @ (((unsigned) &ADCON1)*8) + 3;

extern volatile __bit PEIE @ (((unsigned) &INTCON)*8) + 6;

extern volatile __bit PEN @ (((unsigned) &SSPCON2)*8) + 2;

extern volatile __bit PS0 @ (((unsigned) &OPTION_REG)*8) + 0;

extern volatile __bit PS1 @ (((unsigned) &OPTION_REG)*8) + 1;

extern volatile __bit PS2 @ (((unsigned) &OPTION_REG)*8) + 2;

extern volatile __bit PSA @ (((unsigned) &OPTION_REG)*8) + 3;

extern volatile __bit PSPIE @ (((unsigned) &PIE1)*8) + 7;

extern volatile __bit PSPIF @ (((unsigned) &PIR1)*8) + 7;

extern volatile __bit PSPMODE @ (((unsigned) &TRISE)*8) + 4;

extern volatile __bit RA0 @ (((unsigned) &PORTA)*8) + 0;

extern volatile __bit RA1 @ (((unsigned) &PORTA)*8) + 1;

extern volatile __bit RA2 @ (((unsigned) &PORTA)*8) + 2;

extern volatile __bit RA3 @ (((unsigned) &PORTA)*8) + 3;

extern volatile __bit RA4 @ (((unsigned) &PORTA)*8) + 4;

extern volatile __bit RA5 @ (((unsigned) &PORTA)*8) + 5;

extern volatile __bit RB0 @ (((unsigned) &PORTB)*8) + 0;

extern volatile __bit RB1 @ (((unsigned) &PORTB)*8) + 1;

extern volatile __bit RB2 @ (((unsigned) &PORTB)*8) + 2;

extern volatile __bit RB3 @ (((unsigned) &PORTB)*8) + 3;

extern volatile __bit RB4 @ (((unsigned) &PORTB)*8) + 4;

extern volatile __bit RB5 @ (((unsigned) &PORTB)*8) + 5;

extern volatile __bit RB6 @ (((unsigned) &PORTB)*8) + 6;

extern volatile __bit RB7 @ (((unsigned) &PORTB)*8) + 7;

extern volatile __bit RBIE @ (((unsigned) &INTCON)*8) + 3;

extern volatile __bit RBIF @ (((unsigned) &INTCON)*8) + 0;

extern volatile __bit RC0 @ (((unsigned) &PORTC)*8) + 0;

extern volatile __bit RC1 @ (((unsigned) &PORTC)*8) + 1;

extern volatile __bit RC2 @ (((unsigned) &PORTC)*8) + 2;

extern volatile __bit RC3 @ (((unsigned) &PORTC)*8) + 3;

extern volatile __bit RC4 @ (((unsigned) &PORTC)*8) + 4;

extern volatile __bit RC5 @ (((unsigned) &PORTC)*8) + 5;

extern volatile __bit RC6 @ (((unsigned) &PORTC)*8) + 6;

extern volatile __bit RC7 @ (((unsigned) &PORTC)*8) + 7;

extern volatile __bit RC8_9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RC9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RCD8 @ (((unsigned) &RCSTA)*8) + 0;

extern volatile __bit RCEN @ (((unsigned) &SSPCON2)*8) + 3;

extern volatile __bit RCIE @ (((unsigned) &PIE1)*8) + 5;

extern volatile __bit RCIF @ (((unsigned) &PIR1)*8) + 5;

extern volatile __bit RD @ (((unsigned) &EECON1)*8) + 0;

extern volatile __bit RD0 @ (((unsigned) &PORTD)*8) + 0;

extern volatile __bit RD1 @ (((unsigned) &PORTD)*8) + 1;

extern volatile __bit RD2 @ (((unsigned) &PORTD)*8) + 2;

extern volatile __bit RD3 @ (((unsigned) &PORTD)*8) + 3;

extern volatile __bit RD4 @ (((unsigned) &PORTD)*8) + 4;

extern volatile __bit RD5 @ (((unsigned) &PORTD)*8) + 5;

extern volatile __bit RD6 @ (((unsigned) &PORTD)*8) + 6;

extern volatile __bit RD7 @ (((unsigned) &PORTD)*8) + 7;

extern volatile __bit RE0 @ (((unsigned) &PORTE)*8) + 0;

extern volatile __bit RE1 @ (((unsigned) &PORTE)*8) + 1;

extern volatile __bit RE2 @ (((unsigned) &PORTE)*8) + 2;

extern volatile __bit READ_WRITE @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit RP0 @ (((unsigned) &STATUS)*8) + 5;

extern volatile __bit RP1 @ (((unsigned) &STATUS)*8) + 6;

extern volatile __bit RSEN @ (((unsigned) &SSPCON2)*8) + 1;

extern volatile __bit RX9 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit RX9D @ (((unsigned) &RCSTA)*8) + 0;

extern volatile __bit R_W @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit R_nW @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit SEN @ (((unsigned) &SSPCON2)*8) + 0;

extern volatile __bit SMP @ (((unsigned) &SSPSTAT)*8) + 7;

extern volatile __bit SPEN @ (((unsigned) &RCSTA)*8) + 7;

extern volatile __bit SREN @ (((unsigned) &RCSTA)*8) + 5;

extern volatile __bit SSPEN @ (((unsigned) &SSPCON)*8) + 5;

extern volatile __bit SSPIE @ (((unsigned) &PIE1)*8) + 3;

extern volatile __bit SSPIF @ (((unsigned) &PIR1)*8) + 3;

extern volatile __bit SSPM0 @ (((unsigned) &SSPCON)*8) + 0;

extern volatile __bit SSPM1 @ (((unsigned) &SSPCON)*8) + 1;

extern volatile __bit SSPM2 @ (((unsigned) &SSPCON)*8) + 2;

extern volatile __bit SSPM3 @ (((unsigned) &SSPCON)*8) + 3;

extern volatile __bit SSPOV @ (((unsigned) &SSPCON)*8) + 6;

extern volatile __bit SYNC @ (((unsigned) &TXSTA)*8) + 4;

extern volatile __bit T0CS @ (((unsigned) &OPTION_REG)*8) + 5;

extern volatile __bit T0IE @ (((unsigned) &INTCON)*8) + 5;

extern volatile __bit T0IF @ (((unsigned) &INTCON)*8) + 2;

extern volatile __bit T0SE @ (((unsigned) &OPTION_REG)*8) + 4;

extern volatile __bit T1CKPS0 @ (((unsigned) &T1CON)*8) + 4;

extern volatile __bit T1CKPS1 @ (((unsigned) &T1CON)*8) + 5;

extern volatile __bit T1INSYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit T1OSCEN @ (((unsigned) &T1CON)*8) + 3;

extern volatile __bit T1SYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit T2CKPS0 @ (((unsigned) &T2CON)*8) + 0;

extern volatile __bit T2CKPS1 @ (((unsigned) &T2CON)*8) + 1;

extern volatile __bit TMR0IE @ (((unsigned) &INTCON)*8) + 5;

extern volatile __bit TMR0IF @ (((unsigned) &INTCON)*8) + 2;

extern volatile __bit TMR1CS @ (((unsigned) &T1CON)*8) + 1;

extern volatile __bit TMR1IE @ (((unsigned) &PIE1)*8) + 0;

extern volatile __bit TMR1IF @ (((unsigned) &PIR1)*8) + 0;

extern volatile __bit TMR1ON @ (((unsigned) &T1CON)*8) + 0;

extern volatile __bit TMR2IE @ (((unsigned) &PIE1)*8) + 1;

extern volatile __bit TMR2IF @ (((unsigned) &PIR1)*8) + 1;

extern volatile __bit TMR2ON @ (((unsigned) &T2CON)*8) + 2;

extern volatile __bit TOUTPS0 @ (((unsigned) &T2CON)*8) + 3;

extern volatile __bit TOUTPS1 @ (((unsigned) &T2CON)*8) + 4;

extern volatile __bit TOUTPS2 @ (((unsigned) &T2CON)*8) + 5;

extern volatile __bit TOUTPS3 @ (((unsigned) &T2CON)*8) + 6;

extern volatile __bit TRISA0 @ (((unsigned) &TRISA)*8) + 0;

extern volatile __bit TRISA1 @ (((unsigned) &TRISA)*8) + 1;

extern volatile __bit TRISA2 @ (((unsigned) &TRISA)*8) + 2;

extern volatile __bit TRISA3 @ (((unsigned) &TRISA)*8) + 3;

extern volatile __bit TRISA4 @ (((unsigned) &TRISA)*8) + 4;

extern volatile __bit TRISA5 @ (((unsigned) &TRISA)*8) + 5;

extern volatile __bit TRISB0 @ (((unsigned) &TRISB)*8) + 0;

extern volatile __bit TRISB1 @ (((unsigned) &TRISB)*8) + 1;

extern volatile __bit TRISB2 @ (((unsigned) &TRISB)*8) + 2;

extern volatile __bit TRISB3 @ (((unsigned) &TRISB)*8) + 3;

extern volatile __bit TRISB4 @ (((unsigned) &TRISB)*8) + 4;

extern volatile __bit TRISB5 @ (((unsigned) &TRISB)*8) + 5;

extern volatile __bit TRISB6 @ (((unsigned) &TRISB)*8) + 6;

extern volatile __bit TRISB7 @ (((unsigned) &TRISB)*8) + 7;

extern volatile __bit TRISC0 @ (((unsigned) &TRISC)*8) + 0;

extern volatile __bit TRISC1 @ (((unsigned) &TRISC)*8) + 1;

extern volatile __bit TRISC2 @ (((unsigned) &TRISC)*8) + 2;

extern volatile __bit TRISC3 @ (((unsigned) &TRISC)*8) + 3;

extern volatile __bit TRISC4 @ (((unsigned) &TRISC)*8) + 4;

extern volatile __bit TRISC5 @ (((unsigned) &TRISC)*8) + 5;

extern volatile __bit TRISC6 @ (((unsigned) &TRISC)*8) + 6;

extern volatile __bit TRISC7 @ (((unsigned) &TRISC)*8) + 7;

extern volatile __bit TRISD0 @ (((unsigned) &TRISD)*8) + 0;

extern volatile __bit TRISD1 @ (((unsigned) &TRISD)*8) + 1;

extern volatile __bit TRISD2 @ (((unsigned) &TRISD)*8) + 2;

extern volatile __bit TRISD3 @ (((unsigned) &TRISD)*8) + 3;

extern volatile __bit TRISD4 @ (((unsigned) &TRISD)*8) + 4;

extern volatile __bit TRISD5 @ (((unsigned) &TRISD)*8) + 5;

extern volatile __bit TRISD6 @ (((unsigned) &TRISD)*8) + 6;

extern volatile __bit TRISD7 @ (((unsigned) &TRISD)*8) + 7;

extern volatile __bit TRISE0 @ (((unsigned) &TRISE)*8) + 0;

extern volatile __bit TRISE1 @ (((unsigned) &TRISE)*8) + 1;

extern volatile __bit TRISE2 @ (((unsigned) &TRISE)*8) + 2;

extern volatile __bit TRMT @ (((unsigned) &TXSTA)*8) + 1;

extern volatile __bit TX8_9 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit TX9 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit TX9D @ (((unsigned) &TXSTA)*8) + 0;

extern volatile __bit TXD8 @ (((unsigned) &TXSTA)*8) + 0;

extern volatile __bit TXEN @ (((unsigned) &TXSTA)*8) + 5;

extern volatile __bit TXIE @ (((unsigned) &PIE1)*8) + 4;

extern volatile __bit TXIF @ (((unsigned) &PIR1)*8) + 4;

extern volatile __bit UA @ (((unsigned) &SSPSTAT)*8) + 1;

extern volatile __bit WCOL @ (((unsigned) &SSPCON)*8) + 7;

extern volatile __bit WR @ (((unsigned) &EECON1)*8) + 1;

extern volatile __bit WREN @ (((unsigned) &EECON1)*8) + 2;

extern volatile __bit WRERR @ (((unsigned) &EECON1)*8) + 3;

extern volatile __bit ZERO @ (((unsigned) &STATUS)*8) + 2;

extern volatile __bit nA @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit nADDRESS @ (((unsigned) &SSPSTAT)*8) + 5;

extern volatile __bit nBO @ (((unsigned) &PCON)*8) + 0;

extern volatile __bit nBOR @ (((unsigned) &PCON)*8) + 0;

extern volatile __bit nDONE @ (((unsigned) &ADCON0)*8) + 2;

extern volatile __bit nPD @ (((unsigned) &STATUS)*8) + 3;

extern volatile __bit nPOR @ (((unsigned) &PCON)*8) + 1;

extern volatile __bit nRBPU @ (((unsigned) &OPTION_REG)*8) + 7;

extern volatile __bit nRC8 @ (((unsigned) &RCSTA)*8) + 6;

extern volatile __bit nT1SYNC @ (((unsigned) &T1CON)*8) + 2;

extern volatile __bit nTO @ (((unsigned) &STATUS)*8) + 4;

extern volatile __bit nTX8 @ (((unsigned) &TXSTA)*8) + 6;

extern volatile __bit nW @ (((unsigned) &SSPSTAT)*8) + 2;

extern volatile __bit nWRITE @ (((unsigned) &SSPSTAT)*8) + 2;


# 28 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\pic.h"
#pragma intrinsic(__nop)
extern void __nop(void);

# 78
extern unsigned int flash_read(unsigned short addr);

# 114 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\eeprom_routines.h"
extern void eeprom_write(unsigned char addr, unsigned char value);
extern unsigned char eeprom_read(unsigned char addr);
extern void eecpymem(volatile unsigned char *to, __eeprom unsigned char *from, unsigned char size);
extern void memcpyee(__eeprom unsigned char *to, const unsigned char *from, unsigned char size);


# 152 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\pic.h"
#pragma intrinsic(_delay)
extern __nonreentrant void _delay(unsigned long);
#pragma intrinsic(_delaywdt)
extern __nonreentrant void _delaywdt(unsigned long);

# 193
extern __bank0 unsigned char __resetbits;
extern __bank0 __bit __powerdown;
extern __bank0 __bit __timeout;

# 30 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\math.h"
extern double fabs(double);
extern double floor(double);
extern double ceil(double);
extern double modf(double, double *);
extern double sqrt(double);
extern double atof(const char *);
extern double sin(double) ;
extern double cos(double) ;
extern double tan(double) ;
extern double asin(double) ;
extern double acos(double) ;
extern double atan(double);
extern double atan2(double, double) ;
extern double log(double);
extern double log10(double);
extern double pow(double, double) ;
extern double exp(double) ;
extern double sinh(double) ;
extern double cosh(double) ;
extern double tanh(double);
extern double eval_poly(double, const double *, int);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double fmod(double, double);
extern double trunc(double);
extern double round(double);

# 34 "test ecran 2.c"
__config("__PROG_CONFIG", "pic", 0x1, 0x3FF9);

# 76 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\internals.c"
unsigned char FCI_TMP_STR[20];
int FCI_TMP_INT;

# 46 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_TypeDefs.c"
typedef signed char MX_SINT8;
typedef signed short MX_SINT16;
typedef signed long MX_SINT32;
typedef unsigned char MX_UINT8;
typedef unsigned short MX_UINT16;
typedef unsigned long MX_UINT32;
typedef char MX_CHAR;
typedef MX_UINT16 MX_UINT;
typedef MX_SINT16 MX_SINT;




typedef MX_UINT8 MX_BOOL;

typedef double MX_FLOAT;




typedef union
{
MX_UINT32 AsLong;
MX_UINT16 AsInt[2];
MX_UINT8 AsByte[4];
} MX_Union32;

typedef union
{
MX_UINT16 AsInt;
MX_UINT8 AsByte[2];
} MX_Union16;

# 197 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_IO.c"
void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
{
*Port = (*Port & ~OutMask) | (OutValue & OutMask);
}


void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
{
*Tris = *Tris & (~OutMask);
*Port = (*Port & ~OutMask) | (OutValue & OutMask);
}


MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
{
return (*Port & InMask) >> Shift;
}


inline MX_UINT8 FC_CAL_Port_In_DDR__x (volatile MX_UINT8* Port,volatile MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
{
*Tris = *Tris | InMask;
return (*Port & InMask) >> Shift;
}

# 44 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_Delay.c"
void Wdt_Delay_S(MX_UINT8 delay);
void Wdt_Delay_Ms(MX_UINT8 delay);

# 57
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);




void delay_10us(MX_UINT8 del);
void delay_us(MX_UINT8 del);
void delay_ms(MX_UINT8 del);
void delay_s(MX_UINT8 del);



void delay_10us(MX_UINT8 del)
{
while (del--)
{
_delay((unsigned long)((10)*(4000000/4000000.0)));
}
}



void delay_us(MX_UINT8 del)
{
while (del > 99)
{
_delay((unsigned long)((100)*(4000000/4000000.0)));
del -= 100;
}
while (del > 9)
{
_delay((unsigned long)((10)*(4000000/4000000.0)));
del -= 10;
}
while (del--)
{
_delay((unsigned long)((1)*(4000000/4000000.0)));
}
}



void delay_ms(MX_UINT8 del)
{
while (del--)
{
_delay((unsigned long)((1)*(4000000/4000.0)));
}
}


void delay_s(MX_UINT8 del)
{
MX_UINT8 i;
for(i=0; i<del; i++)
{
delay_ms(250);
delay_ms(250);
delay_ms(250);
delay_ms(250);
}
}



void Wdt_Delay_S(MX_UINT8 delay)
{
MX_UINT8 i;
MX_UINT16 j;
for (i=0; i<delay; i++)
{
for (j=0; j<999; j++)
{
Wdt_Delay_Ms(1);
}
}
}

void Wdt_Delay_Ms(MX_UINT8 delay)
{
MX_UINT8 i;
for (i=0; i<delay; i++)
{
asm("clrwdt");
delay_ms(1);
}
}


void FCI_DELAYINT_US(MX_UINT16 Delay)
{
while (Delay > 255)
{
delay_us(255);
Delay = Delay - 255;
}
if (Delay > 0)
delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
while (Delay > 255)
{
delay_ms(255);
Delay = Delay - 255;
}
if (Delay > 0)
delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
while (Delay > 255)
{
Wdt_Delay_Ms(255);
Delay = Delay - 255;
}
if (Delay > 0)
Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
while (Delay > 255)
{
delay_s(255);
Delay = Delay - 255;
}
if (Delay > 0)
delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
while (Delay > 255)
{
Wdt_Delay_S(255);
Delay = Delay - 255;
}
if (Delay > 0)
Wdt_Delay_S(Delay & 0xFF);
}

# 93 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_String.c"
MX_UINT8 FCI_GETCHAR(unsigned char* sStr1, MX_UINT16 iStr1_len, MX_UINT16 iPos);
MX_UINT16 FCI_GETLENGTH(unsigned char* sStr1, MX_UINT16 iStr1_len);
unsigned char* FCI_MIDSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iStart, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len);
unsigned char* FCI_LEFTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len);
unsigned char* FCI_RIGHTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len);
unsigned char* FCI_TOSTRING(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len);

void FCI_TOLOWER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
void FCI_TOUPPER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_COMPARE(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, MX_UINT8 iNoCase);
unsigned char* FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, unsigned char* String, MX_UINT16 MSZ_String);
unsigned char* FCI_NUMBER_TO_HEX(MX_UINT32 Number, unsigned char* String, MX_UINT16 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(unsigned char* String, MX_UINT16 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(unsigned char* String, MX_UINT16 MSZ_String);


MX_UINT8 FCI_STRREV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
MX_UINT8 FCI_STRMOV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);
void FCI_SHEAD(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, unsigned char* sDst, MX_UINT16 iDst_len);
void FCI_SCOPY(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len);

# 4 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\__size_t.h"
typedef unsigned size_t;

# 7 "C:\PROGRA~2\Flowcode\Common\COMPIL~1\pic\include\stdlib.h"
typedef unsigned short wchar_t;

# 15
typedef struct {
int rem;
int quot;
} div_t;
typedef struct {
unsigned rem;
unsigned quot;
} udiv_t;
typedef struct {
long quot;
long rem;
} ldiv_t;
typedef struct {
unsigned long quot;
unsigned long rem;
} uldiv_t;

# 53
extern double atof(const char *);
extern double strtod(const char *, const char **);
extern int atoi(const char *);
extern unsigned xtoi(const char *);
extern long atol(const char *);
extern long strtol(const char *, char **, int);

extern int rand(void);
extern void srand(unsigned int);
extern void * calloc(size_t, size_t);
extern div_t div(int numer, int denom);
extern udiv_t udiv(unsigned numer, unsigned denom);
extern ldiv_t ldiv(long numer, long denom);
extern uldiv_t uldiv(unsigned long numer,unsigned long denom);
extern unsigned long _lrotl(unsigned long value, unsigned int shift);
extern unsigned long _lrotr(unsigned long value, unsigned int shift);
extern unsigned int _rotl(unsigned int value, unsigned int shift);
extern unsigned int _rotr(unsigned int value, unsigned int shift);




extern void * malloc(size_t);
extern void free(void *);
extern void * realloc(void *, size_t);

# 86
extern int atexit(void (*)(void));
extern char * getenv(const char *);
extern char ** environ;
extern int system(char *);
extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
extern void * bsearch(const void *, void *, size_t, size_t, int(*)(const void *, const void *));
extern int abs(int);
extern long labs(long);

extern char * itoa(char * buf, int val, int base);
extern char * utoa(char * buf, unsigned val, int base);




extern char * ltoa(char * buf, long val, int base);
extern char * ultoa(char * buf, unsigned long val, int base);

extern char * ftoa(float f, int * status);

# 124 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_String.c"
MX_UINT8 FCI_GETCHAR(unsigned char* sStr1, MX_UINT16 iStr1_len, MX_UINT16 iPos)
{
if(iPos < iStr1_len)
return sStr1[iPos];
return '\0';
}


MX_UINT16 FCI_GETLENGTH(unsigned char* sStr1, MX_UINT16 iStr1_len)
{
MX_UINT16 tmp;
for (tmp = 0; tmp < iStr1_len; tmp++) if (sStr1[tmp] == 0) break;
return (tmp);
}


unsigned char* FCI_MIDSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iStart, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return sDst;
MX_UINT16 idx;
for (idx = 0; idx < iSrc_len; idx++) if (sSrc[idx] == 0) break;

if (iStart >= idx)
{
sDst[0] = '\0';
}
else
{
if ((iStart + iCount) >= idx)
iCount = idx - iStart;
if (iCount > (iDst_len))
iCount = (iDst_len);

for (idx = 0; idx < iCount; idx++)
{
sDst[idx] = sSrc[idx + iStart];
}
if (idx < iDst_len)
{
sDst[idx] = '\0';
}
}
return (sDst);
}


unsigned char* FCI_LEFTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return sDst;
MX_UINT16 idx;
for (idx = 0; idx < iSrc_len; idx++) if (sSrc[idx] == 0) break;

if (iCount > idx)
iCount = idx;
if (iCount > (iDst_len))
iCount = (iDst_len);

for (idx = 0; idx < iCount; idx++)
{
sDst[idx] = sSrc[idx];
}

if (idx < iDst_len)
sDst[idx] = '\0';

return (sDst);
}


unsigned char* FCI_RIGHTSTRING(unsigned char* sSrc, MX_UINT16 iSrc_len, MX_UINT16 iCount, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return sDst;
MX_UINT16 idx;
MX_UINT16 delta;

for (idx = 0; idx < iSrc_len; idx++) if (sSrc[idx] == 0) break;

if (iCount > idx)
iCount = idx;

delta = idx - iCount;

if (iCount > (iDst_len))
iCount = (iDst_len);

for(idx = 0; idx < iCount; idx++)
{
sDst[idx] = sSrc[idx + delta];
}

if (idx < iDst_len)
sDst[idx] = '\0';

return (sDst);
}



MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_SINT16 iSrc = iSrc1;
MX_UINT16 top = 10000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;



if (iSrc < 0)
{
sDst[0] = '-';
idx++;
iSrc = -iSrc;
}

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_SINT32 iSrc = iSrc1;
MX_UINT32 top = 1000000000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;



if (iSrc < 0)
{
sDst[0] = '-';
idx++;
iSrc = -iSrc;
}

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned long)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned long)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_UINT16 iSrc = iSrc1;
MX_UINT16 top = 10000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;
MX_UINT32 iSrc = iSrc1;
MX_UINT32 top = 1000000000;
MX_UINT8 idx = 0;

if (iDst_len == 0) return 0;

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{
if (((unsigned long)iSrc >= top) || (tmp1))
{
tmp1 = (unsigned long)iSrc / top;
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (idx);
}



unsigned char* FCI_TOSTRING(MX_SINT32 iSrc1, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT8 tmp1;

MX_SINT32 iSrc = iSrc1;


unsigned long top = 1000000000;

# 389
MX_UINT8 idx = 0;

if (iDst_len == 0) return sDst;



if (iSrc < 0)
{
sDst[0] = '-';
idx++;
iSrc = -iSrc;
}

tmp1 = 0;
if (iSrc == 0)
{
tmp1 = 1;
top = 1;
}
while (( idx < iDst_len) && (top > 0))
{

if (((unsigned long)iSrc >= top) || (tmp1))

# 415
{

tmp1 = (unsigned long)iSrc / top;

# 421
sDst[idx] = '0' + tmp1;
idx++;
iSrc -= tmp1 * top;
tmp1 = 1;
}
top /= 10;
}

if (idx < iDst_len)
sDst[idx] = '\0';
return (sDst);
}


void FCI_TOLOWER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return;
MX_UINT16 idx;
MX_UINT16 ch;

if (iSrc_len < iDst_len) iSrc_len = iDst_len;

for (idx=0; idx<iSrc_len; idx++)
{
ch = sSrc[idx];
if ((ch >= 'A') && (ch <= 'Z'))
{
ch ^= 0x20;
}
sDst[idx] = ch;
if (ch == 0)
{
break;
}
}
if (idx < iDst_len)
sDst[idx] = '\0';
}


void FCI_TOUPPER(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
if (iDst_len == 0) return;
MX_UINT16 idx;
MX_UINT16 ch;

if (iSrc_len < iDst_len) iSrc_len = iDst_len;

for (idx=0; idx<iSrc_len; idx++)
{
ch = sSrc[idx];
if ((ch >= 'a') && (ch <= 'z'))
{
ch ^= 0x20;
}
sDst[idx] = ch;
if (ch == 0)
{
break;
}
}
if (idx < iDst_len)
sDst[idx] = '\0';
}


MX_UINT8 FCI_COMPARE(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, MX_UINT8 iNoCase)
{
MX_UINT16 idx = 0;
MX_UINT8 ch1, ch2;

while ((idx < iSrc1_len)&&(idx < iSrc2_len))
{
ch1 = sSrc1[idx];
ch2 = sSrc2[idx];

if (iNoCase)
{
if ((ch1 >= 'a') && (ch1 <= 'z'))
ch1 = (ch1 & 0xDF);

if ((ch2 >= 'a') && (ch2 <= 'z'))
ch2 = (ch2 & 0xDF);
}

if (ch2 == 0)
{
if (ch1 == 0)
return (0);
else
return (1);
}
else if (ch1 == 0)
return (255);
else if (ch1 < ch2)
return(255);
else if (ch1 > ch2)
return(1);

++idx;
}


if (iSrc1_len > iSrc2_len)
{
if (sSrc1[idx] == 0)
return (0);
else
return (1);
}
else if (iSrc1_len < iSrc2_len)
{
if (sSrc2[idx] == 0)
return (0);
else
return (255);
}
return (0);
}


unsigned char* FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, unsigned char* String, MX_UINT16 MSZ_String)
{
MX_SINT32 whole;
MX_UINT8 idx;
MX_UINT8 stringidx = 0;
MX_FLOAT temp = 0.5;
MX_FLOAT real;
MX_UINT8 temp_string[12];


for (idx = 0; idx < Precision; idx++) temp *= 0.1;

if (Number < 0)
{
Number = -Number;
String[stringidx++] = '-';
}
Number += temp;

temp = floor(Number);
whole = (MX_SINT32)temp;

real = Number - temp;

FCI_TOSTRING(whole, temp_string, sizeof(temp_string));

for (idx=0; temp_string[idx]; idx++)
{
if(stringidx < MSZ_String)
{
String[stringidx] = temp_string[idx];
stringidx = stringidx + 1;
}
}

if (Precision > 0)
{
if(stringidx < MSZ_String)
{
String[stringidx] = '.';
stringidx = stringidx + 1;
}

for (idx = 0; idx < Precision; idx++)
{
if (stringidx >= MSZ_String)
break;

real = real * 10;
whole = (MX_SINT32)real;
temp = (MX_FLOAT)whole;
real = real - temp;

String[stringidx] = '0' + whole;
stringidx = stringidx + 1;
}
}

if(stringidx < MSZ_String)
{
String[stringidx] = 0;
}

return String;
}




unsigned char* FCI_NUMBER_TO_HEX(MX_UINT32 Number, unsigned char* String, MX_UINT16 MSZ_String)
{
MX_UINT8 stringidx;
MX_UINT8 idx = 0;
MX_UINT8 temp;
MX_UINT8 digit[8];



MX_UINT32 num = Number;

# 625
String[0] = 0;


if(((Number >> 8) > 0xFF) && (MSZ_String < 10))
return String;

if((Number > 0xFF) && (MSZ_String < 6))
return String;

if((Number <= 0xFF) && (MSZ_String < 4))
return String;


String[0] = '0';
String[1] = 'x';


do
{
temp = num % 16;
num = num >> 4;

if(temp > 9)
{
temp = temp - 10;
digit[idx] = temp + 'A';
}
else
digit[idx] = temp + '0';

idx = idx + 1;
} while (num > 0);


if(idx == 1)
{
digit[1] = '0';
idx = 2;
}


for (stringidx = 2; stringidx < (idx + 2); stringidx++)
String[stringidx] = digit[idx - (stringidx - 1)];


if(stringidx < MSZ_String)
{
String[stringidx] = 0;
}

return String;
}




MX_SINT32 FCI_STRING_TO_INT(unsigned char* String, MX_UINT16 MSZ_String)
{
MX_UINT8 bNegative = 0;
MX_UINT8 idx = 0;
MX_SINT32 RetVal = 0;


while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
{

if(String[idx] == '-')
{
bNegative = 1;
idx = idx + 1;
break;
}
idx = idx + 1;
}


while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
{

RetVal = (long) RetVal * 10;
RetVal = (long) RetVal + (String[idx] - '0');
idx = idx + 1;
}

if (bNegative)
RetVal = (long) 0 - RetVal;

return RetVal;
}




MX_FLOAT FCI_STRING_TO_FLOAT(unsigned char* String, MX_UINT16 MSZ_String)
{
MX_FLOAT RetVal = 0;
MX_FLOAT real_divider = 1;
MX_UINT32 whole, real;
MX_UINT8 idx = 0;
MX_UINT8 idx2 = 0;
MX_UINT8 offset = 0;
MX_UINT8 bNegative = 0;
MX_UINT8 Comp_String[8];


if(String[0] == '-')
{
bNegative = 1;
offset = 1;
}


for(idx=offset; idx<MSZ_String; idx++)
{
if(String[idx] == '.')
break;
}


whole = FCI_STRING_TO_INT (String, idx);


if(idx == MSZ_String)
{
RetVal = (MX_FLOAT)whole;
return RetVal;
}


offset = idx + 1;
for(idx=offset; idx<MSZ_String; idx++)
{
if(String[idx] >= '0' && String[idx] <= '9')
{
Comp_String[idx - offset] = String[idx];
real_divider = real_divider * 0.1;
}
else
break;
}


real = FCI_STRING_TO_INT (Comp_String, (idx - offset));


RetVal = (MX_FLOAT)real;
RetVal = RetVal * real_divider;
real_divider = (MX_FLOAT)whole;
RetVal = RetVal + real_divider;

if (bNegative)
RetVal = -RetVal;

return RetVal;
}

# 788
MX_UINT8 FCI_STRREV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT16 ix, len;
for (len = 0; len < iSrc_len; len++) if (sSrc[len] == 0) break;
if (len > iDst_len)
{
len = iDst_len;
}
ix = len;
while (ix > 0)
{
ix--;
sDst[ix] = sSrc[ix];
}


return len;
}

# 812
MX_UINT8 FCI_STRMOV(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT16 ix;
ix = 0;
while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
{
sDst[ix] = sSrc[ix];
ix++;
}


return ix;
}

# 835
void FCI_SHEAD(unsigned char* sSrc1, MX_UINT16 iSrc1_len, unsigned char* sSrc2, MX_UINT16 iSrc2_len, unsigned char* sDst, MX_UINT16 iDst_len)
{

MX_UINT16 len, strt;

if ((MX_UINT16) sSrc2 == (MX_UINT16) sDst)
{
for (strt = 0; strt < iSrc1_len; strt++) if (sSrc1[strt] == 0) break;
if (strt < iDst_len)
{


for (len = 0; len < iSrc2_len; len++) if (sSrc2[len] == 0) break;
if (len > (iDst_len - strt))
{
len = (iDst_len - strt);
}
iSrc2_len = strt + len;
strt = len;
while (strt > 0)
{
strt--;
iSrc2_len--;
sDst[iSrc2_len] = sSrc2[strt];
}

for (strt = 0; strt < (iSrc1_len) && strt < (iDst_len) && sSrc1[strt] != '\0'; strt++) sDst[strt] = sSrc1[strt];
len += strt;
}
else
{

for (len = 0; len < (iSrc1_len) && len < (iDst_len) && sSrc1[len] != '\0'; len++) sDst[len] = sSrc1[len];
}
}
else
{

for (len = 0; len < (iSrc1_len) && len < (iDst_len) && sSrc1[len] != '\0'; len++) sDst[len] = sSrc1[len];

if (len < iDst_len)
{
unsigned char* temp_sSrc1 = sDst + len;
iSrc1_len = iDst_len - len;
for (strt = 0; strt < (iSrc2_len) && strt < (iSrc1_len) && sSrc2[strt] != '\0'; strt++) temp_sSrc1[strt] = sSrc2[strt];
len += strt;
}
}

if (len < iDst_len)
{
sDst[len] = '\0';
}
}

# 896
void FCI_SCOPY(unsigned char* sSrc, MX_UINT16 iSrc_len, unsigned char* sDst, MX_UINT16 iDst_len)
{
MX_UINT16 len;


for (len = 0; len < (iSrc_len) && len < (iDst_len) && sSrc[len] != '\0'; len++) sDst[len] = sSrc[len];

if (len < iDst_len)
{
sDst[len] = '\0';
}
}

# 44 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_Float.c"
char isinf(float f);

# 76
MX_SINT32 MX_Map(MX_SINT32 x, MX_SINT32 in_min, MX_SINT32 in_max, MX_SINT32 out_min, MX_SINT32 out_max);
MX_FLOAT MX_Map_Float(MX_FLOAT x, MX_FLOAT in_min, MX_FLOAT in_max, MX_FLOAT out_min, MX_FLOAT out_max);

MX_SINT32 MX_Map(MX_SINT32 x, MX_SINT32 in_min, MX_SINT32 in_max, MX_SINT32 out_min, MX_SINT32 out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

MX_FLOAT MX_Map_Float(MX_FLOAT x, MX_FLOAT in_min, MX_FLOAT in_max, MX_FLOAT out_min, MX_FLOAT out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}



char isinf(float f)
{
char* b;
b = (char*)&f;
if ((b[0] == 0) &&
(b[1] == 0) &&
(b[2] == 128) &&
((b[3] & 127) == 127))
{
return (255);
}
return (0);
}

# 120
inline signed long flt_cos_i(unsigned long Rads12)
{
unsigned long x, x2, x4, x6, x8, err;
signed int sgn;

x = Rads12;
if (x > 6433 && x <= 19301)
{
sgn = -1;
}
else
{
sgn = 1;
}
if (x > 12867)
{
x -= 12867;
}
if (x > 6433)
{
x = 12867 - x;
}

x2 = (x * x + 2047) >> 12;
x4 = (x2 * x2) >> 12;
x6 = (x4 * x2) >> 12;
x8 = (x4 * x4) >> 12;

x2 *= 360;
x4 *= 30;
x8 /= 90;
err = 250;
return ((signed long)((2949120L - x2 + x4 - x6 + x8 - err) * sgn) * 7) >> 1;
}

# 168
inline signed long flt_sin_i(unsigned long Rads12)
{
unsigned long x, x2, x3, x5, x7, x9, err;
signed int sgn;

x = Rads12;
if (x > 12867)
{
sgn = -1;
x -= 12867;
}
else
{
sgn = 1;
}
if (x > 6433)
{
x = 12867 - x;
}
x2 = (x * x + 2047) >> 12;
x3 = (x2 * x) >> 12;
x5 = (x3 * x2) >> 12;
x7 = (x5 * x2) >> 12;
x9 = (x7 * x2) >> 12;

x *= 2520;
x3 *= 420;
x5 *= 21;
x9 /= 36;
err = 2048;
return (signed long)(x - x3 + x5 - x7 + x9 + err) * sgn;
}

# 43 "test ecran 2.c"
MX_UINT8 FCLV_LOOP1;

# 53
volatile MX_UINT8 FCV_NOMBRE;
volatile MX_UINT8 FCV_COORD_Y;
volatile MX_UINT8 FCV_NOMBRE2;
volatile MX_UINT8 FCV_COORD_X;

# 106
volatile MX_UINT32 FCV_01531_cal_spi1__CONSOLELOG;

void FCD_01531_cal_spi1__Master_Enable_CS();
void FC_CAL_SPI_Slave_Uninit_1();
void FCD_01531_cal_spi1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_COLOUR, MX_UINT8 FCL_APPENDTIMESTAMP);
MX_UINT8 FC_CAL_SPI_Transaction_1(MX_UINT8 *FCL_BUFFER, MX_UINT16 FCLsz_BUFFER, MX_UINT16 FCL_LENGTH);
void FCD_01531_cal_spi1__Prv_SimShowWaveform(MX_UINT8 FCL_RXDATA, MX_UINT16 FCL_TXDATA);
void FC_CAL_SPI_Slave_Init_1();
void FCD_01531_cal_spi1__Master_Disable_CS();
void FC_CAL_SPI_Master_Uninit_1();
MX_UINT8 FC_CAL_SPI_Master_Byte_1(MX_UINT8 FCL_DATAOUT);
void FC_CAL_SPI_Slave_TxByte_1(MX_UINT8 FCL_DATA);
MX_UINT8 FC_CAL_SPI_Slave_RxByte_1();
void FC_CAL_SPI_SetPrescaler_1(MX_UINT8 FCL_PRESCALER);
MX_UINT8 FC_CAL_SPI_Master_Init_1();

# 132
const MX_UINT8 FCD_00fb1_ASCIIData__INTLIST_LUT [] =
{

0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8, 0, 224, 96, 0, 0,
8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16, 8, 4, 2, 62,
81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73, 73, 70, 34, 73,
73, 73, 54, 24, 20, 18, 127, 16, 39, 69, 69, 69, 57, 60, 74, 73,
73, 48, 1, 113, 9, 5, 3, 54, 73, 73, 73, 54, 6, 73, 73, 41,
30, 0, 108, 108, 0, 0, 0, 236, 108, 0, 0, 8, 20, 34, 65, 0,
36, 36, 36, 36, 36, 0, 65, 34, 20, 8, 2, 1, 89, 9, 6, 62,
65, 93, 85, 30, 126, 9, 9, 9, 126, 127, 73, 73, 73, 54, 62, 65,
65, 65, 34, 127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9,
9, 1, 62, 65, 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65,
0, 48, 64, 64, 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64,
127, 2, 4, 2, 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62, 127,
9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0, 2, 4, 8, 16, 32,
0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128, 128, 128, 128, 0,
3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68, 68, 56, 56, 68,
68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84, 24, 8, 126, 9,
9, 0, 24, 164, 164, 164, 124, 127, 4, 4, 120, 0, 0, 0, 125, 0,
0, 64, 128, 132, 125, 0, 127, 16, 40, 68, 0, 0, 0, 127, 64, 0,
124, 4, 24, 4, 120, 124, 4, 4, 120, 0, 56, 68, 68, 68, 56, 252,
68, 68, 68, 56, 56, 68, 68, 68, 252, 68, 120, 68, 4, 8, 8, 84,
84, 84, 32, 4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64,
32, 28, 60, 96, 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60,
0, 100, 84, 84, 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0,
0, 65, 65, 62, 8, 2, 1, 2, 1, 0


};

MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount();

# 176
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);

# 183
volatile MX_UINT16 FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR;
volatile MX_UINT16 FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR;
volatile MX_UINT8 FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION = (0x0);

void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOn();
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(MX_UINT8 FCL_DATA);
void FCD_0a2b1_gLCD_ILI9341_SPI1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(MX_UINT8 FCL_DATA);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0a2b1_gLCD_ILI9341_SPI1__FastPlot();
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOff();
void FCD_0a2b1_gLCD_ILI9341_SPI1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0a2b1_gLCD_ILI9341_SPI1__ClearDisplay();
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0a2b1_gLCD_ILI9341_SPI1__Initialise();

# 111 "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\PIC\PIC_CAL_SPI.c"
MX_UINT8 FC_CAL_SPI_Master_Init_1 (void);
void FC_CAL_SPI_Master_Uninit_1 (void);
MX_UINT8 FC_CAL_SPI_Master_Byte_1 (MX_UINT8 DataOut);
void FC_CAL_SPI_SetPrescaler_1 (MX_UINT8 Prescaler);

void FC_CAL_SPI_Slave_Init_1 (void);
void FC_CAL_SPI_Slave_Uninit_1 (void);
void FC_CAL_SPI_Slave_TxByte_1 (MX_UINT8 Data);
MX_UINT8 FC_CAL_SPI_Slave_RxByte_1 (void);

MX_UINT8 FC_CAL_SPI_Transaction_Init_1 (void);
MX_UINT8 FC_CAL_SPI_Transaction_1 (MX_UINT8* Buffer, MX_UINT16 Size, MX_UINT16 Length);
void FC_CAL_SPI_Transaction_Uninit_1 (void);

# 204
MX_UINT8 FC_CAL_SPI_Master_Init_1 (void)
{
MX_UINT8 retVal = 1;

{TRISC &= ~(1 << (5)); PORTC |= (1 << (5));};
TRISC |= (1 << (4));


{TRISC &= ~(1 << (3)); PORTC |= (1 << (3));};

# 232
SSPCON = 0 & 0x03;
SSPCONbits.CKP = (((1) & 0x01))?1:0;
SSPSTATbits.CKE = (((1) & 0x02))?1:0;
SSPSTATbits.SMP = (((1) & 0x04))?1:0;
SSPCONbits.SSPEN = 1;

# 256
return (retVal);
}


void FC_CAL_SPI_Master_Uninit_1 (void)
{




SSPCON = 0;

# 279
TRISC |= (1 << (5));
TRISC |= (1 << (4));
TRISC |= (1 << (3));
}


MX_UINT8 FC_CAL_SPI_Master_Byte_1 (MX_UINT8 DataOut)
{
MX_UINT8 retVal = 0;

# 369
SSPBUF = DataOut;
while ((SSPSTAT & 0x01) == 0);
retVal = SSPBUF;

# 387
return (retVal);
}


void FC_CAL_SPI_SetPrescaler_1 (MX_UINT8 Prescaler)
{

# 412
SSPCONbits.SSPEN = 0;
SSPCON = SSPCON & 0xFC;
SSPCON = SSPCON | (Prescaler & 0x03);
SSPCONbits.SSPEN = 1;

# 429
}

# 436
MX_UINT8 FC_CAL_SPI_Transaction_Init_1 (void)
{
 FC_CAL_SPI_Master_Init_1 ();
return 1;
}

MX_UINT8 FC_CAL_SPI_Transaction_1 (MX_UINT8* Buffer, MX_UINT16 Size, MX_UINT16 Length)
{
if (Length > Size) return 0;
MX_UINT16 n = 0;
while (n < Length)
{
Buffer[n] =  FC_CAL_SPI_Master_Byte_1 (Buffer[n]);
++n;
}
return 1;
}

void FC_CAL_SPI_Transaction_Uninit_1 (void)
{
 FC_CAL_SPI_Master_Uninit_1 ();
}

# 235 "test ecran 2.c"
void FCD_01531_cal_spi1__Master_Enable_CS()
{


MX_CHAR FCL_STR[20];

# 265
}

# 276
void FCD_01531_cal_spi1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_COLOUR, MX_UINT8 FCL_APPENDTIMESTAMP)
{


MX_CHAR FCL_TSTR[20];

# 292
}

# 299
void FCD_01531_cal_spi1__Prv_SimShowWaveform(MX_UINT8 FCL_RXDATA, MX_UINT16 FCL_TXDATA)
{



for (FCLV_LOOP1=0; (FCLV_LOOP1)<(8); (FCLV_LOOP1)++)
{

# 315
{TRISC &= ~(1<<3); (0) ? (PORTC = PORTC | (1<<3)) : (PORTC = PORTC & ~(1<<3));};

# 324
if (FCL_TXDATA & 0x80)
{


{TRISC &= ~(1<<5); (1) ? (PORTC = PORTC | (1<<5)) : (PORTC = PORTC & ~(1<<5));};

} else {


{TRISC &= ~(1<<5); (0) ? (PORTC = PORTC | (1<<5)) : (PORTC = PORTC & ~(1<<5));};

}



if (FCL_RXDATA & 0x80)
{


{TRISC &= ~(1<<4); (1) ? (PORTC = PORTC | (1<<4)) : (PORTC = PORTC & ~(1<<4));};

} else {


{TRISC &= ~(1<<4); (0) ? (PORTC = PORTC | (1<<4)) : (PORTC = PORTC & ~(1<<4));};

}

# 357
delay_us((4));

# 370
{TRISC &= ~(1<<3); (1) ? (PORTC = PORTC | (1<<3)) : (PORTC = PORTC & ~(1<<3));};

# 383
delay_us((4));

# 394
FCL_TXDATA = FCL_TXDATA << 1;
FCL_RXDATA = FCL_RXDATA << 1;


}

# 405
}

# 410
void FCD_01531_cal_spi1__Master_Disable_CS()
{


MX_CHAR FCL_STR[20];

# 440
}

# 452
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount()
{

MX_UINT16 FCR_RETVAL;



FCR_RETVAL = 475;

return (FCR_RETVAL);

}

# 479
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{

MX_UINT16 FCL_POSITION;
MX_UINT8 FCR_RETVAL;




if (FCL_POS_STR > 94)
{


FCR_RETVAL = 0xaa;

} else {


FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

FCR_RETVAL = FCD_00fb1_ASCIIData__INTLIST_LUT[FCL_POSITION];

}

# 508
return (FCR_RETVAL);

}

# 521
void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOn()
{

# 531
}

# 537
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(MX_UINT8 FCL_DATA)
{


{TRISC &= ~(1<<6); (0) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};

FC_CAL_SPI_Master_Byte_1(FCL_DATA);

}

# 557
void FCD_0a2b1_gLCD_ILI9341_SPI1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{


MX_CHAR FCL_TEMP[8];



FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,8);

FCD_0a2b1_gLCD_ILI9341_SPI1__Print(FCL_TEMP, 8, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);



}

# 582
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

MX_SINT16 FCL_C1;
MX_SINT16 FCL_M1;
MX_SINT16 FCL_D1 = (0);
MX_SINT16 FCL_PIXELX;
MX_SINT16 FCL_PIXELY;
MX_SINT16 FCL_YINC = (1);
MX_SINT16 FCL_XINC = (1);
MX_SINT16 FCL_X;
MX_SINT16 FCL_Y;




FCL_PIXELX = FCL_X2 - FCL_X1;
FCL_PIXELY = FCL_Y2 - FCL_Y1;



FCL_X = FCL_X1;
FCL_Y = FCL_Y1;

if (FCL_PIXELX < 0)
{



FCL_XINC = -1;
FCL_PIXELX = FCL_PIXELX * -1;



}

if (FCL_PIXELY < 0)
{



FCL_YINC = -1;
FCL_PIXELY = FCL_PIXELY * -1;



}

if (FCL_PIXELY <= FCL_PIXELX)
{



FCL_C1 = 2 * FCL_PIXELX;
FCL_M1 = 2 * FCL_PIXELY;

while (FCL_X != FCL_X2)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X, FCL_Y);


FCL_X = FCL_X + FCL_XINC;


FCL_D1 = FCL_D1 + FCL_M1;

if (FCL_D1 > FCL_PIXELX)
{


FCL_Y = FCL_Y + FCL_YINC;


FCL_D1 = FCL_D1 - FCL_C1;



}


}

} else {



FCL_C1 = 2 * FCL_PIXELY;
FCL_M1 = 2 * FCL_PIXELX;

while (FCL_Y != FCL_Y2)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X, FCL_Y);


FCL_Y = FCL_Y + FCL_YINC;


FCL_D1 = FCL_D1 + FCL_M1;

if (FCL_D1 > FCL_PIXELY)
{


FCL_X = FCL_X + FCL_XINC;


FCL_D1 = FCL_D1 - FCL_C1;



}


}

}

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X, FCL_Y);

}

# 709
void FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(MX_UINT8 FCL_DATA)
{


{TRISC &= ~(1<<6); (1) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};

FC_CAL_SPI_Master_Byte_1(FCL_DATA);

}

# 730
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

MX_SINT16 FCL_ERR;
MX_SINT16 FCL_CURX;
MX_SINT16 FCL_CURY;
MX_UINT32 FCL_BGCOL;
MX_UINT32 FCL_FGCOL;
MX_UINT8 FCL_REP = (0x0);
MX_SINT16 FCL_E2;
MX_FLOAT FCL_K;


if (FCL_SOLID == 1)
{

FCC_DrawEllipse_A:
;



FCL_CURX = 0;
FCL_CURY = 0 - FCL_YRADIUS;


FCL_ERR = 2 - (2 * FCL_XRADIUS);


FCL_K = (((float)(((float)(FCL_YRADIUS))) / (float)(((float)(FCL_XRADIUS)))));

while (1)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(((long)(((float)(((float)(FCL_X))) - (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y + FCL_CURY, ((long)(((float)(((float)(FCL_X))) + (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y + FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(((long)(((float)(((float)(FCL_X))) - (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y - FCL_CURY, ((long)(((float)(((float)(FCL_X))) + (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y - FCL_CURY);


FCL_E2 = FCL_ERR;

if (FCL_E2 <= FCL_CURX)
{



FCL_CURX = FCL_CURX + 1;
FCL_ERR = FCL_ERR + ((FCL_CURX * 2) + 1);

if ((0 - FCL_CURY == FCL_CURX) && (FCL_E2 <= FCL_CURY))
{


FCL_E2 = 0;



}



}

if (FCL_E2 > FCL_CURY)
{



FCL_CURY = FCL_CURY + 1;
FCL_ERR = FCL_ERR + ((FCL_CURY * 2) + 1);



}


if ((FCL_CURY <= 0) == 0) break;
}

} else {

if (FCL_TRANSPARENT == 1)
{

FCC_DrawEllipse_B:
;



FCL_CURX = 0;
FCL_CURY = 0 - FCL_YRADIUS;


FCL_ERR = 2 - (2 * FCL_XRADIUS);


FCL_K = (((float)(((float)(FCL_YRADIUS))) / (float)(((float)(FCL_XRADIUS)))));

while (1)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(((long)(((float)(((float)(FCL_X))) - (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y + FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(((long)(((float)(((float)(FCL_X))) + (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y + FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(((long)(((float)(((float)(FCL_X))) + (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y - FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(((long)(((float)(((float)(FCL_X))) - (float)((((float)(((float)(FCL_CURX))) / (float)(FCL_K))))))), FCL_Y - FCL_CURY);


FCL_E2 = FCL_ERR;

if (FCL_E2 <= FCL_CURX)
{



FCL_CURX = FCL_CURX + 1;
FCL_ERR = FCL_ERR + ((FCL_CURX * 2) + 1);

if ((0 - FCL_CURY == FCL_CURX) && (FCL_E2 <= FCL_CURY))
{


FCL_E2 = 0;



}



}

if (FCL_E2 > FCL_CURY)
{



FCL_CURY = FCL_CURY + 1;
FCL_ERR = FCL_ERR + ((FCL_CURY * 2) + 1);



}


if ((FCL_CURY <= 0) == 0) break;
}

} else {



FCL_FGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR;
FCL_BGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR;


FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_BGCOL;


FCL_REP = 1;

goto FCC_DrawEllipse_A;

}

}

if (FCL_REP == 1)
{


FCL_REP = FCL_REP + 1;


FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_FGCOL;

goto FCC_DrawEllipse_B;



}

}

# 922
void FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

MX_UINT16 FCL_TEMP;


switch (FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION)
{
case 1:
{



FCL_TEMP = 240 - (FCL_Y1 + 1);
FCL_Y1 = FCL_X1;
FCL_X1 = FCL_TEMP;

break;
}
case 2:
{


FCL_X1 = 240 - (FCL_X1 + 1);
FCL_Y1 = 320 - (FCL_Y1 + 1);

break;
}
case 3:
{



FCL_TEMP = FCL_Y1;
FCL_Y1 = 320 - (FCL_X1 + 1);
FCL_X1 = FCL_TEMP;

break;
}


}

FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1, FCL_Y1, FCL_X1, FCL_Y1);




{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 977
FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR >> 8);

FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR);




{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 991
}

# 997
void FCD_0a2b1_gLCD_ILI9341_SPI1__FastPlot()
{




{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1010
FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR >> 8);

FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR);




{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1024
}

# 1032
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{


FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION = FCL_ORIENTATION;

}

# 1044
void FCD_0a2b1_gLCD_ILI9341_SPI1__BacklightOff()
{

# 1054
}

# 1063
void FCD_0a2b1_gLCD_ILI9341_SPI1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

MX_UINT16 FCL_TEMP;


switch (FCV_0a2b1_gLCD_ILI9341_SPI1__ORIENTATION)
{
case 1:
{



FCL_TEMP = 240 - (FCL_Y1 + 1);
FCL_Y1 = FCL_X1;
FCL_X1 = FCL_TEMP;

break;
}
case 2:
{


FCL_X1 = 240 - (FCL_X1 + 1);
FCL_Y1 = 320 - (FCL_Y1 + 1);

break;
}
case 3:
{



FCL_TEMP = FCL_Y1;
FCL_Y1 = 320 - (FCL_X1 + 1);
FCL_X1 = FCL_TEMP;

break;
}


}

FCD_0a2b1_gLCD_ILI9341_SPI1__Window(FCL_X1, FCL_Y1, FCL_X1, FCL_Y1);


{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR >> 8);

FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR);


{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

}

# 1127
void FCD_0a2b1_gLCD_ILI9341_SPI1__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{




{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1144
{TRISC &= ~(1<<6); (0) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};

FC_CAL_SPI_Master_Byte_1(0x2A);


{TRISC &= ~(1<<6); (1) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};

FC_CAL_SPI_Master_Byte_1(FCL_X1 >> 8);

FC_CAL_SPI_Master_Byte_1(FCL_X1);

FC_CAL_SPI_Master_Byte_1(FCL_X2 >> 8);

FC_CAL_SPI_Master_Byte_1(FCL_X2);

# 1163
{TRISC &= ~(1<<6); (0) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};

FC_CAL_SPI_Master_Byte_1(0x2B);


{TRISC &= ~(1<<6); (1) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};

FC_CAL_SPI_Master_Byte_1(FCL_Y1 >> 8);

FC_CAL_SPI_Master_Byte_1(FCL_Y1);

FC_CAL_SPI_Master_Byte_1(FCL_Y2 >> 8);

FC_CAL_SPI_Master_Byte_1(FCL_Y2);

# 1182
{TRISC &= ~(1<<6); (0) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};

FC_CAL_SPI_Master_Byte_1(0x2C);


{TRISC &= ~(1<<6); (1) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};




{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1199
}

# 1211
void FCD_0a2b1_gLCD_ILI9341_SPI1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

MX_UINT8 FCL_XPIX;
MX_UINT8 FCL_YPIX;
MX_UINT8 FCL_POS_STR;
MX_UINT8 FCL_LEN_STR;
MX_UINT8 FCL_COUNT;
MX_UINT8 FCL_XCOUNT;
MX_UINT8 FCL_YCOUNT;
MX_UINT8 FCL_HEIGHT;
MX_UINT8 FCL_WIDTH;
MX_UINT8 FCL_IDX;
MX_UINT8 FCL_FONT_WIDTH = (0x1);
MX_UINT8 FCL_FONT_HEIGHT = (0x1);
MX_UINT8 FCL_POSITION;

MX_UINT8 FCL_TEMP[6];
MX_UINT8 FCL_DAT;


switch (FCL_FONT)
{
case 1:
{

FCL_FONT_WIDTH = 2;

break;
}
case 2:
{


FCL_FONT_WIDTH = 2;
FCL_FONT_HEIGHT = 2;

break;
}
case 3:
{

FCL_FONT_HEIGHT = 2;

break;
}
case 4:
{


FCL_FONT_WIDTH = 2;
FCL_FONT_HEIGHT = 3;

break;
}
case 5:
{


FCL_FONT_WIDTH = 2;
FCL_FONT_HEIGHT = 4;

break;
}
case 6:
{


FCL_FONT_WIDTH = 2;
FCL_FONT_HEIGHT = 5;

break;
}
case 7:
{


FCL_FONT_WIDTH = 2;
FCL_FONT_HEIGHT = 6;

break;
}
case 8:
{


FCL_FONT_WIDTH = 3;
FCL_FONT_HEIGHT = 1;

break;
}
case 9:
{


FCL_FONT_WIDTH = 3;
FCL_FONT_HEIGHT = 2;

break;
}
case 10:
{


FCL_FONT_WIDTH = 3;
FCL_FONT_HEIGHT = 3;

break;
}


}

switch (FCL_FONT)
{
case 11:
{


FCL_FONT_WIDTH = 3;
FCL_FONT_HEIGHT = 4;

break;
}
case 12:
{


FCL_FONT_WIDTH = 3;
FCL_FONT_HEIGHT = 5;

break;
}
case 13:
{


FCL_FONT_WIDTH = 3;
FCL_FONT_HEIGHT = 6;

break;
}
case 14:
{


FCL_FONT_WIDTH = 4;
FCL_FONT_HEIGHT = 1;

break;
}
case 15:
{


FCL_FONT_WIDTH = 4;
FCL_FONT_HEIGHT = 2;

break;
}
case 16:
{


FCL_FONT_WIDTH = 4;
FCL_FONT_HEIGHT = 3;

break;
}
case 17:
{


FCL_FONT_WIDTH = 4;
FCL_FONT_HEIGHT = 4;

break;
}
case 18:
{


FCL_FONT_WIDTH = 4;
FCL_FONT_HEIGHT = 5;

break;
}
case 19:
{


FCL_FONT_WIDTH = 4;
FCL_FONT_HEIGHT = 6;

break;
}
case 20:
{


FCL_FONT_WIDTH = 5;
FCL_FONT_HEIGHT = 1;

break;
}


}

switch (FCL_FONT)
{
case 21:
{


FCL_FONT_WIDTH = 5;
FCL_FONT_HEIGHT = 2;

break;
}
case 22:
{


FCL_FONT_WIDTH = 5;
FCL_FONT_HEIGHT = 3;

break;
}
case 23:
{


FCL_FONT_WIDTH = 5;
FCL_FONT_HEIGHT = 4;

break;
}
case 24:
{


FCL_FONT_WIDTH = 5;
FCL_FONT_HEIGHT = 5;

break;
}
case 25:
{


FCL_FONT_WIDTH = 5;
FCL_FONT_HEIGHT = 6;

break;
}
case 26:
{


FCL_FONT_WIDTH = 6;
FCL_FONT_HEIGHT = 1;

break;
}
case 27:
{


FCL_FONT_WIDTH = 6;
FCL_FONT_HEIGHT = 2;

break;
}
case 28:
{


FCL_FONT_WIDTH = 6;
FCL_FONT_HEIGHT = 3;

break;
}
case 29:
{


FCL_FONT_WIDTH = 6;
FCL_FONT_HEIGHT = 4;

break;
}
case 30:
{


FCL_FONT_WIDTH = 6;
FCL_FONT_HEIGHT = 5;

break;
}


}

switch (FCL_FONT)
{
case 31:
{


FCL_FONT_WIDTH = 6;
FCL_FONT_HEIGHT = 6;

break;
}


}




FCL_XCOUNT = 0;
FCL_IDX = 0;
FCL_TEMP[5] = 0;


FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

while (FCL_IDX < FCL_LEN_STR)
{


FCL_POS_STR = FCL_STR[FCL_IDX] - 32;


FCL_COUNT = 0;

while (FCL_COUNT < 5)
{

FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);


FCL_COUNT = FCL_COUNT + 1;


}


FCL_TEMP[FCL_COUNT] = 0;


FCL_XPIX = 0;

while (FCL_XPIX < 6)
{


FCL_WIDTH = 0;

while (FCL_WIDTH < FCL_FONT_WIDTH)
{


FCL_YCOUNT = 0;


FCL_YPIX = 0;


{TRISC &= ~(1<<6); (1) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};


{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

while (FCL_YPIX < 8)
{


FCL_HEIGHT = 0;

while (FCL_HEIGHT < FCL_FONT_HEIGHT)
{

if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
{

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

} else {

if (FCL_TRANSPARENT == 0)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);



}

}



FCL_HEIGHT = FCL_HEIGHT + 1;
FCL_YCOUNT = FCL_YCOUNT + 1;


}


FCL_YPIX = FCL_YPIX + 1;


}

# 1636
FCL_WIDTH = FCL_WIDTH + 1;
FCL_XCOUNT = FCL_XCOUNT + 1;


}


FCL_XPIX = FCL_XPIX + 1;


}


FCL_IDX = FCL_IDX + 1;


}



}

# 1661
void FCD_0a2b1_gLCD_ILI9341_SPI1__ClearDisplay()
{

MX_UINT16 FCL_Y = (0x0);
MX_UINT16 FCL_X = (0x0);


FCD_0a2b1_gLCD_ILI9341_SPI1__Window(0, 0, 240 - 1, 320 - 1);


{TRISC &= ~(1<<6); (1) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};




{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1683
while (FCL_Y < 320)
{


FCL_X = 0;

while (FCL_X < 240)
{

FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR >> 8);

FC_CAL_SPI_Master_Byte_1(FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR);


FCL_X = FCL_X + 1;


}


FCL_Y = FCL_Y + 1;


}




{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 1718
}

# 1728
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{




FCL_RED = FCL_RED >> (8 - 5);
FCL_GREEN = FCL_GREEN >> (8 - 6);
FCL_BLUE = FCL_BLUE >> (8 - 5);



FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR = FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

# 1755
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

MX_SINT16 FCL_D;
MX_SINT16 FCL_CURX;
MX_SINT16 FCL_CURY;
MX_UINT32 FCL_BGCOL;
MX_UINT32 FCL_FGCOL;
MX_UINT8 FCL_REP = (0x0);


if (FCL_SOLID == 1)
{

FCC_DrawCircle_A:
;


FCL_D = 3 - (FCL_RADIUS << 1);



FCL_CURX = 0;
FCL_CURY = FCL_RADIUS;

while (FCL_CURX <= FCL_CURY)
{

if (FCL_CURY > 0)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURY, FCL_Y + FCL_CURX, FCL_X + FCL_CURY, FCL_Y + FCL_CURX);

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURY, FCL_Y - FCL_CURX, FCL_X + FCL_CURY, FCL_Y - FCL_CURX);



}

if (FCL_CURX > 0)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURX, FCL_Y - FCL_CURY, FCL_X + FCL_CURX, FCL_Y - FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X - FCL_CURX, FCL_Y + FCL_CURY, FCL_X + FCL_CURX, FCL_Y + FCL_CURY);



}

if (FCL_D < 0)
{


FCL_D = FCL_D + ((FCL_CURX << 2) + 6);

} else {


FCL_D = FCL_D + (((FCL_CURX - FCL_CURY) << 2) + 10);


FCL_CURY = FCL_CURY - 1;

}


FCL_CURX = FCL_CURX + 1;


}

} else {

if (FCL_TRANSPARENT == 1)
{

FCC_DrawCircle_B:
;


FCL_D = 3 - (FCL_RADIUS << 1);



FCL_CURX = 0;
FCL_CURY = FCL_RADIUS;

while (FCL_CURX <= FCL_CURY)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURX, FCL_Y - FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURX, FCL_Y - FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURY, FCL_Y - FCL_CURX);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURY, FCL_Y - FCL_CURX);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURX, FCL_Y + FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURX, FCL_Y + FCL_CURY);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X + FCL_CURY, FCL_Y + FCL_CURX);

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X - FCL_CURY, FCL_Y + FCL_CURX);

if (FCL_D < 0)
{


FCL_D = FCL_D + ((FCL_CURX << 2) + 6);

} else {


FCL_D = FCL_D + (((FCL_CURX - FCL_CURY) << 2) + 10);


FCL_CURY = FCL_CURY - 1;

}


FCL_CURX = FCL_CURX + 1;


}

} else {



FCL_FGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR;
FCL_BGCOL = FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR;


FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_BGCOL;


FCL_REP = 1;

goto FCC_DrawCircle_A;

}

}

if (FCL_REP == 1)
{


FCL_REP = FCL_REP + 1;


FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_FGCOL;

goto FCC_DrawCircle_B;



}

}

# 1928
void FCD_0a2b1_gLCD_ILI9341_SPI1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{




FCL_RED = FCL_RED >> (8 - 5);
FCL_GREEN = FCL_GREEN >> (8 - 6);
FCL_BLUE = FCL_BLUE >> (8 - 5);



FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

# 1956
void FCD_0a2b1_gLCD_ILI9341_SPI1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

MX_UINT16 FCL_XMIN;
MX_UINT16 FCL_XMAX;
MX_UINT16 FCL_YMIN;
MX_UINT16 FCL_YMAX;


FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

FCD_0a2b1_gLCD_ILI9341_SPI1__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

if (FCL_TRANSPARENT == 0)
{

if (FCL_X1 > FCL_X2)
{



FCL_XMAX = FCL_X1;
FCL_XMIN = FCL_X2 + 1;

} else {



FCL_XMAX = FCL_X2;
FCL_XMIN = FCL_X1 + 1;

}

if (FCL_Y1 > FCL_Y2)
{



FCL_YMAX = FCL_Y1;
FCL_YMIN = FCL_Y2 + 1;

} else {



FCL_YMAX = FCL_Y2;
FCL_YMIN = FCL_Y1 + 1;

}


FCL_Y1 = FCL_YMIN;

while (FCL_Y1 < FCL_YMAX)
{


FCL_X1 = FCL_XMIN;

while (FCL_X1 < FCL_XMAX)
{

if (FCL_SOLID)
{

FCD_0a2b1_gLCD_ILI9341_SPI1__Plot(FCL_X1, FCL_Y1);

} else {

FCD_0a2b1_gLCD_ILI9341_SPI1__BPlot(FCL_X1, FCL_Y1);

}


FCL_X1 = FCL_X1 + 1;


}


FCL_Y1 = FCL_Y1 + 1;


}



}

}

# 2054
void FCD_0a2b1_gLCD_ILI9341_SPI1__Initialise()
{

FC_CAL_SPI_Master_Init_1();


{TRISC &= ~(1<<7); (1) ? (PORTC = PORTC | (1<<7)) : (PORTC = PORTC & ~(1<<7));};

delay_ms((5));


{TRISC &= ~(1<<7); (0) ? (PORTC = PORTC | (1<<7)) : (PORTC = PORTC & ~(1<<7));};

delay_ms((5));



{TRISC &= ~(1<<6); (0) ? (PORTC = PORTC | (1<<6)) : (PORTC = PORTC & ~(1<<6));};
{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};


{TRISC &= ~(1<<7); (1) ? (PORTC = PORTC | (1<<7)) : (PORTC = PORTC & ~(1<<7));};

delay_ms((5));


{TRISC &= ~(1<<2); (0) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xCB);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x39);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x2C);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x34);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x02);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xCF);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0xC1);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x30);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xE8);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x85);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x78);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xEA);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xED);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x64);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x03);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x12);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x81);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xF7);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x20);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC0);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x23);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC1);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x10);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC5);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x3E);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x28);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xC7);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x86);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x36);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x48);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x3A);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x55);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xB1);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x18);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xB6);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x08);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x82);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x27);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xF2);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x26);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x01);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xE0);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0F);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x31);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x2B);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0C);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0E);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x08);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x4E);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0xF1);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x37);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x07);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x10);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x3);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0E);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x09);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0xE1);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x00);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0E);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x14);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x03);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x11);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x07);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x31);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0xC1);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x48);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x08);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0F);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0C);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x31);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x36);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Data8(0x0F);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x11);

delay_ms((120));

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x29);

FCD_0a2b1_gLCD_ILI9341_SPI1__LCD_Write_Reg(0x2C);




{TRISC &= ~(1<<2); (1) ? (PORTC = PORTC | (1<<2)) : (PORTC = PORTC & ~(1<<2));};

# 2262
FCV_0a2b1_gLCD_ILI9341_SPI1__FOREGROUND_COL_VAR = 18463;
FCV_0a2b1_gLCD_ILI9341_SPI1__BACKGROUND_COL_VAR = 63496;

FCD_0a2b1_gLCD_ILI9341_SPI1__ClearDisplay();

}

# 2279
void main()
{
ADCON1 = 0x07;

OPTION_REG = 0xC0;



FCD_0a2b1_gLCD_ILI9341_SPI1__Initialise();


FCD_0a2b1_gLCD_ILI9341_SPI1__DrawCircle(120, 210, 50, 0, 1);

mainendloop: goto mainendloop;
}

# 2300
void interrupt myisr(void)
{

}

